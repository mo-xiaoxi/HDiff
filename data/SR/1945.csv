sentences
"This specification reflects common usage of the protocol referred too as ""HTTP/1.0""."
"Those features which have few or inconsistent implementations are listed in Appendix D.
Practical information systems require more functionality than simple retrieval, including search, front-end update, and annotation."
"HTTP is also used as a generic protocol for communication between user agents and proxies/gateways to other Internet protocols, such as SMTP [12], NNTP [11], FTP [14], Gopher [1], and WAIS [8], allowing basic hypermedia access to resources available from diverse applications and simplifying the implementation of user agents."
Proxies are often used as client-side portals through network firewalls and as helper applications for handling requests via protocols not implemented by the user agent.
"Unlike a proxy, a gateway receives requests as if it were the origin server for the requested resource; the requesting client may not be aware that it is communicating with a gateway."
"Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel may have been initiated by an HTTP request."
"Tunnels are used when a portal is necessary and the intermediary cannot, or should not, interpret the relayed communication."
"A program's local store of response messages and the subsystem that controls its message storage, retrieval, and deletion."
"A cache stores cachable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests."
A tunnel acts as a relay point between two connections without changing the messages; tunnels are used when the communication needs to pass through an intermediary (such as a firewall) even when the intermediary cannot understand the contents of the messages.
Any party to the communication which is not acting as a tunnel may employ an internal cache for handling requests.
The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request which has not been cached by UA or A.
"Not all responses are cachable, and some requests may contain modifiers which place special requirements on cache behavior."
"Some HTTP/1.0 applications use heuristics to describe what is or is not a ""cachable"" response, but these rules are not standardized."
"This does not preclude HTTP from being implemented on top of any other protocol on the Internet, or on other networks."
"Except for experimental applications, current practice requires that the connection be established by the client prior to each request and closed by the server after sending the response."
"Both clients and servers should be aware that either party may close the connection prematurely, due to user action, automated time-out, or program failure, and should handle such closing in a predictable fashion."
"The name of a rule is simply the name itself (without any enclosing ""<"" and "">"") and is separated from its definition by the equal character ""=""."
Whitespace is only significant in that indentation of continuation lines is used to indicate a rule definition that spans more than one line.
"Certain basic rules are in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc."
Angle brackets are used within definitions whenever their presence will facilitate discerning the use of rule names.
"Unless stated otherwise, the text is case-insensitive."
"Elements separated by a bar (""I"") are alternatives, e.g., ""yes | no"" will accept yes or no."
Elements enclosed in parentheses are treated as a single element.
"The character ""*"" preceding an element indicates repetition."
"Square brackets enclose optional elements; ""[foo bar]"" is equivalent to ""*1(foo bar)""."
"The full form is ""<n>#<m>element"" indicating at least <n> and at most <m> elements, each separated by one or more commas ("","") and optional linear whitespace (LWS)."
"Wherever this construct is used, null elements are allowed, but do not contribute to the count of elements present."
"However, applications should attempt to follow ""common form"" when generating HTTP constructs, since there exist some implementations that fail to accept anything beyond the common forms."
The US-ASCII coded character set is defined by [17].
"However, folding of header lines is not expected by some applications, and should not be generated by HTTP/1.0 applications."
The TEXT rule is only used for descriptive field contents and values that are not intended to be interpreted by the message parser.
A string of text is parsed as a single word if it is quoted using double-quote marks.
"Single-character quoting using the backslash (""\"") character is not permitted in HTTP/1.0.
HTTP uses a ""<major>.<minor>"" numbering scheme to indicate versions of the protocol."
"The <minor> number is incremented when the changes made to the protocol add features which do not change the general message parsing algorithm, but which may add to the message semantics and imply additional capabilities of the sender."
The <major> number is incremented when the format of a message within the protocol is changed.
The version of an HTTP message is indicated by an HTTP-Version field in the first line of the message.
"If the protocol version is not specified, the recipient must assume that the message is in the simple HTTP/0.9 format."
"Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is lower than HTTP/12.3."
Leading zeros should be ignored by recipients and never generated by senders.
"Since the protocol version indicates the protocol capability of the sender, a proxy/gateway must never send a message with a version indicator which is greater than its native version; if a higher version request is received, the proxy/gateway must either downgrade the request version or respond with an error."
The two forms are differentiated by the fact that absolute URIs always begin with a scheme name followed by a colon.
"The BNF above includes national characters not allowed in valid URLs as specified by RFC 1738, since HTTP servers are not restricted in the set of unreserved characters allowed to represent the rel_path part of addresses, and HTTP proxies may receive requests for URIs not defined by RFC 1738."
This section defines the scheme-specific syntax and semantics for http URLs.
"If the port is empty or not given, port 80 is assumed."
"The semantics are that the identified resource is located at the server listening for TCP connections on that port of that host, and the Request-URI for the resource is abs_path."
"If the abs_path is not present in the URL, it must be given as ""/"" when used as a Request-URI (Section 5.1.2)."
"The canonical form for ""http"" URLs is obtained by converting any UPALPHA characters in host to their LOALPHA equivalent (hostnames are case-insensitive), eliding the [ "":"" port ] if the port is 80, and replacing an empty abs_path with ""/""."
"The second format is in common use, but is based on the obsolete RFC 850 [10] date format and lacks a four-digit year."
"HTTP/1.0 clients and servers that parse the date value should accept all three formats, though they must never generate the third (asctime) format."
"Clients and servers are not required to use these formats for user presentation, request logging, etc."
"Note that unconditional conversion in the other direction is not required, in that not all characters may be available in a given character set and a character set may provide more than one sequence of octets to represent a particular character."
"In particular, use of external profiling information to determine the exact mapping is not permitted."
"This use of the term ""character set"" is more commonly referred to as a ""character encoding."""
"The character set of an entity body should be labelled as the lowest common denominator of the character codes used within that body, with the exception that no label is preferred over the labels US-ASCII or ISO-8859-1."
"Note: For future compatibility, HTTP/1.0 applications should consider ""gzip"" and ""compress"" to be equivalent to ""x-gzip"" and ""x-compress"", respectively."
"An encoding format produced by the file compression program ""gzip"" (GNU zip) developed by Jean-loup Gailly."
"The encoding format produced by the file compression program ""compress""."
Note: Use of program names for the identification of encoding formats is not desirable and should be discouraged for future encodings.
"Their use here is representative of historical practice, not good design."
"The type, subtype, and parameter attribute names are case- insensitive."
"LWS must not be generated between the type and subtype, nor between an attribute and its value."
"Upon receipt of a media type with an unrecognized parameter, a user agent should treat the media type as if the unrecognized parameter and its value were not present."
Some older HTTP applications do not recognize media type parameters.
Use of non-registered media types is discouraged.
"Media subtypes of the ""text"" type use CRLF as the text line break when in canonical form."
"HTTP applications must accept CRLF, bare CR, and bare LF as being representative of a line break in text media received via HTTP."
"In addition, if the text media is represented in a character set that does not use octets 13 and 10 for CR and LF respectively, as is the case for some multi-byte character sets, HTTP allows the use of whatever octet sequences are defined by that character set to represent the equivalent of CR and LF for line breaks."
This flexibility regarding line breaks applies only to text media in the Entity-Body; a bare CR or LF should not be substituted for CRLF within any of the HTTP control structures (such as header fields and multipart boundaries).
"The ""charset"" parameter is used with some media types to define the character set (Section 3.4) of the data."
"When no explicit charset parameter is provided by the sender, media subtypes of the ""text"" type are defined to have a default charset value of ""ISO-8859-1"" when received via HTTP."
"Data in character sets other than ""ISO-8859-1"" or its subsets must be labelled with an appropriate charset value in order to be consistently interpreted by the recipient."
"Note: Many current HTTP servers provide data using charsets other than ""ISO-8859-1"" without proper labelling."
This situation reduces interoperability and is not recommended.
"To compensate for this, some HTTP user agents provide a configuration option to allow the user to change the default interpretation of the media type character set when no charset parameter is given."
HTTP servers should not assume that all HTTP clients are prepared to handle multipart types.
The message body is itself a protocol element and must therefore use only CRLF to represent line breaks between body-parts.
"Most fields using product tokens also allow subproducts which form a significant part of the application to be listed, separated by whitespace."
Product tokens should be short and to the point -- use of them for advertizing or other non-essential information is explicitly forbidden.
"The entity body is separated from the headers by a null line (i.e., a line with nothing preceding the CRLF)."
Simple-Request and Simple-Response do not allow the use of any header information and are limited to a single request method (GET).
Use of the Simple-Request format is discouraged because it prevents the server from identifying the media type of the returned entity.
Field names are case-insensitive.
"Header fields can be extended over multiple lines by preceding each extra line with at least one SP or HT, though this is not recommended."
The order in which header fields are received is not significant.
"However, it is ""good practice"" to send General-Header fields first, followed by Request-Header or Response-Header fields prior to the Entity-Header fields."
"It must be possible to combine the multiple header fields into one ""field- name: field-value"" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma."
"There are a few header fields which have general applicability for both request and response messages, but which do not apply to the entity being transferred."
"If an HTTP/1.0 server receives a Simple-Request, it must respond with an HTTP/0.9 Simple-Response."
An HTTP/1.0 client capable of receiving a Full-Response should never generate a Simple-Request.
"The Request-Line begins with a method token, followed by the Request-URI and the protocol version, and ending with CRLF."
No CR or LF are allowed except in the final CRLF sequence.
The list of methods acceptable by a specific resource can change dynamically; the client is notified through the return code of the response if a method is not allowed on a resource.
Servers should return the status code 501 (not implemented) if the method is unrecognized or not implemented.
"Note that the absolute path cannot be empty; if none is present in the original URI, it must be given as ""/"" (the server root)."
"The Request-URI is transmitted as an encoded string, where some characters may be escaped using the ""% HEX HEX"" encoding defined by RFC 1738 [4]."
A Simple-Response should only be sent in response to an HTTP/0.9 Simple-Request or if the server only supports the more limited HTTP/0.9 protocol.
"If a client sends an HTTP/1.0 Full-Request and receives a response that does not begin with a Status-Line, it should assume that the response is a Simple-Response and parse it accordingly."
Note that the Simple-Response consists only of the entity body and is terminated by the server closing the connection.
"No CR or LF is allowed except in the final CRLF sequence.
e.g., ""HTTP/1.0 200 ""), the presence of that expression is sufficient to differentiate a Full-Response from a Simple-Response."
"Although the Simple-Response format may allow such an expression to occur at the beginning of an entity body, and thus cause a misinterpretation of the message if it was given in response to a Full-Request, most HTTP/0.9 servers are limited to responses of type ""text/html"" and therefore would never generate such a response."
o 2xx: Success -
"The action was successfully received, understood, and accepted."
"HTTP applications are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable."
"However, applications must understand the class of any status code, as indicated by the first digit, and treat any unrecognized response as being equivalent to the x00 status code of that class, with the exception that an unrecognized response must not be cached."
"For example, if an unrecognized status code of 431 is received by the client, it can safely assume that there was something wrong with its request and treat the response as if it had received a 400 status code."
The response header fields allow the server to pass additional information about the response which cannot be placed in the Status- Line.
Unrecognized header fields should be ignored by the recipient and forwarded by proxies.
The presence of an entity body in a request is signaled by the inclusion of a Content-Length header field in the request message headers.
"All responses to the HEAD request method must not include a body, even though the presence of entity header fields may lead one to believe they do."
"All 1xx (informational), 204 (no content), and 304 (not modified) responses must not include a body."
"The default for the content encoding is none (i.e., the identity function)."
Any HTTP/1.0 message containing an entity body should include a Content-Type header field defining the media type of that body.
"If and only if the media type is not given by a Content-Type header, as is the case for Simple-Response messages, the recipient may attempt to guess the media type via inspection of its content and/or the name extension(s) of the URL used to identify the resource."
"Closing the connection cannot be used to indicate the end of a request body, since it leaves no possibility for the server to send back a response."
"If a request contains an entity body and Content-Length is not specified, and the server does not recognize or cannot calculate the length from other fields, then the server should send a 400 (bad request) response."
Note: Some older servers supply an invalid Content-Length when sending a document that contains server-side includes dynamically inserted into the data stream.
It must be emphasized that this will not be tolerated by future versions of HTTP.
"Unless the client knows that it is receiving a response from a compliant server, it should not depend on the Content-Length value being correct."
The set of common methods for HTTP/1.0 is defined below.
"If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process."
The conditional GET method is intended to reduce network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring unnecessary data.
The HEAD method is identical to GET except that the server must not return any Entity-Body in the response.
This method can be used for obtaining metainformation about the resource identified by the Request-URI without transferring the Entity-Body itself.
"There is no ""conditional HEAD"" request analogous to the conditional GET."
"If an If-Modified-Since header field is included with a HEAD request, it should be ignored."
The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI.
A successful POST does not require that the entity be created as a resource on the origin server or made accessible for future reference.
"In this case, either 200 (ok) or 204 (no content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result."
A valid Content-Length is required on all HTTP/1.0 POST requests.
An HTTP/1.0 server should respond with a 400 (bad request) message if it cannot determine the length of the request message's content.
Applications must not cache responses to a POST request because the application has no way of knowing that the server would return an equivalent response on some future request.
"This class of status code indicates a provisional response, consisting only of the Status-Line and optional headers, and is terminated by an empty line."
HTTP/1.0 does not define any 1xx status codes and they are not a valid response to a HTTP/1.0 request.
The origin server should create the resource before using this Status-Code.
"The request has been accepted for processing, but the processing has not been completed."
"The request may or may not eventually be acted upon, as it may be disallowed when processing actually takes place."
There is no facility for re-sending a status code from an asynchronous operation such as this.
The 202 response is intentionally non-committal.
Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed.
The server has fulfilled the request but there is no new information to send back.
"If the client is a user agent, it should not change its document view from that which caused the request to be generated."
The action required may be carried out by the user agent without interaction with the user if and only if the method used in the subsequent request is GET or HEAD.
"A user agent should never automatically redirect a request more than 5 times, since such redirections usually indicate an infinite loop."
"This response code is not directly used by HTTP/1.0 applications, but serves as the default for interpreting the 3xx class of responses."
The requested resource has been assigned a new permanent URL and any future references to this resource should be done using that URL.
"If the 301 status code is received in response to a request using the POST method, the user agent must not automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued."
"If the 302 status code is received in response to a request using the POST method, the user agent must not automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued."
"If the client has performed a conditional GET request and access is allowed, but the document has not been modified since the date and time specified in the If-Modified-Since field, the server must respond with this status code and not send an Entity-Body to the client."
The 4xx class of status code is intended for cases in which the client seems to have erred.
"If the client has not completed the request when a 4xx code is received, it should immediately cease sending data to the server."
"Except when responding to a HEAD request, the server should include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition."
"If the client is sending data, server implementations on TCP should be careful to ensure that the client acknowledges receipt of the packet(s) containing the response prior to closing the input connection."
"If the client continues sending data to the server after the close, the server's controller will send a reset packet to the client, which may erase the client's unacknowledged input buffers before they can be read and interpreted by the HTTP application."
The request could not be understood by the server due to malformed syntax.
The client should not repeat the request without modifications.
"If the request already included Authorization credentials, then the 401 response indicates that authorization has been refused for those credentials."
"If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user should be presented the entity that was given in the response, since that entity may include relevant diagnostic information."
"The server understood the request, but is refusing to fulfill it."
Authorization will not help and the request should not be repeated.
"If the request method was not HEAD and the server wishes to make public why the request has not been fulfilled, it should describe the reason for the refusal in the entity body."
"This status code is commonly used when the server does not wish to reveal exactly why the request has been refused, or when no other response is applicable."
The server has not found anything matching the Request-URI.
No indication is given of whether the condition is temporary or permanent.
"If the server does not wish to make this information available to the client, the status code 403 (forbidden) can be used instead."
"Response status codes beginning with the digit ""5"" indicate cases in which the server is aware that it has erred or is incapable of performing the request."
"If the client has not completed the request when a 5xx code is received, it should immediately cease sending data to the server."
"Except when responding to a HEAD request, the server should include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition."
These response codes are applicable to any request method and there are no required header fields.
The server does not support the functionality required to fulfill the request.
This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.
"The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request."
The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.
The implication is that this is a temporary condition which will be alleviated after some delay.
The existence of the 503 status code does not imply that a server must use it when becoming overloaded.
"The Allow header field is not permitted in a request using the POST method, and thus should be ignored if it is received as part of a POST entity."
This field cannot prevent a client from trying other methods.
"A proxy must not modify the Allow header field even if it does not understand all the methods specified, since the user agent may have other means of communicating with the origin server."
The Allow header field does not indicate what methods are implemented by the server.
"A user agent that wishes to authenticate itself with a server-- usually, but not necessarily, after receiving a 401 response--may do so by including an Authorization request-header field with the request."
The Authorization field value consists of credentials containing the authentication information of the user agent for the realm of the resource being requested.
"If a request is authenticated and a realm specified, the same credentials should be valid for all other requests within this realm."
Responses to requests containing an Authorization field are not cachable.
"When present, its value indicates what additional content coding has been applied to the resource, and thus what decoding mechanism must be applied in order to obtain the media-type referenced by the Content-Type header field."
The Content-Encoding is primarily used to allow a document to be compressed without losing the identity of its underlying media type.
Any Content-Length greater than or equal to zero is a valid value.
Section 7.2.2 describes how to determine the length of a response entity body if a Content-Length is not given.
"The meaning of this field is significantly different from the corresponding definition in MIME, where it is an optional field used within the ""message/external-body"" content-type."
"The field value is an HTTP-date, as described in Section 3.3."
A received message which does not have a Date header field should be assigned one by the recipient if the message will be cached by that recipient or gatewayed via a protocol which requires a Date.
This has been changed to reflect actual (and proper) usage.
The Expires entity-header field gives the date/time after which the entity should be considered stale.
"This allows information providers to suggest the volatility of the resource, or a date after which the information may no longer be valid."
Applications must not cache this entity beyond the date given.
"The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time."
"If the date given is equal to or earlier than the value of the Date header, the recipient must not cache the enclosed entity."
"If a resource is dynamic by nature, as is the case with many data- producing processes, entities from that resource should be given an appropriate Expires value which reflects that dynamism."
"By default, the Expires field does not apply to history mechanisms."
Note: Applications are encouraged to be tolerant of bad or misinformed implementations of the Expires header.
"A value of zero (0) or an invalid date format should be considered equivalent to an ""expires immediately."""
"Although these values are not legitimate for HTTP/1.0, a robust implementation is always desirable."
This header field may be used for logging purposes and as a means for identifying the source of invalid or unwanted requests.
It should not be used as an insecure form of access protection.
"In particular, robot agents should include this header so that the person responsible for running the robot can be contacted if problems occur on the receiving end."
"The client should not send the From header field without the user's approval, as it may conflict with the user's privacy interests or their site's security policy."
"The If-Modified-Since request-header field is used with the GET method to make it conditional: if the requested resource has not been modified since the time specified in this field, a copy of the resource will not be returned from the server; instead, a 304 (not modified) response will be returned without any Entity-Body.
a)"
"If the request would normally result in anything other than a 200 (ok) status, or if the passed If-Modified-Since date is invalid, the response is exactly the same as for a normal GET."
A date which is later than the server's current time is invalid.
"If the resource has been modified since the If-Modified-Since date, the response is exactly the same as for a normal GET.
c)"
"If the resource has not been modified since a valid If-Modified-Since date, the server shall return a 304 (not modified) response."
The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead.
The Last-Modified entity-header field indicates the date and time at which the sender believes the resource was last modified.
"The exact semantics of this field are defined in terms of how the recipient should interpret it:  if the recipient has a copy of this resource which is older than the date given by the Last-Modified field, that copy should be considered stale."
"For files, it may be just the file system last-modified time."
An origin server must not send a Last-Modified date which is later than the server's time of message origination.
The Pragma general-header field is used to include implementation- specific directives that may apply to any recipient along the request/response chain.
"When the ""no-cache"" directive is present in a request message, an application should forward the request toward the origin server even if it has a cached copy of what is being requested."
It also allows a client to refresh a cached copy which is known to be corrupted or stale.
"It is not possible to specify a pragma for a specific recipient; however, any pragma directive not relevant to a recipient should be ignored by that recipient."
"The Referer request-header field allows the client to specify, for the server's benefit, the address (URI) of the resource from which the Request-URI was obtained."
"This allows a server to generate lists of back-links to resources for interest, logging, optimized caching, etc."
"The Referer field must not be sent if the Request-URI was obtained from a source that does not have its own URI, such as input from the user keyboard."
The URI must not include a fragment.
"For example, a browser client could have a toggle switch for browsing openly/anonymously, which would respectively enable/disable the sending of Referer and From information."
"If the response is being forwarded through a proxy, the proxy application must not add its data to the product list."
Note: Revealing the specific software version of the server may allow the server machine to become more vulnerable to attacks against software that is known to contain security holes.
Server implementors are encouraged to make this field a configurable option.
Note: Some existing servers fail to restrict themselves to the product token syntax within the Server field.
"This is for statistical purposes, the tracing of protocol violations, and automated recognition of user agents for the sake of tailoring responses to avoid particular user agent limitations."
"Although it is not required, user agents should include this field with requests."
"This is not recommended, since it makes machine interpretation of these fields ambiguous."
Note: Some existing clients fail to restrict themselves to the product token syntax within the User-Agent field.
"It uses an extensible, case-insensitive token to identify the authentication scheme, followed by a comma-separated list of attribute-value pairs which carry the parameters necessary for achieving authentication via that scheme."
The 401 (unauthorized) response message is used by an origin server to challenge the authorization of a user agent.
"A user agent that wishes to authenticate itself with a server-- usually, but not necessarily, after receiving a 401 response--may do so by including an Authorization header field with the request."
The Authorization field value consists of credentials containing the authentication information of the user agent for the realm of the resource being requested.
"Unless otherwise defined by the authentication scheme, a single protection space cannot extend outside the scope of its server."
"If the server does not wish to accept the credentials sent with a request, it should return a 403 (forbidden) response."
The HTTP protocol does not restrict applications to this simple challenge-response mechanism for access authentication.
"However, these additional mechanisms are not defined by this specification."
"That is, they must forward the WWW-Authenticate and Authorization headers untouched, and must not cache the response to a request containing Authorization."
HTTP/1.0 does not provide a means for a client to be authenticated with a proxy.
The realm value should be considered an opaque string which can only be compared for equality with other realms on that server.
There are no optional authentication parameters.
It is based on the assumption that the connection between the client and the server can be regarded as a trusted carrier.
"As this is not generally true on an open network, the basic authentication scheme should be used accordingly."
"The discussion does not include definitive solutions to the problems revealed, though it does make some suggestions for reducing security risks."
"As mentioned in Section 11.1, the Basic authentication scheme is not a secure method of user authentication, nor does it prevent the Entity-Body from being transmitted in clear text across the physical network used as the carrier."
HTTP/1.0 does not prevent additional authentication schemes and encryption mechanisms from being employed to increase security.
"In particular, the convention has been established that the GET and HEAD methods should never have the significance of taking an action other than retrieval."
"These methods should be considered ""safe."""
"Naturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a GET request; in fact, some dynamic resources consider that a feature."
"The important distinction here is that the user did not request the side-effects, so therefore cannot be held accountable for them."
People using the HTTP protocol to provide data are responsible for ensuring that such material is not distributed without the permission of any individuals that are identifiable by the published results.
"Like any generic data transfer protocol, HTTP cannot regulate the content of the data that is transferred, nor is there any a priori method of determining the sensitivity of any particular piece of information within the context of any given request."
Implementors should make the Server header field a configurable option.
"Although it can be very useful, its power can be abused if user details are not separated from the information contained in the Referer."
"Even when the personal information has been removed, the Referer field may indicate a private document's URI whose publication would be inappropriate."
"The information sent in the From field might conflict with the user's privacy interests or their site's security policy, and hence it should not be transmitted without the user being able to disable, enable, and modify the contents of the field."
The user must be able to set the contents of this field within a user preference or application defaults configuration.
"We suggest, though do not require, that a convenient toggle interface be provided for the user to enable or disable the sending of From and Referer information."
Implementations of HTTP origin servers should be careful to restrict the documents returned by HTTP requests to be only those that were intended by the server administrators.
"If an HTTP server translates HTTP URIs directly into file system calls, the server must take special care not to serve files that were not intended to be delivered to HTTP clients."
"Similarly, files intended for reference only internally to the server (such as access control files, configuration files, and script code) must be protected from inappropriate retrieval, since they might contain sensitive information."
Experience has shown that minor bugs in such HTTP server implementations have turned into security risks.
This specification makes heavy use of the augmented BNF and generic constructs defined by David H. Crocker for RFC 822 [7].
These appendices are provided for informational reasons only -- they do not form a part of the HTTP/1.0 specification.
"The message type -- ""request"" or ""response""."
"Although this document specifies the requirements for the generation of HTTP/1.0 messages, not all applications will be correct in their implementation."
Clients should be tolerant in parsing the Status-Line and servers tolerant when parsing the Request-Line.
The line terminator for HTTP-header fields is the sequence CRLF.
"However, we recommend that applications, when parsing such headers, recognize a single LF as a line terminator and ignore the leading CR."
"These differences were carefully chosen to optimize performance over binary connections, to allow greater freedom in the use of new media types, to make date comparisons easier, and to acknowledge the practice of some early HTTP servers and clients."
"Section 3.6.1 of this document describes the forms allowed for subtypes of the ""text"" media type when transmitted over HTTP."
"RFC 1521 requires that content with a Content-Type of ""text"" represent line breaks as CRLF and forbids the use of CR or LF outside of line break sequences."
"HTTP allows CRLF, bare CR, and bare LF to indicate a line break within text content when a message is transmitted over HTTP."
"Where it is possible, a proxy or gateway from HTTP to a strict RFC 1521 environment should translate all line breaks within the text media types described in Section 3.6.1 of this document to the RFC 1521 canonical form of CRLF."
"Note, however, that this may be complicated by the presence of a Content-Encoding and by the fact that HTTP allows the use of some character sets which do not use octets 13 and 10 to represent CR and LF, as is the case for some multi-byte character sets."
HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC 1521.
"Proxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where ""safe transport"" is defined by the limitations of the protocol being used."
"In RFC 1521, most header fields in multipart body-parts are generally ignored unless the field name begins with ""Content-""."
"In HTTP/1.0, multipart body-parts may contain any HTTP header fields which are significant to the meaning of that part."
"This appendix documents protocol elements used by some existing HTTP implementations, but not consistently and correctly across most HTTP/1.0 applications."
"If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI."
"In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server should not apply the request to some other resource."
The set of ranges given by the client should represent what types are acceptable given the context of the request.
This field allows clients capable of understanding more comprehensive or special-purpose character sets to signal that capability to a server which is capable of representing documents in those character sets.
"The Accept-Encoding request-header field is similar to Accept, but restricts the content-coding values which are acceptable in the response."
"Unfortunately, some older HTTP/1.0 servers send it indiscriminately, and thus this field should be ignored."
The Retry-After response-header field can be used with a 503 (service unavailable) response to indicate how long the service is expected to be unavailable to the requesting client.
There is no guarantee that the resource can be accessed using the URI(s) specified.
