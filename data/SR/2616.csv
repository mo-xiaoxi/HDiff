sentences
"The first version of HTTP, referred to as HTTP/0.9, was a simple protocol for raw data transfer across the Internet."
"HTTP/1.0, as defined by RFC 1945 [6], improved the protocol by allowing messages to be in the format of MIME-like messages, containing metainformation about the data transferred and modifiers on the request/response semantics."
"However, HTTP/1.0 does not sufficiently take into consideration the effects of hierarchical proxies, caching, the need for persistent connections, or virtual hosts."
"In addition, the proliferation of incompletely-implemented applications calling themselves ""HTTP/1.0"" has necessitated a protocol version change in order for two communicating applications to determine each other's true capabilities."
This protocol includes more stringent requirements than HTTP/1.0 in order to ensure reliable implementation of its features.
"Practical information systems require more functionality than simple retrieval, including search, front-end update, and annotation."
"In this way, HTTP allows basic hypermedia access to resources available from diverse applications."
"The key words ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"", ""SHOULD"", ""SHOULD NOT"", ""RECOMMENDED"", ""MAY"", and ""OPTIONAL"" in this document are to be interpreted as described in RFC 2119 [34]."
The representation of entities in any response can be negotiated (including error responses).
Use of the term `variant' does not necessarily imply that the resource is subject to content negotiation.
An application program that accepts connections in order to service requests by sending back responses.
"A ""transparent proxy"" is a proxy that does not modify the request or response beyond what is required for proxy authentication and identification."
"Unlike a proxy, a gateway receives requests as if it were the origin server for the requested resource; the requesting client may not be aware that it is communicating with a gateway."
"Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel may have been initiated by an HTTP request."
The tunnel ceases to exist when both ends of the relayed connections are closed.
"cache A program's local store of response messages and the subsystem that controls its message storage, retrieval, and deletion."
"A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests."
"Any client or server may include a cache, though a cache cannot be used by a server that is acting as a tunnel."
A response is cacheable if a cache is allowed to store a copy of the response message for use in answering subsequent requests.
"Even if a resource is cacheable, there may be additional constraints on whether a cache can use the cached copy for a particular request."
"A response is first-hand if it comes directly and without unnecessary delay from the origin server, perhaps via one or more proxies."
The time at which the origin server intends that an entity should no longer be returned by a cache without further validation.
An expiration time assigned by a cache when no explicit expiration time is available.
"The age of a response is the time since it was sent by, or successfully validated with, the origin server."
freshness lifetime
fresh A response is fresh if its age has not yet exceeded its freshness lifetime.
stale
A response is stale if its age has passed its freshness lifetime.
"semantically transparent A cache behaves in a ""semantically transparent"" manner, with respect to a particular response, when its use affects neither the requesting client nor the origin server, except to improve performance."
"When a cache is semantically transparent, the client receives exactly the same response (except for hop-by-hop headers) that it would have received had its request been handled directly by the origin server."
"A protocol element (e.g., an entity tag or a Last-Modified time) that is used to find out whether a cache entry is an equivalent copy of an entity."
Most HTTP communication is initiated by a user agent and consists of a request to be applied to a resource on some origin server.
A tunnel acts as a relay point between two connections without changing the messages; tunnels are used when the communication needs to pass through an intermediary (such as a firewall) even when the intermediary cannot understand the contents of the messages.
Any party to the communication which is not acting as a tunnel may employ an internal cache for handling requests.
The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request.
The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request which has not been cached by UA or A.
"Not all responses are usefully cacheable, and some requests may contain modifiers which place special requirements on cache behavior."
"HTTP systems are used in corporate intranets over high-bandwidth links, and for access via PDAs with low-power radio links and intermittent connectivity."
"The goal of HTTP/1.1 is to support the wide diversity of configurations already deployed while introducing protocol constructs that meet the needs of those who build web applications that require high reliability and, failing that, at least reliable indications of failure."
HTTP communication usually takes place over TCP/IP connections.
"This does not preclude HTTP from being implemented on top of any other protocol on the Internet, or on other networks."
"In HTTP/1.0, most implementations used a new connection for each request/response exchange."
"Unless stated otherwise, the text is case-insensitive."
"Elements separated by a bar (""|"") are alternatives, e.g., ""yes | no"" will accept yes or no.
rule1 rule2)"
"Thus, ""(elem (foo | bar) elem)"" allows the token sequences ""elem foo elem"" and ""elem bar elem""."
"The full form is ""<n>*<m>element"" indicating at least <n> and at most <m> occurrences of element."
"This makes the usual form of lists very easy; a rule such as ( *LWS element *( *LWS "","" *LWS element )) can be shown as 1#element Wherever this construct is used, null elements are allowed, but do not contribute to the count of elements present."
"Therefore, where at least one element is required, at least one non-null element MUST be present."
"Default values are 0 and infinity so that ""#element"" allows any number, including zero; ""1#element"" requires at least one; and ""1#2element"" allows one or two."
"This is a simple way of including useful notes in parallel with the specifications.
separators) MUST exist between any two tokens (for the definition of ""token"" below), since they would otherwise be interpreted as a single token."
The TEXT rule is only used for descriptive field contents and values that are not intended to be interpreted by the message parser.
A CRLF is allowed in the definition of TEXT only as part of a header field continuation.
It is expected that the folding LWS will be replaced with a single SP before interpretation of the TEXT value.
A string of text is parsed as a single word if it is quoted using double-quote marks.
"The backslash character (""\"") MAY be used as a single-character quoting mechanism only within quoted-string and comment constructs."
"HTTP uses a ""<major>.<minor>"" numbering scheme to indicate versions of the protocol."
"The protocol versioning policy is intended to allow the sender to indicate the format of a message and its capacity for understanding further HTTP communication, rather than the features obtained via that communication."
No change is made to the version number for the addition of message components which do not affect communication behavior or which only add to extensible field values.
"The <minor> number is incremented when the changes made to the protocol add features which do not change the general message parsing algorithm, but which may add to the message semantics and imply additional capabilities of the sender."
The <major> number is incremented when the format of a message within the protocol is changed.
The version of an HTTP message is indicated by an HTTP-Version field in the first line of the message.
Note that the major and minor numbers MUST be treated as separate integers and that each MAY be incremented higher than a single digit.
"Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is lower than HTTP/12.3."
Leading zeros MUST be ignored by recipients and MUST NOT be sent.
"Applications that are at least conditionally compliant with this specification SHOULD use an HTTP-Version of ""HTTP/1.1"" in their messages, and MUST do so for any message that is not compatible with HTTP/1.0."
The HTTP version of an application is the highest HTTP version for which the application is at least conditionally compliant.
"Since the protocol version indicates the protocol capability of the sender, a proxy/gateway MUST NOT send a message with a version indicator which is greater than its actual version."
"If a higher version request is received, the proxy/gateway MUST either downgrade the request version, or respond with an error, or switch to tunnel behavior."
"Due to interoperability problems with HTTP/1.0 proxies discovered since the publication of RFC 2068[33], caching proxies MUST, gateways MAY, and tunnels MUST NOT upgrade the request to the highest version they support."
The two forms are differentiated by the fact that absolute URIs always begin with a scheme name followed by a colon.
The HTTP protocol does not place any a priori limit on the length of a URI.
A server SHOULD return 414 (Request-URI Too Long) status if a URI is longer than the server can handle (see section 10.4.15).
"Note: Servers ought to be cautious about depending on URI lengths above 255 bytes, because some older client or proxy implementations might not properly support these lengths."
"The ""http"" scheme is used to locate network resources via the HTTP protocol."
"If the port is empty or not given, port 80 is assumed."
"The semantics are that the identified resource is located at the server listening for TCP connections on that port of that host, and the Request-URI for the resource is abs_path (section 5.1.2)."
The use of IP addresses in URLs SHOULD be avoided whenever possible (see RFC 1900 [24]).
"If the abs_path is not present in the URL, it MUST be given as ""/"" when used as a Request-URI for a resource (section 5.1.2)."
"If a proxy receives a host name which is not a fully qualified domain name, it MAY add its domain to the host name it received."
"If a proxy receives a fully qualified domain name, the proxy MUST NOT change the host name."
"An empty abs_path is equivalent to an abs_path of ""/""."
"Characters other than those in the ""reserved"" and ""unsafe"" sets (see RFC 2396 [42]) are equivalent to their """"%"" HEX HEX"" encoding."
"The second format is in common use, but is based on the obsolete RFC 850 [12] date format and lacks a four-digit year."
"HTTP/1.1 clients and servers that parse the date value MUST accept all three formats (for compatibility with HTTP/1.0), though they MUST only generate the RFC 1123 format for representing HTTP-date values in header fields."
"All HTTP date/time stamps MUST be represented in Greenwich Mean Time (GMT), without exception."
HTTP-date is case sensitive and MUST NOT include additional LWS beyond that specifically included as SP in the grammar.
"Clients and servers are not required to use these formats for user presentation, request logging, etc."
"Some HTTP header fields allow a time value to be specified as an integer number of seconds, represented in decimal, after the time that the message was received."
"Note that unconditional conversion in the other direction is not required, in that not all characters may be available in a given character set and a character set may provide more than one sequence of octets to represent a particular character."
"In particular, use of external profiling information to determine the exact mapping is not permitted."
"This use of the term ""character set"" is more commonly referred to as a ""character encoding."""
HTTP character sets are identified by case-insensitive tokens.
"Although HTTP allows an arbitrary token to be used as a charset value, any token that has a predefined value within the IANA Character Set registry [19]"
"Some HTTP/1.0 software has interpreted a Content-Type header without charset parameter incorrectly to mean ""recipient should guess."""
Senders wishing to defeat this behavior MAY include a charset parameter even when the charset is ISO-8859-1 and SHOULD do so when it is known that it will not confuse the recipient.
"Unfortunately, some older HTTP/1.0 clients did not deal properly with an explicit charset parameter."
"HTTP/1.1 recipients MUST respect the charset label provided by the sender; and those user agents that have a provision to ""guess"" a charset MUST use the charset from the content-type field if they support that charset, rather than the recipient's preference, when initially displaying a document."
Content codings are primarily used to allow a document to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information.
"Frequently, the entity is stored in coded form, transmitted directly, and only decoded by the recipient."
All content-coding values are case-insensitive.
HTTP/1.1 uses content-coding values in the Accept-Encoding (section 14.3) and Content-Encoding (section 14.11) header fields.
"Although the value describes the content-coding, what is more important is that it indicates what decoding mechanism will be required to remove the encoding."
"An encoding format produced by the file compression program ""gzip"" (GNU zip) as described in RFC 1952 [25]."
"The encoding format produced by the common UNIX file compression program ""compress""."
Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.
"Their use here is representative of historical practice, not good design."
"For compatibility with previous implementations of HTTP, applications SHOULD consider ""x-gzip"" and ""x-compress"" to be equivalent to ""gzip"" and ""compress"" respectively."
"The ""zlib"" format defined in RFC 1950 [31] in combination with the ""deflate"" compression mechanism described in RFC 1951 [29]."
The default (identity) encoding; the use of no transformation whatsoever.
"This content-coding is used only in the Accept- Encoding header, and SHOULD NOT be used in the Content-Encoding header."
"New content-coding value tokens SHOULD be registered; to allow interoperability between clients and servers, specifications of the content coding algorithms needed to implement a new value SHOULD be publicly available and adequate for independent implementation, and conform to the purpose of content coding defined in this section."
"This differs from a content coding in that the transfer-coding is a property of the message, not of the original entity."
All transfer-coding values are case-insensitive.
"Whenever a transfer-coding is applied to a message-body, the set of transfer-codings MUST include ""chunked"", unless the message is terminated by closing the connection."
"When the ""chunked"" transfer- coding is used, it MUST be the last transfer-coding applied to the message-body."
"The ""chunked"" transfer-coding MUST NOT be applied more than once to a message-body."
"Transfer-codings are analogous to the Content-Transfer-Encoding values of MIME [7], which were designed to enable safe transport of binary data over a 7-bit transport service."
"However, safe transport has a different focus for an 8bit-clean transfer protocol."
"In HTTP, the only unsafe characteristic of message-bodies is the difficulty in determining the exact body length (section 7.2.2), or the desire to encrypt data over a shared transport."
"Initially, the registry contains the following tokens: ""chunked"" (section 3.6.1), ""identity"" (section 3.6.2), ""gzip"" (section 3.5), ""compress"" (section 3.5), and ""deflate"" (section 3.5)."
New transfer-coding value tokens SHOULD be registered in the same way as new content-coding value tokens (section 3.5).
"A server which receives an entity-body with a transfer-coding it does not understand SHOULD return 501 (Unimplemented), and close the connection."
A server MUST NOT send transfer-codings to an HTTP/1.0 client.
"The chunked encoding modifies the body of a message in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer containing entity-header fields."
This allows dynamically produced content to be transferred along with the information necessary for the recipient to verify that it has received the full message.
The chunk-size field is a string of hex digits indicating the size of the chunk.
"The chunked encoding is ended by any chunk whose size is zero, followed by the trailer, which is terminated by an empty line."
"b)the server is the origin server for the response, the trailer fields consist entirely of optional metadata, and the recipient could use the message (in a manner acceptable to the origin server) without receiving this metadata."
"In other words, the origin server is willing to accept the possibility that the trailer fields might be silently discarded along the path to the client."
This requirement prevents an interoperability failure when the message is being received by an HTTP/1.1 (or later) proxy and forwarded to an HTTP/1.0 recipient.
It avoids a situation where compliance with the protocol would have necessitated a possibly infinite buffer on the proxy.
"All HTTP/1.1 applications MUST be able to receive and decode the ""chunked"" transfer-coding, and MUST ignore chunk-extension extensions they do not understand."
"The type, subtype, and parameter attribute names are case- insensitive."
"Linear white space (LWS) MUST NOT be used between the type and subtype, nor between an attribute and its value."
Note that some older HTTP applications do not recognize media type parameters.
"When sending data to older HTTP applications, implementations SHOULD only use media type parameters when they are required by that type/subtype definition."
Use of non-registered media types is discouraged.
"An entity-body transferred via HTTP messages MUST be represented in the appropriate canonical form prior to its transmission except for ""text"" types, as defined in the next paragraph."
"When in canonical form, media subtypes of the ""text"" type use CRLF as the text line break."
"HTTP applications MUST accept CRLF, bare CR, and bare LF as being representative of a line break in text media received via HTTP."
"In addition, if the text is represented in a character set that does not use octets 13 and 10 for CR and LF respectively, as is the case for some multi-byte character sets, HTTP allows the use of whatever octet sequences are defined by that character set to represent the equivalent of CR and LF for line breaks."
This flexibility regarding line breaks applies only to text media in the entity-body; a bare CR or LF MUST NOT be substituted for CRLF within any of the HTTP control structures (such as header fields and multipart boundaries).
"The ""charset"" parameter is used with some media types to define the character set (section 3.4) of the data."
"When no explicit charset parameter is provided by the sender, media subtypes of the ""text"" type are defined to have a default charset value of ""ISO-8859-1"" when received via HTTP."
"Data in character sets other than ""ISO-8859-1"" or its subsets MUST be labeled with an appropriate charset value."
The message body is itself a protocol element and MUST therefore use only CRLF to represent line breaks between body-parts.
"Unlike in RFC 2046, the epilogue of any multipart message MUST be empty; HTTP applications MUST NOT transmit the epilogue (even if the original multipart contains an epilogue)."
"These restrictions exist in order to preserve the self-delimiting nature of a multipart message- body, wherein the ""end"" of the message-body is indicated by the ending multipart boundary."
"In general, HTTP treats a multipart message-body no differently than any other media type: strictly as payload."
"The one exception is the ""multipart/byteranges"" type (appendix 19.2) when it appears in a 206 (Partial Content) response, which will be interpreted by some HTTP caching mechanisms as described in sections 13.5.4 and 14.16."
"In all other cases, an HTTP user agent SHOULD follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type."
The MIME header fields within each body-part of a multipart message- body do not have any significance to HTTP beyond that defined by their MIME semantics.
"In general, an HTTP user agent SHOULD follow the same or similar behavior as a MIME user agent would upon receipt of a multipart type."
"If an application receives an unrecognized multipart subtype, the application MUST treat it as being equivalent to ""multipart/mixed""."
Product tokens are used to allow communicating applications to identify themselves by software name and version.
Product tokens SHOULD be short and to the point.
"HTTP content negotiation (section 12) uses short ""floating point"" numbers to indicate the relative importance (""weight"") of various negotiable parameters."
"A weight is normalized to a real number in the range 0 through 1, where 0 is the minimum and 1 the maximum value."
"If a parameter has a quality value of 0, then content with this parameter is `not acceptable' for the client."
HTTP/1.1 applications MUST NOT generate more than three digits after the decimal point.
"Quality values"" is a misnomer, since these values merely represent relative degradation in desired quality."
The definition of how they are used and compared as cache validators is in section 13.3.3.
"An entity tag consists of an opaque quoted string, possibly prefixed by a weakness indicator."
"A ""weak entity tag,"" indicated by the ""W/"" prefix, MAY be shared by two entities of a resource only if the entities are equivalent and could be substituted for each other with no significant change in semantics."
A weak entity tag can only be used for weak comparison.
An entity tag MUST be unique across all versions of all entities associated with a particular resource.
The use of the same entity tag value in conjunction with entities obtained by requests on different URIs does not imply the equivalence of those entities.
An entity can be broken down into subranges according to various structural units.
"The only range unit defined by HTTP/1.1 is ""bytes""."
HTTP/1.1 has been designed to allow implementations of applications that do not depend on knowledge of ranges.
HTTP messages consist of requests from client to server and responses from server to client.
"Both types of message consist of a start-line, zero or more header fields (also known as ""headers""), an empty line (i.e., a line with nothing preceding the CRLF) indicating the end of the header fields, and possibly a message-body."
"In the interest of robustness, servers SHOULD ignore any empty line(s) received where a Request-Line is expected."
"In other words, if the server is reading the protocol stream at the beginning of a message and receives a CRLF first, it should ignore the CRLF."
Certain buggy HTTP/1.0 client implementations generate extra CRLF's after a POST request.
"To restate what is explicitly forbidden by the BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an extra CRLF."
"Each header field consists of a name followed by a colon ("":"") and the field value."
Field names are case-insensitive.
Header fields can be extended over multiple lines by preceding each extra line with at least one SP or HT.
"Applications ought to follow ""common form"", where one is known or indicated, when generating HTTP constructs, since there might exist some implementations that fail to accept anything beyond the common forms."
The field-content does not include any leading or trailing LWS: linear white space occurring before the first non-whitespace character of the field-value or after the last non-whitespace character of the field-value.
Such leading or trailing LWS MAY be removed without changing the semantics of the field value.
Any LWS that occurs between field-content MAY be replaced with a single SP before interpreting the field value or forwarding the message downstream.
The order in which header fields with differing field names are received is not significant.
"However, it is ""good practice"" to send general-header fields first, followed by request-header or response- header fields, and ending with the entity-header fields."
"It MUST be possible to combine the multiple header fields into one ""field-name: field-value"" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma."
"The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded."
"The message-body differs from the entity-body only when a transfer-coding has been applied, as indicated by the Transfer-Encoding header field (section 14.41)."
The rules for when a message-body is allowed in a message differ for requests and responses.
The presence of a message-body in a request is signaled by the inclusion of a Content-Length or Transfer-Encoding header field in the request's message-headers.
A message-body MUST NOT be included in a request if the specification of the request method (section 5.1.1) does not allow sending an entity-body in requests.
"A server SHOULD read and forward a message-body on any request; if the request method does not include defined semantics for an entity-body, then the message-body SHOULD be ignored when handling the request."
"For response messages, whether or not a message-body is included with a message is dependent on both the request method and the response status code (section 6.1.1)."
"All responses to the HEAD request method MUST NOT include a message-body, even though the presence of entity- header fields might lead one to believe they do."
"All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a message-body."
"Any response message which ""MUST NOT"" include a message-body (such as the 1xx, 204, and 304 responses and any response to a HEAD request) is always terminated by the first empty line after the header fields, regardless of the entity-header fields present in the message."
"If a Transfer-Encoding header field (section 14.41) is present and has any value other than ""identity"", then the transfer-length is defined by use of the ""chunked"" transfer-coding (section 3.6), unless the message is terminated by closing the connection."
"The Content-Length header field MUST NOT be sent if these two lengths are different (i.e., if a Transfer-Encoding header field is present)."
"If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored."
"If the message uses the media type ""multipart/byteranges"", and the ransfer-length is not otherwise specified, then this self- elimiting media type defines the transfer-length."
This media type UST NOT be used unless the sender knows that the recipient can arse it; the presence in a request of a Range header with ultiple byte- range specifiers from a 1.1 client implies that the lient can parse multipart/byteranges responses.
"A range header might be forwarded by a 1.0 proxy that does not understand multipart/byteranges; in this case the server MUST delimit the message using methods defined in items 1,3 or 5 of this section."
"For compatibility with HTTP/1.0 applications, HTTP/1.1 requests containing a message-body MUST include a valid Content-Length header field unless the server is known to be HTTP/1.1 compliant."
"If a request contains a message-body and a Content-Length is not given, the server SHOULD respond with 400 (bad request) if it cannot determine the length of the message, or with 411 (length required) if it wishes to insist on receiving a valid Content-Length."
"All HTTP/1.1 applications that receive entities MUST accept the ""chunked"" transfer-coding (section 3.6), thus allowing this mechanism to be used for messages when the message length cannot be determined in advance."
Messages MUST NOT include both a Content-Length header field and a non-identity transfer-coding.
"If the message does include a non- identity transfer-coding, the Content-Length MUST be ignored."
HTTP/1.1 user agents MUST notify the user when an invalid length is received and detected.
"There are a few header fields which have general applicability for both request and response messages, but which do not apply to the entity being transferred."
Unrecognized header fields are treated as entity-header fields.
"The Request-Line begins with a method token, followed by the Request-URI and the protocol version, and ending with CRLF."
No CR or LF is allowed except in the final CRLF sequence.
The list of methods allowed by a resource can be specified in an Allow header field (section 14.7).
"The return code of the response always notifies the client whether a method is currently allowed on a resource, since the set of allowed methods can change dynamically."
"An origin server SHOULD return the status code 405 (Method Not Allowed) if the method is known by the origin server but not allowed for the requested resource, and 501 (Not Implemented) if the method is unrecognized or not implemented by the origin server."
The methods GET and HEAD MUST be supported by all general-purpose servers.
"URIs in all requests in future versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI form in requests, even though HTTP/1.1 clients will only generate them in requests to proxies."
"Note that the absolute path cannot be empty; if none is present in the original URI, it MUST be given as ""/"" (the server root)."
"A transparent proxy MUST NOT rewrite the ""abs_path"" part of the received Request-URI when forwarding it to the next inbound server, except as noted above to replace a null abs_path with ""/""."
"The ""no rewrite"" rule prevents the proxy from changing the meaning of the request when the origin server is improperly using a non-reserved URI character for a reserved purpose."
Implementors should be aware that some pre-HTTP/1.1 proxies have been known to rewrite the Request-URI.
The exact resource identified by an Internet request is determined by examining both the Request-URI and the Host header field.
Any Host header field value in the request MUST be ignored.
If the Request-URI is not an absolute
"URI, and the request includes a Host header field, the host is determined by the Host header field value."
"If the host as determined by rule 1 or 2 is not a valid host on the server, the response MUST be a 400 (Bad Request) error message."
"Recipients of an HTTP/1.0 request that lacks a Host header field MAY attempt to use heuristics (e.g., examination of the URI path for something unique to a particular host) in order to determine what exact resource is being requested."
"The request-header fields allow the client to pass additional information about the request, and about the client itself, to the server."
Unrecognized header fields are treated as entity-header fields.
"After receiving and interpreting a request message, a server responds with an HTTP response message."
No CR or LF is allowed except in the final CRLF sequence.
"The individual values of the numeric status codes defined for HTTP/1.1, and an example set of corresponding Reason-Phrase's, are presented below."
The reason phrases listed here are only recommendations -- they MAY be replaced by local equivalents without affecting the protocol.
"HTTP applications are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable."
"However, applications MUST understand the class of any status code, as indicated by the first digit, and treat any unrecognized response as being equivalent to the x00 status code of that class, with the exception that an unrecognized response MUST NOT be cached."
"For example, if an unrecognized status code of 431 is received by the client, it can safely assume that there was something wrong with its request and treat the response as if it had received a 400 status code."
"In such cases, user agents SHOULD present to the user the entity returned with the response, since that entity is likely to include human- readable information which will explain the unusual status."
The response-header fields allow the server to pass additional information about the response which cannot be placed in the Status- Line.
These header fields give information about the server and about further access to the resource identified by the Request-URI.
Unrecognized header fields are treated as entity-header fields.
Request and Response messages MAY transfer an entity if not otherwise restricted by the request method or response status code.
"In this section, both sender and recipient refer to either the client or the server, depending on who sends and who receives the entity."
"Entity-header fields define metainformation about the entity-body or, if no body is present, about the resource identified by the request."
Some of this metainformation is OPTIONAL; some might be REQUIRED by portions of this specification.
Unrecognized header fields SHOULD be ignored by the recipient and MUST be forwarded by transparent proxies.
"Content-Encoding may be used to indicate any additional content codings applied to the data, usually for the purpose of data compression, that are a property of the requested resource."
There is no default encoding.
"If and only if the media type is not given by a Content-Type field, the recipient MAY attempt to guess the media type via inspection of its content and/or the name extension(s) of the URI used to identify the resource."
"If the media type remains unknown, the recipient SHOULD treat it as type ""application/octet-stream""."
The entity-length of a message is the length of the message-body before any transfer-codings have been applied.
"Prior to persistent connections, a separate TCP connection was established to fetch each URL, increasing the load on HTTP servers and causing congestion on the Internet."
Analysis of these performance problems and results from a prototype implementation are available [26] [30].
Implementation experience and measurements of actual HTTP/1.1 (RFC 2068) implementations show good results [39].
"Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time."
"Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network."
Latency on subsequent requests is reduced since there is no time spent in TCP's connection opening handshake.
"HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection."
"Clients using future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old semantics after an error is reported."
A significant difference between HTTP/1.1 and earlier versions of HTTP is that persistent connections are the default behavior of any HTTP connection.
"That is, unless otherwise indicated, the client SHOULD assume that the server will maintain a persistent connection, even after error responses from the server."
Persistent connections provide a mechanism by which a client and a server can signal the close of a TCP connection.
"Once a close has been signaled, the client MUST NOT send any more requests on that connection."
"An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to maintain a persistent connection unless a Connection header including the connection-token ""close"" was sent in the request."
"If the server chooses to close the connection immediately after sending the response, it SHOULD send a Connection header including the connection-token close."
"An HTTP/1.1 client MAY expect a connection to remain open, but would decide to keep it open based on whether the response from a server contains a Connection header with the connection-token close."
"In case the client does not want to maintain a connection for more than that request, it SHOULD send a Connection header including the connection-token close."
Clients and servers SHOULD NOT assume that a persistent connection is maintained for HTTP versions less than 1.1 unless it is explicitly signaled.
"In order to remain persistent, all messages on the connection MUST have a self-defined message length (i.e., one not defined by closure of the connection), as described in section 4.4."
"A client that supports persistent connections MAY ""pipeline"" its requests (i.e., send multiple requests without waiting for each response)."
A server MUST send its responses to those requests in the same order that the requests were received.
Clients which assume persistent connections and pipeline immediately after connection establishment SHOULD be prepared to retry their connection if the first pipelined attempt fails.
"If a client does such a retry, it MUST NOT pipeline before it knows the connection is persistent."
Clients MUST also be prepared to resend their requests if the server closes the connection before sending all of the corresponding responses.
Clients SHOULD NOT pipeline requests using non-idempotent methods or non-idempotent sequences of methods (see section 9.1.2).
"Otherwise, a premature termination of the transport connection could lead to indeterminate results."
A client wishing to send a non-idempotent request SHOULD wait to send that request until it has received the response status for the previous request.
It is especially important that proxies correctly implement the properties of the Connection header field as specified in section 14.10.
A proxy server MUST NOT establish a HTTP/1.1 persistent connection with an HTTP/1.0 client (but see RFC 2068 [33] for information and discussion of the problems with the Keep-Alive header implemented by many HTTP/1.0 clients).
Servers will usually have some time-out value beyond which they will no longer maintain an inactive connection.
Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same server.
The use of persistent connections places no requirements on the length (or existence) of this time-out for either the client or the server.
When a client or server wishes to time-out it SHOULD issue a graceful close on the transport connection.
"Clients and servers SHOULD both constantly watch for the other side of the transport close, and respond to it as appropriate."
If a client or server does not detect the other side's close promptly it could cause unnecessary resource drain on the network.
"For example, a client might have started to send a new request at the same time that the server has decided to close the ""idle"" connection."
"From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress."
Client software SHOULD reopen the transport connection and retransmit the aborted sequence of requests without user interaction so long as the request sequence is idempotent (see section 9.1.2).
"Non-idempotent methods or sequences MUST NOT be automatically retried, although user agents MAY offer a human operator the choice of retrying the request(s)."
The automatic retry SHOULD NOT be repeated if the second sequence of requests fails.
"Servers SHOULD always respond to at least one request per connection, if at all possible."
"Servers SHOULD NOT close a connection in the middle of transmitting a response, unless a network or client failure is suspected."
Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server.
A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy.
"A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users."
These guidelines are intended to improve HTTP response times and avoid congestion.
"HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's flow control mechanisms to resolve temporary overloads, rather than terminating connections with the expectation that clients will retry."
The latter technique can exacerbate network congestion.
An HTTP/1.1 (or later) client sending a message-body SHOULD monitor the network connection for an error status while it is transmitting the request.
"If the client sees an error status, it SHOULD immediately cease transmitting the body."
"If the body is being sent using a ""chunked"" encoding (section 3.6), a zero length chunk and empty trailer MAY be used to prematurely mark the end of the message."
"If the body was preceded by a Content-Length header, the client MUST close the connection."
"In some cases, it might either be inappropriate or highly inefficient for the client to send the body if the server will reject the message without looking at the body."
"If a client will wait for a 100 (Continue) response before sending the request body, it MUST send an Expect request-header field (section 14.20) with the ""100-continue"" expectation."
"A client MUST NOT send an Expect request-header field (section 14.20) with the ""100-continue"" expectation if it does not intend to send a request body."
"Because of the presence of older implementations, the protocol allows ambiguous situations in which a client may send ""Expect: 100- continue"" without receiving either a 417 (Expectation Failed) status or a 100 (Continue) status."
"Therefore, when a client sends this header field to an origin server (possibly via a proxy) from which it has never seen a 100 (Continue) status, the client SHOULD NOT wait for an indefinite period before sending the request body."
The origin server MUST NOT wait for the request body before sending the 100 (Continue) response.
It MUST NOT perform the requested method if it returns a final status code.
"An origin server SHOULD NOT send a 100 (Continue) response if the request message does not include an Expect request-header field with the ""100-continue"" expectation, and MUST NOT send a 100 (Continue) response if such a request comes from an HTTP/1.0 (or earlier) client."
"There is an exception to this rule: for compatibility with RFC 2068, a server MAY send a 100 (Continue) status in response to an HTTP/1.1 PUT or POST request that does not include an Expect request-header field with the ""100- continue"" expectation."
"This exception, the purpose of which is to minimize any client processing delays associated with an undeclared wait for 100 (Continue) status, applies only to HTTP/1.1 requests, and not to requests with any other HTTP- version value."
"An origin server that sends a 100 (Continue) response MUST ultimately send a final status code, once the request body is received and processed, unless it terminates the transport connection prematurely."
"If an origin server receives a request that does not include an Expect request-header field with the ""100-continue"" expectation, the request includes a request body, and the server responds with a final status code before reading the entire request body from the transport connection, then the server SHOULD NOT close the transport connection until it has read the entire request, or until the client closes the connection."
"Otherwise, the client might not reliably receive the response message."
"However, this requirement is not be construed as preventing a server from defending itself against denial-of-service attacks, or from badly broken client implementations."
"If the proxy knows that the version of the next-hop server is HTTP/1.0 or lower, it MUST NOT forward the request, and it MUST respond with a 417 (Expectation Failed) status."
Proxies SHOULD maintain a cache recording the HTTP version numbers received from recently-referenced next-hop servers.
"A proxy MUST NOT forward a 100 (Continue) response if the request message was received from an HTTP/1.0 (or earlier) client and did not include an Expect request-header field with the ""100-continue"" expectation."
This requirement overrides the general rule for forwarding of 1xx responses (see section 10.1).
"Initialize a variable R to the estimated round-trip time to the server (e.g., based on the time it took to establish the connection), or to a constant value of 5 seconds if the round- trip time is not available."
"If no error response is received, after T seconds transmit the body of the request."
SHOULD close the connection if it has not completed sending the request message.
"Although this set can be expanded, additional methods cannot be assumed to share the same semantics for separately extended clients and servers."
"In particular, the convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an action other than retrieval."
"These methods ought to be considered ""safe""."
"This allows user agents to represent other methods, such as POST, PUT and DELETE, in a special way, so that the user is made aware of the fact that a possibly unsafe action is being requested."
"Naturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a GET request; in fact, some dynamic resources consider that a feature."
"The important distinction here is that the user did not request the side-effects, so therefore cannot be held accountable for them."
"The methods GET, HEAD, PUT and DELETE share this property."
"Also, the methods OPTIONS and TRACE SHOULD NOT have side effects, and so are inherently idempotent."
"(A sequence is idempotent if a single execution of the entire sequence always yields a result that is not changed by a reexecution of all, or part, of that sequence.)"
"For example, a sequence is non-idempotent if its result depends on a value that is later modified in the same sequence."
"A sequence that never has side effects is idempotent, by definition (provided that no concurrent operations are being executed on the same set of resources)."
The OPTIONS method represents a request for information about the communication options available on the request/response chain identified by the Request-URI.
Responses to this method are not cacheable.
"Although this specification does not define any use for such a body, future extensions to HTTP might use the OPTIONS body to make more detailed queries on the server."
A server that does not support such an extension MAY discard the request body.
"If the Request-URI is an asterisk (""*""), the OPTIONS request is intended to apply to the server in general rather than to a specific resource."
"Since a server's communication options typically depend on the resource, the ""*"" request is only useful as a ""ping"" or ""no-op"" type of method; it does nothing beyond allowing the client to test the capabilities of the server."
"For example, this can be used to test a proxy for HTTP/1.1 compliance (or lack thereof)."
"If the Request-URI is not an asterisk, the OPTIONS request applies only to the options that are available when communicating with that resource."
"A 200 response SHOULD include any header fields that indicate optional features implemented by the server and applicable to that resource (e.g., Allow), possibly including extensions not defined by this specification."
"The format for such a body is not defined by this specification, but might be defined by future extensions to HTTP."
"If no response body is included, the response MUST include a Content-Length field with a field-value of ""0""."
When a proxy receives an OPTIONS request on an absolute
"If the Max-Forwards field-value is zero (""0""), the proxy MUST NOT forward the message; instead, the proxy SHOULD respond with its own communication options."
"If the Max-Forwards field-value is an integer greater than zero, the proxy MUST decrement the field-value when it forwards the request."
"If no Max-Forwards field is present in the request, then the forwarded request MUST NOT include a Max-Forwards field."
"If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process."
A conditional GET method requests that the entity be transferred only under the circumstances described by the conditional header field(s).
The conditional GET method is intended to reduce unnecessary network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring data already held by the client.
The partial GET method is intended to reduce unnecessary network usage by allowing partially-retrieved entities to be completed without transferring data already held by the client.
The response to a GET request is cacheable if and only if it meets the requirements for HTTP caching described in section 13.
The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.
The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request.
This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself.
"If the new field values indicate that the cached entity differs from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), then the cache MUST treat the cache entry as stale."
The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI.
The action performed by the POST method might not result in a resource that can be identified by a URI.
"In this case, either 200 (OK) or 204 (No Content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result."
"Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields."
"However, the 303 (See Other) response can be used to direct the user agent to retrieve a cacheable resource."
The PUT method requests that the enclosed entity be stored under the supplied Request-URI.
"If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server."
"If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI."
"If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request."
"If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem."
The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.
"If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale."
Responses to this method are not cacheable.
"In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource."
HTTP/1.1 does not define how a PUT method affects the state of an origin server.
"Unless otherwise specified for a particular entity-header, the entity-headers in the PUT request SHOULD be applied to the resource created or modified by the PUT."
The DELETE method requests that the origin server delete the resource identified by the Request-URI.
"The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully."
"However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location."
"A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, or 204 (No Content) if the action has been enacted but the response does not include an entity."
"If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale."
Responses to this method are not cacheable.
The final recipient of the request SHOULD reflect the message received back to the client as the entity-body of a 200 (OK) response.
A TRACE request MUST NOT include an entity.
"The value of the Via header field (section 14.45) is of particular interest, since it acts as a trace of the request chain."
"Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop."
"If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of ""message/http""."
Responses to this method MUST NOT be cached.
"Each Status-Code is described below, including a description of which method(s) it can follow and any metainformation required in the response."
"This class of status code indicates a provisional response, consisting only of the Status-Line and optional headers, and is terminated by an empty line."
There are no required headers for this class of status code.
"Since HTTP/1.0 did not define any 1xx status codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client except under experimental conditions."
"A client MUST be prepared to accept one or more 1xx status responses prior to a regular response, even if the client does not expect a 100 (Continue) status message."
This interim response is used to inform the client that the initial part of the request has been received and has not yet been rejected by the server.
"The client SHOULD continue by sending the remainder of the request or, if the request has already been completed, ignore this response."
The server MUST send a final response after the request has been completed.
The server will switch protocols to those defined by the response's Upgrade header field immediately after the empty line which terminates the 101 response.
"For example, switching to a newer version of HTTP is advantageous over older versions, and switching to a real-time, synchronous protocol might be advantageous when delivering resources that use such features."
"This class of status code indicates that the client's request was successfully received, understood, and accepted."
The request has been fulfilled and resulted in a new resource being created.
The entity format is specified by the media type given in the Content-Type header field.
"If the action cannot be carried out immediately, the server SHOULD respond with 202 (Accepted) response instead."
"A 201 response MAY contain an ETag response header field indicating the current value of the entity tag for the requested variant just created, see section 14.19."
"The request has been accepted for processing, but the processing has not been completed."
"The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place."
There is no facility for re-sending a status code from an asynchronous operation such as this.
The 202 response is intentionally non-committal.
Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed.
"The returned metainformation in the entity-header is not the definitive set as available from the origin server, but is gathered from a local or a third-party copy."
Use of this response code is not required and is only appropriate when the response would otherwise be 200 (OK).
"The server has fulfilled the request but does not need to return an entity-body, and might want to return updated metainformation."
"If the client is a user agent, it SHOULD NOT change its document view from that which caused the request to be sent."
"The 204 response MUST NOT include a message-body, and thus is always terminated by the first empty line after the header fields."
The server has fulfilled the request and the user agent SHOULD reset the document view which caused the request to be sent.
"This response is primarily intended to allow input for actions to take place via user input, followed by a clearing of the form in which the input is given so that the user can easily initiate another input action."
The response MUST NOT include an entity.
"If the 206 response is the result of an If-Range request that used a strong cache validator (see section 13.3.3), the response SHOULD NOT include other entity-headers."
"If the response is the result of an If-Range request that used a weak validator, the response MUST NOT include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers."
"Otherwise, the response MUST include all of the entity-headers that would have been returned with a 200 (OK) response to the same request."
"A cache MUST NOT combine a 206 response with other previously cached content if the ETag or Last-Modified headers do not match exactly, see 13.5.4."
A cache that does not support the Range and Content-Range headers MUST NOT cache 206 (Partial) responses.
This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.
The action required MAY be carried out by the user agent without interaction with the user if and only if the method used in the second request is GET or HEAD.
"A client SHOULD detect infinite redirection loops, since such loops generate network traffic for each redirection."
Content developers should be aware that there might be clients that implement such a fixed limitation.
The entity format is specified by the media type given in the Content- Type header field.
"Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically."
"However, this specification does not define any standard for such automatic selection."
"If the server has a preferred choice of representation, it SHOULD include the specific URI for that representation in the Location field; user agents MAY use the Location field value for automatic redirection."
This response is cacheable unless indicated otherwise.
This response is cacheable unless indicated otherwise.
The new permanent URI SHOULD be given by the Location field in the response.
"Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s)."
"If the 301 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued."
"Note: When automatically redirecting a POST request after receiving a 301 status code, some existing HTTP/1.0 user agents will erroneously change it into a GET request."
This response is only cacheable if indicated by a Cache-Control or Expires header field.
The temporary URI SHOULD be given by the Location field in the response.
"Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s)."
"If the 302 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued."
Note: RFC 1945 and RFC 2068 specify that the client is not allowed to change the method on the redirected request.
"However, most existing user agent implementations treat 302 as if it were a 303 response, performing a GET on the Location field-value regardless of the original request method."
The status codes 303 and 307 have been added for servers that wish to make unambiguously clear which kind of reaction is expected of the client.
The response to the request can be found under a different URI and SHOULD be retrieved using a GET method on that resource.
The new URI is not a substitute reference for the originally requested resource.
"The 303 response MUST NOT be cached, but the response to the second (redirected) request might be cacheable."
"Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s)."
Note: Many pre-HTTP/1.1 user agents do not understand the 303 status.
"When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303."
"If the client has performed a conditional GET request and access is allowed, but the document has not been modified, the server SHOULD respond with this status code."
"The 304 response MUST NOT contain a message-body, and thus is always terminated by the first empty line after the header fields."
"Date, unless its omission is required by section 14.18.1"
"If the conditional GET used a strong cache validator (see section 13.3.3), the response SHOULD NOT include other entity-headers."
"Otherwise (i.e., the conditional GET used a weak validator), the response MUST NOT include other entity-headers; this prevents inconsistencies between cached entity-bodies and updated headers."
"If a 304 response indicates an entity not currently cached, then the cache MUST disregard the response and repeat the request without the conditional."
"Note: RFC 2068 was not clear that 305 was intended to redirect a single request, and to be generated by origin servers only."
Not observing these limitations has significant security consequences.
"The 306 status code was used in a previous version of the specification, is no longer used, and the code is reserved."
This response is only cacheable if indicated by a Cache-Control or Expires header field.
The temporary URI SHOULD be given by the Location field in the response.
"Unless the request method was HEAD, the entity of the response SHOULD contain a short hypertext note with a hyperlink to the new URI(s) , since many pre-HTTP/1.1 user agents do not understand the 307 status."
"Therefore, the note SHOULD contain the information necessary for a user to repeat the original request on the new URI."
"If the 307 status code is received in response to a request other than GET or HEAD, the user agent MUST NOT automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued."
The 4xx class of status code is intended for cases in which the client seems to have erred.
"Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition."
"If the client is sending data, a server implementation using TCP SHOULD be careful to ensure that the client acknowledges receipt of the packet(s) containing the response, before the server closes the input connection."
"If the client continues sending data to the server after the close, the server's TCP stack will send a reset packet to the client, which may erase the client's unacknowledged input buffers before they can be read and interpreted by the HTTP application."
The request could not be understood by the server due to malformed syntax.
The client SHOULD NOT repeat the request without modifications.
The client MAY repeat the request with a suitable Authorization header field (section 14.8).
"If the request already included Authorization credentials, then the 401 response indicates that authorization has been refused for those credentials."
"If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user SHOULD be presented the entity that was given in the response, since that entity might include relevant diagnostic information."
"HTTP access authentication is explained in ""HTTP Authentication: Basic and Digest Access Authentication"" [43]."
Authorization will not help and the request SHOULD NOT be repeated.
"If the request method was not HEAD and the server wishes to make public why the request has not been fulfilled, it SHOULD describe the reason for the refusal in the entity."
"If the server does not wish to make this information available to the client, the status code 404 (Not Found) can be used instead."
The server has not found anything matching the Request-URI.
"The 410 (Gone) status code SHOULD be used if the server knows, through some internally configurable mechanism, that an old resource is permanently unavailable and has no forwarding address."
"This status code is commonly used when the server does not wish to reveal exactly why the request has been refused, or when no other response is applicable."
The method specified in the Request-Line is not allowed for the resource identified by the Request-URI.
The resource identified by the request is only capable of generating response entities which have content characteristics not acceptable according to the accept headers sent in the request.
The entity format is specified by the media type given in the Content-Type header field.
"Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically."
"However, this specification does not define any standard for such automatic selection."
Note: HTTP/1.1 servers are allowed to return responses which are not acceptable according to the accept headers sent in the request.
"In some cases, this may even be preferable to sending a 406 response."
User agents are encouraged to inspect the headers of an incoming response to determine if it is acceptable.
"If the response could be unacceptable, a user agent SHOULD temporarily stop receipt of more data and query the user for a decision on further actions."
"This code is similar to 401 (Unauthorized), but indicates that the client must first authenticate itself with the proxy."
"HTTP access authentication is explained in ""HTTP Authentication: Basic and Digest Access Authentication"" [43]."
The client did not produce a request within the time that the server was prepared to wait.
The request could not be completed due to a conflict with the current state of the resource.
This code is only allowed in situations where it is expected that the user might be able to resolve the conflict and resubmit the request.
"Ideally, the response entity would include enough information for the user or user agent to fix the problem; however, that might not be possible and is not required."
"For example, if versioning were being used and the entity being PUT included changes to a resource which conflict with those made by an earlier (third-party) request, the server might use the 409 response to indicate that it can't complete the request."
"In this case, the response entity would likely contain a list of the differences between the two versions in a format defined by the response Content-Type."
The requested resource is no longer available at the server and no forwarding address is known.
This condition is expected to be considered permanent.
Clients with link editing capabilities SHOULD delete references to the Request-URI after user approval.
"If the server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) SHOULD be used instead."
This response is cacheable unless indicated otherwise.
The 410 response is primarily intended to assist the task of web maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed.
"Such an event is common for limited-time, promotional services and for resources belonging to individuals no longer working at the server's site."
"It is not necessary to mark all permanently unavailable resources as ""gone"" or to keep the mark for any length of time -- that is left to the discretion of the server owner."
The server refuses to accept the request without a defined Content- Length.
The client MAY repeat the request if it adds a valid Content-Length header field containing the length of the message-body in the request message.
The precondition given in one or more of the request-header fields evaluated to false when it was tested on the server.
The server is refusing to process a request because the request entity is larger than the server is willing or able to process.
"If the condition is temporary, the server SHOULD include a Retry- After header field to indicate that it is temporary and after what time the client MAY try again."
The server is refusing to service the request because the Request-URI is longer than the server is willing to interpret.
"This rare condition is only likely to occur when a client has improperly converted a POST request to a GET request with long query information, when the client has descended into a URI ""black hole"" of redirection (e.g., a redirected URI prefix that points to a suffix of itself), or when the server is under attack by a client attempting to exploit security holes present in some servers using fixed-length buffers for reading or manipulating the Request-URI."
The server is refusing to service the request because the entity of the request is in a format not supported by the requested resource for the requested method.
"When this status code is returned for a byte-range request, the response SHOULD include a Content-Range entity-header field specifying the current length of the selected resource (see section 14.16)."
This response MUST NOT use the multipart/byteranges content- type.
"The expectation given in an Expect request-header field (see section 14.20) could not be met by this server, or, if the server is a proxy, the server has unambiguous evidence that the request could not be met by the next-hop server."
"Response status codes beginning with the digit ""5"" indicate cases in which the server is aware that it has erred or is incapable of performing the request."
"Except when responding to a HEAD request, the server SHOULD include an entity containing an explanation of the error situation, and whether it is a temporary or permanent condition."
The server encountered an unexpected condition which prevented it from fulfilling the request.
The server does not support the functionality required to fulfill the request.
This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.
"The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request."
The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.
The implication is that this is a temporary condition which will be alleviated after some delay.
"If known, the length of the delay MAY be indicated in a Retry-After header."
"If no Retry-After is given, the client SHOULD handle the response as it would for a 500 response."
The existence of the 503 status code does not imply that a server must use it when becoming overloaded.
Some servers may wish to simply refuse the connection.
"The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server specified by the URI (e.g. HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed to access in attempting to complete the request."
Note: Note to implementors: some deployed proxies are known to return 400 or 500 when DNS lookups time out.
"The server does not support, or refuses to support, the HTTP protocol version that was used in the request message."
"The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in section 3.1, other than with this error message."
The response SHOULD contain an entity describing why that version is not supported and what other protocols are supported by that server.
HTTP provides several OPTIONAL challenge-response authentication mechanisms which can be used by a server to challenge a client request and by a client to provide authentication information.
"The general framework for access authentication, and the specification of ""basic"" and ""digest"" authentication, are specified in ""HTTP Authentication: Basic and Digest Access Authentication"" [43]."
"This specification adopts the definitions of ""challenge"" and ""credentials"" from that specification."
"Naturally, it is desirable to supply the user with the ""best available"" entity corresponding to the request."
"Unfortunately for servers and caches, not all users have the same preferences for what is ""best,"" and not all user agents are equally capable of rendering all entity types."
"For that reason, HTTP has provisions for several mechanisms for ""content negotiation"" -- the process of selecting the best representation for a given response when there are multiple representations available."
"Any response containing an entity-body MAY be subject to negotiation, including error responses."
There are two kinds of content negotiation which are possible in HTTP: server-driven and agent-driven negotiation.
"One method of combination, referred to as transparent negotiation, occurs when a cache uses the agent-driven negotiation information provided by the origin server in order to provide server-driven negotiation for subsequent requests."
"If the selection of the best representation for a response is made by an algorithm located at the server, it is called server-driven negotiation."
"Server-driven negotiation is advantageous when the algorithm for selecting from among the available representations is difficult to describe to the user agent, or when the server desires to send its ""best guess"" to the client along with the first response (hoping to avoid the round-trip delay of a subsequent request if the ""best guess"" is good enough for the user)."
"In order to improve the server's guess, the user agent MAY include request header fields (Accept, Accept-Language, Accept-Encoding, etc.) which describe its preferences for such a response."
"It is impossible for the server to accurately determine what might be ""best"" for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?)."
Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential violation of the user's privacy.
4. It may limit a public cache's ability to use the same response for multiple user's requests.
"However, an origin server is not limited to these dimensions and MAY vary the response based on any aspect of the request, including information outside the request-header fields or within extension header fields not defined by this specification."
The Vary  header field can be used to express the parameters the server uses to select a representation that is subject to server- driven negotiation.
See section 13.6 for use of the Vary header field by caches and section 14.44 for use of the Vary header field by servers.
"With agent-driven negotiation, selection of the best representation for a response is performed by the user agent after receiving an initial response from the origin server."
"Agent-driven negotiation is advantageous when the response would vary over commonly-used dimensions (such as type, language, or encoding), when the origin server is unable to determine a user agent's capabilities from examining the request, and generally when public caches are used to distribute server load and reduce network usage."
Agent-driven negotiation suffers from the disadvantage of needing a second request to obtain the best alternate representation.
This second request is only efficient when caching is used.
"In addition, this specification does not define any mechanism for supporting automatic selection, though it also does not prevent any such mechanism from being developed as an extension and used within HTTP/1.1. HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable) status codes for enabling agent-driven negotiation when the server is unwilling or unable to provide a varying response using server-driven negotiation."
Transparent negotiation is a combination of both server-driven and agent-driven negotiation.
Transparent negotiation has the advantage of distributing the negotiation work that would otherwise be required of the origin server and also removing the second request delay of agent-driven negotiation when the cache is able to correctly guess the right response.
"This specification does not define any mechanism for transparent negotiation, though it also does not prevent any such mechanism from being developed as an extension that could be used within HTTP/1.1.
HTTP is typically used for distributed information systems, where performance can be improved by the use of response caches."
Caching would be useless if it did not significantly improve performance.
"The former reduces the number of network round-trips required for many operations; we use an ""expiration"" mechanism for this purpose (see section 13.2)."
"The latter reduces network bandwidth requirements; we use a ""validation"" mechanism for this purpose (see section 13.3)."
Protocol features that allow an origin server or user agent to explicitly request and control non-transparent operation.
Protocol features that allow a cache to attach warnings to responses that do not preserve the requested approximation of semantic transparency.
A basic principle is that it must be possible for the clients to detect any potential relaxation of semantic transparency.
"The server, cache, or client implementor might be faced with design decisions not explicitly discussed in this specification."
"If a decision might affect semantic transparency, the implementor ought to err on the side of maintaining transparency unless a careful and complete analysis shows significant benefits in breaking transparency."
It has been checked for equivalence with what the origin server would have returned by revalidating the response with the origin server (section 13.3);
"2. It is ""fresh enough"" (see section 13.2)."
"In the default case, this means it meets the least restrictive freshness requirement of the client, origin server, and cache (see section 14.9); if the origin server so specifies, it is the freshness requirement of the origin server alone."
"If a stored response is not ""fresh enough"" by the most restrictive freshness requirement of both the client and the origin server, in carefully considered circumstances the cache MAY still return the response with the appropriate Warning header (see section 13.1.5 and 14.46), unless such a response is prohibited (e.g., by a ""no-store"" cache-directive, or by a ""no-cache"" cache-request-directive; see section 14.9)."
"It is an appropriate 304 (Not Modified), 305 (Proxy Redirect), or error (4xx or 5xx) response message."
"If the cache can not communicate with the origin server, then a correct cache SHOULD respond as above if the response can be correctly served from the cache; if not it MUST return an error or warning indicating that there was a communication failure."
"If a cache receives a response (either an entire response, or a 304 (Not Modified) response) that it would normally forward to the requesting client, and the received response is no longer fresh, the cache SHOULD forward it to the requesting client without adding a new Warning (but without removing any existing Warning headers)."
A cache SHOULD NOT attempt to revalidate a response simply because that response became stale in transit; this might lead to an infinite loop.
A user agent that receives a stale response without a Warning MAY display a warning indication to the user.
"Whenever a cache returns a response that is neither first-hand nor ""fresh enough"" (in the sense of condition 2 in section 13.1.1), it MUST attach a warning to that effect, using a Warning general-header."
"The use of a warning, rather than an error status code, distinguish these responses from true failures."
Warnings are assigned three digit warn-codes.
"The first digit indicates whether the Warning MUST or MUST NOT be deleted from a stored cache entry after a successful revalidation: 1xx  Warnings that describe the freshness or revalidation status of the response, and so MUST be deleted after a successful revalidation."
1XX warn-codes MAY be generated by a cache only when validating a cached entry.
It MUST NOT be generated by clients.
"xx  Warnings that describe some aspect of the entity body or entity headers that is not rectified by a revalidation (for example, a lossy compression of the entity bodies) and which MUST NOT be deleted after a successful revalidation."
"HTTP/1.0 caches will cache all Warnings in responses, without deleting the ones in the first category."
"Warnings in responses that are passed to HTTP/1.0 caches carry an extra warning-date field, which prevents a future HTTP/1.1 recipient from believing an erroneously cached Warning."
"Multiple warnings MAY be attached to a response (either by the origin server or by a cache), including multiple warnings with the same code number."
"When multiple warnings are attached to a response, it might not be practical or reasonable to display all of them to the user."
"This version of HTTP does not specify strict priority rules for deciding which warnings to display and in what order, but does suggest some heuristics."
The basic cache mechanisms in HTTP/1.1 (server-specified expiration times and validators) are implicit directives to caches.
We use the Cache-Control header for this purpose.
The Cache-Control header allows a client or server to transmit a variety of directives in either requests or responses.
These directives typically override the default caching algorithms.
"However, in some cases, cache-control directives are explicitly specified as weakening the approximation of semantic transparency (for example, ""max-stale"" or ""public"")."
Many user agents make it possible for users to override the basic caching mechanisms.
"For example, the user agent might allow the user to specify that cached entities (even explicitly stale ones) are never validated."
"Or the user agent might habitually add ""Cache- Control: max-stale=3600"" to every request."
"The user agent SHOULD NOT default to either non-transparent behavior, or behavior that results in abnormally ineffective caching, but MAY be explicitly configured to do so by an explicit action of the user."
"If the user has overridden the basic caching mechanisms, the user agent SHOULD explicitly indicate to the user whenever this results in the display of information that might not meet the server's transparency requirements (in particular, if the displayed entity is known to be stale)."
"Since the protocol normally allows the user agent to determine if responses are stale or not, this indication need only be displayed when this actually happens."
"The indication need not be a dialog box; it could be an icon (for example, a picture of a rotting fish) or some other indicator."
"If the user has overridden the caching mechanisms in a way that would abnormally reduce the effectiveness of caches, the user agent SHOULD continually indicate this state to the user (for example, by a display of a picture of currency in flames) so that the user does not inadvertently consume excess resources or suffer from excessive latency."
"In some cases, the operator of a cache MAY choose to configure it to return stale responses even when not requested by clients."
"This decision ought not be made lightly, but may be necessary for reasons of availability or performance, especially when the cache is poorly connected to the origin server."
"Whenever a cache returns a stale response, it MUST mark it as such (using a Warning header) enabling the client software to alert the user that there might be a potential problem."
It also allows the user agent to take steps to obtain a first-hand or fresh response.
"For this reason, a cache SHOULD NOT return a stale response if the client explicitly requests a first-hand or fresh one, unless it is impossible to comply for technical or policy reasons."
A client's request MAY specify the maximum age it is willing to accept of an unvalidated response; specifying a value of zero forces the cache(s) to revalidate all responses.
A client MAY also specify the minimum time remaining before a response expires.
"Both of these options increase constraints on the behavior of caches, and so cannot further relax the cache's approximation of semantic transparency."
"A client MAY also specify that it will accept stale responses, up to some maximum amount of staleness."
"This loosens the constraints on the caches, and so might violate the origin server's specified constraints on semantic transparency, but might be necessary to support disconnected operation, or high availability in the face of poor connectivity."
HTTP caching works best when caches can entirely avoid making requests to the origin server.
"The primary mechanism for avoiding requests is for an origin server to provide an explicit expiration time in the future, indicating that a response MAY be used to satisfy subsequent requests."
"In other words, a cache can return a fresh response without first contacting the server."
"Our expectation is that servers will assign future explicit expiration times to responses in the belief that the entity is not likely to change, in a semantically significant way, before the expiration time is reached."
"This normally preserves semantic transparency, as long as the server's expiration times are carefully chosen."
The expiration mechanism applies only to responses taken from a cache and not to first-hand responses forwarded immediately to the requesting client.
"If an origin server wishes to force a semantically transparent cache to validate every request, it MAY assign an explicit expiration time in the past."
"This means that the response is always stale, and so the cache SHOULD validate it before using it for subsequent requests."
"If an origin server wishes to force any HTTP/1.1 cache, no matter how it is configured, to validate every request, it SHOULD use the ""must- revalidate"" cache-control directive (see section 14.9)."
"Servers specify explicit expiration times using either the Expires header, or the max-age directive of the Cache-Control header."
"An expiration time cannot be used to force a user agent to refresh its display or reload a resource; its semantics apply only to caching mechanisms, and such mechanisms need only check a resource's expiration status when a new request for that resource is initiated."
"Since origin servers do not always provide explicit expiration times, HTTP caches typically assign heuristic expiration times, employing algorithms that use other header values (such as the Last-Modified time) to estimate a plausible expiration time."
"The HTTP/1.1 specification does not provide specific algorithms, but does impose worst-case constraints on their results."
"Since heuristic expiration times might compromise semantic transparency, they ought to used cautiously, and we encourage origin servers to provide explicit expiration times as much as possible."
"In order to know if a cached entry is fresh, a cache needs to know if its age exceeds its freshness lifetime."
"In this discussion, we use the term ""now"" to mean ""the current value of the clock at the host performing the calculation."""
"We use the term ""date_value"" to denote the value of the Date header, in a form appropriate for arithmetic operations."
The Age field value is the cache's estimate of the amount of time since the response was generated or revalidated by the origin server.
"We use the term ""age_value"" to denote the value of the Age header, in a form appropriate for arithmetic operations."
"now minus date_value, if the local clock is reasonably well synchronized to the origin server's clock."
"If the result is negative, the result is replaced by zero."
"Because of network-imposed delays, some significant interval might pass between the time that a server generates a response and the time it is received at the next outbound cache or client."
"If uncorrected, this delay could result in improperly low ages."
"where ""request_time"" is the time (according to the local clock) when the request that elicited this response was sent."
The current_age of a cache entry is calculated by adding the amount of time (in seconds) since the cache entry was last validated by the origin server to the corrected_initial_age.
"When a response is generated from a cache entry, the cache MUST include a single"
The presence of an Age header field in a response implies that a response is not first-hand.
"However, the converse is not true, since the lack of an Age header field in a response does not imply that the response is first-hand unless all caches along the request path are compliant with HTTP/1.1 (i.e., older HTTP caches did not implement the Age header field)."
"In order to decide whether a response is fresh or stale, we need to compare its freshness lifetime to its age."
"We use the term ""expires_value"" to denote the value of the Expires header."
"Note that neither of these calculations is vulnerable to clock skew, since all of the information comes from the origin server."
"If none of Expires, Cache-Control: max-age, or Cache-Control: s- maxage (see section 14.9.3) appears in the response, and the response does not include other restrictions on caching, the cache MAY compute a freshness lifetime using a heuristic."
The cache MUST attach Warning 113 to any response whose age is more than 24 hours if such warning has not already been added.
"Also, if the response does have a Last-Modified time, the heuristic expiration value SHOULD be no more than some fraction of the interval since that time."
"If a client performing a retrieval receives a non-first-hand response for a request that was already fresh in its own cache, and the Date header in its existing cache entry is newer than the Date on the new response, then the client MAY ignore the response."
"If a cache has two fresh responses for the same representation with different validators, it MUST use the one with the more recent Date header."
"This situation might arise because the cache is pooling responses from other caches, or because a client has asked for a reload or a revalidation of an apparently fresh cache entry."
"We would like the client to use the most recently generated response, even if older responses are still apparently fresh."
"Neither the entity tag nor the expiration value can impose an ordering on responses, since it is possible that a later response intentionally carries an earlier expiration time."
"Servers MUST NOT depend on clients being able to choose deterministically between responses generated during the same second, if their expiration times overlap."
"When a cache has a stale entry that it would like to use as a response to a client's request, it first has to check with the origin server (or possibly an intermediate cache with a fresh response) to see if its cached entry is still usable."
"We call this ""validating"" the cache entry."
"Since we do not want to have to pay the overhead of retransmitting the full response if the cached entry is good, and we do not want to pay the overhead of an extra round trip if the cached entry is invalid, the HTTP/1.1 protocol supports the use of conditional methods."
"The key protocol features for supporting conditional methods are those concerned with ""cache validators."""
"When an origin server generates a full response, it attaches some sort of validator to it, which is kept with the cache entry."
"The server then checks that validator against the current validator for the entity, and, if they match (see section 13.3.3), it responds with a special status code (usually, 304 (Not Modified)) and no entity-body."
"Thus, we avoid transmitting the full response if the validator matches, and we avoid an extra round trip if it does not match."
The protocol includes both positive and negative senses of cache- validating conditions.
"That is, it is possible to request either that a method be performed if and only if a validator matches or if and only if no validators match."
"Note: a response that lacks a validator may still be cached, and served from cache until it expires, unless this is explicitly prohibited by a cache-control directive."
"However, a cache cannot do a conditional retrieval if it does not have a validator for the entity, which means it will not be refreshable after it expires."
The Last-Modified entity-header field value is often used as a cache validator.
"In simple terms, a cache entry is considered to be valid if the entity has not been modified since the Last-Modified value."
"The ETag response-header field value, an entity tag, provides for an ""opaque"" cache validator."
"This might allow more reliable validation in situations where it is inconvenient to store modification dates, where the one-second resolution of HTTP date values is not sufficient, or where the origin server wishes to avoid certain paradoxes that might arise from the use of modification dates."
"Entity tags are normally ""strong validators,"" but the protocol provides a mechanism to tag an entity tag as ""weak."""
"One can think of a strong validator as one that changes whenever the bits of an entity changes, while a weak value changes whenever the meaning of an entity changes."
"Alternatively, one can think of a strong validator as part of an identifier for a specific entity, while a weak validator is part of an identifier for a set of semantically equivalent entities."
One example of a strong validator is an integer that is incremented in stable storage every time an entity is changed.
"An entity's modification time, if represented with one-second resolution, could be a weak validator, since it is possible that the resource might be modified twice during a single second."
Support for weak validators is optional.
"However, weak validators allow for more efficient caching of equivalent objects; for example, a hit counter on a site is probably good enough if it is updated every few days or weeks, and any value during that period is likely ""good enough"" to be equivalent."
"A ""use"" of a validator is either when a client generates a request and includes the validator in a validating header field, or when a server compares two validators."
Strong validators are usable in any context.
Weak validators are only usable in contexts that do not depend on exact equality of an entity.
"For example, either kind is usable for a conditional GET of a full entity."
"However, only a strong validator is usable for a sub-range retrieval, since otherwise the client might end up with an internally inconsistent entity."
Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators.
Clients MUST NOT use weak validators in other forms of request.
"The strong comparison function: in order to be considered equal, both validators MUST be identical in every way, and both MUST NOT be weak."
"The weak comparison function: in order to be considered equal, both validators MUST be identical in every way, but either or both of them MAY be tagged as ""weak"" without affecting the result."
An entity tag is strong unless it is explicitly tagged as weak.
"The validator is being compared by an origin server to the actual current validator for the entity and, - That origin server reliably knows that the associated entity did not change twice during the second covered by the presented validator."
The presented Last-Modified time is at least 60 seconds before the Date value.
The presented Last-Modified time is at least 60 seconds before the Date value.
"An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short."
"If a client wishes to perform a sub-range retrieval on a value for which it has only a Last-Modified time and no opaque validator, it MAY do this only if the Last-Modified time is strong in the sense described here."
These rules allow HTTP/1.1 caches and clients to safely perform sub- range retrievals on values that have been obtained from HTTP/1.0 servers.
SHOULD send an entity tag validator unless it is not feasible to generate one.
"MAY send a weak entity tag instead of a strong entity tag, if performance considerations support the use of weak entity tags, or if it is unfeasible to send a strong entity tag."
"SHOULD send a Last-Modified value if it is feasible to send one, unless the risk of a breakdown in semantic transparency that could result from using this date in an If-Modified-Since header would lead to serious problems."
"In other words, the preferred behavior for an HTTP/1.1 origin server is to send both a strong entity tag and a Last-Modified value."
A weak entity tag SHOULD change whenever the associated entity changes in a semantically significant way.
"Note: in order to provide semantically transparent caching, an origin server must avoid reusing a specific strong entity tag value for two different entities, or reusing a specific weak entity tag value for two semantically different entities."
"Cache entries might persist for arbitrarily long periods, regardless of expiration times, so it might be inappropriate to expect that a cache will never again attempt to validate an entry using a validator that it obtained at some point in the past."
"If only a Last-Modified value has been provided by the origin server, SHOULD use that value in non-subrange cache-conditional requests (using If-Modified-Since)."
"- If only a Last-Modified value has been provided by an HTTP/1.0 origin server, MAY use that value in subrange cache-conditional requests (using If-Unmodified-Since:)."
"The user agent SHOULD provide a way to disable this, in case of difficulty."
"If both an entity tag and a Last-Modified value have been provided by the origin server, SHOULD use both validators in cache-conditional requests."
"An HTTP/1.1 origin server, upon receiving a conditional request that includes both a Last-Modified date (e.g., in an If-Modified-Since or If-Unmodified-Since header field) and one or more entity tags (e.g., in an If-Match, If-None-Match, or If-Range header field) as cache validators, MUST NOT return a response status of 304 (Not Modified) unless doing so is consistent with all of the conditional header fields in the request."
"An HTTP/1.1 caching proxy, upon receiving a conditional request that includes both a Last-Modified date and one or more entity tags as cache validators, MUST NOT return a locally cached response to the client unless that cached response is consistent with all of the conditional header fields in the request."
The general principle behind these rules is that HTTP/1.1 servers and clients should transmit as much non-redundant information as is available in their responses and requests.
HTTP/1.1 systems receiving this information will make the most conservative assumptions about the validators they receive.
HTTP/1.0 clients and caches will ignore entity tags.
"Generally, last-modified values received or used by these systems will support transparent and efficient caching, and so HTTP/1.1 origin servers should provide Last-Modified values."
"In those rare cases where the use of a Last-Modified value as a validator by an HTTP/1.0 system could result in a serious problem, then HTTP/1.1 origin servers should not provide one."
"Thus, comparisons of any other headers (except Last-Modified, for compatibility with HTTP/1.0) are never used for purposes of validating a cache entry."
"Unless specifically constrained by a cache-control (section 14.9) directive, a caching system MAY always store a successful response (see section 13.8) as a cache entry, MAY return it without validation if it is fresh, and MAY return it after successful validation."
"If there is neither a cache validator nor an explicit expiration time associated with a response, we do not expect it to be cached, but certain caches MAY violate this expectation (for example, when little or no network connectivity is available)."
A client can usually detect that such a response was taken from a cache by comparing the Date header to the current time.
Note: some HTTP/1.0 caches are known to violate this expectation without providing any Warning.
"However, in some cases it might be inappropriate for a cache to retain an entity, or to return it in response to a subsequent request."
"This might be because absolute semantic transparency is deemed necessary by the service author, or because of security or privacy considerations."
"Certain cache-control directives are therefore provided so that the server can indicate that certain resource entities, or portions thereof, are not to be cached regardless of other considerations."
Note that section 14.8 normally prevents a shared cache from saving and returning a response to a previous request if that request included an Authorization header.
"However, a cache that does not support the Range and Content-Range headers MUST NOT cache 206 (Partial Content) responses."
A response received with any other status code (e.g. status codes 302 and 307) MUST NOT be returned in a reply to a subsequent request unless there are cache-control directives or another header(s) that explicitly allow it.
The purpose of an HTTP cache is to store information received in response to requests for use in responding to future requests.
"End-to-end headers, which are  transmitted to the ultimate recipient of a request or response."
End-to-end headers in responses MUST be stored as part of a cache entry and MUST be transmitted in any response formed from a cache entry.
"Hop-by-hop headers, which are meaningful only for a single transport-level connection, and are not stored by caches or forwarded by proxies."
"A non-transparent proxy MAY modify or add these fields to a message that does not include no-transform, but if it does so, it MUST add a Warning 214 (Transformation applied) if one does not already appear in the message (see section 14.46)."
Warning: unnecessary modification of end-to-end headers might cause authentication failures if stronger authentication mechanisms are introduced in later versions of HTTP.
Such authentication mechanisms MAY rely on the values of header fields not listed here.
The Content-Length field of a request or response is added or deleted according to the rules in section 4.4.
"When a cache makes a validating request to a server, and the server provides a 304 (Not Modified) response or a 206 (Partial Content) response, the cache then constructs a response to send to the requesting client."
"If the status code is 304 (Not Modified), the cache uses the entity- body stored in the cache entry as the entity-body of this outgoing response."
any stored Warning headers with warn-code 1xx (see section 14.46) MUST be deleted from the cache entry and the forwarded response.
any stored Warning headers with warn-code 2xx MUST be retained in the cache entry and the forwarded response.
any end-to-end headers provided in the 304 or 206 response MUST replace the corresponding headers from the cache entry.
"Unless the cache decides to remove the cache entry, it MUST also replace the end-to-end headers stored with the cache entry with corresponding headers received in the incoming response, except for Warning headers as described immediately above."
"If a header field- name in the incoming response matches more than one header in the cache entry, all such old headers MUST be replaced."
"In other words, the set of end-to-end headers received in the incoming response overrides all corresponding end-to-end headers stored with the cache entry (except for stored Warning headers with warn-code 1xx, which are deleted even if not overridden)."
"Note: this rule allows an origin server to use a 304 (Not Modified) or a 206 (Partial Content) response to update any header associated with a previous response for the same entity or sub- ranges thereof, although it might not always be meaningful or correct to do so."
This rule does not allow an origin server to use a 304 (Not Modified) or a 206 (Partial Content) response to entirely delete a header that it had provided with a previous response.
"A response might transfer only a subrange of the bytes of an entity- body, either because the request included one or more Range specifications, or because a connection was broken prematurely."
"If either requirement is not met, the cache MUST use only the most recent partial response (based on the Date values transmitted with every response, and using the incoming response if these values are equal or missing), and MUST discard the other partial information."
"Use of server-driven content negotiation (section 12.1), as indicated by the presence of a Vary header field in a response, alters the conditions and procedure by which a cache can use the response for subsequent requests."
A server SHOULD use the Vary header field to inform a cache of what request-header fields were used to select among multiple representations of a cacheable response subject to server-driven negotiation.
"The set of header fields named by the Vary field value is known as the ""selecting"" request-headers."
"When the cache receives a subsequent request whose Request-URI specifies one or more cache entries including a Vary header field, the cache MUST NOT use such a cache entry to construct a response to the new request unless all of the selecting request-headers present in the new request match the corresponding stored request-headers in the original request."
"The selecting request-headers from two requests are defined to match if and only if the selecting request-headers in the first request can be transformed to the selecting request-headers in the second request by adding or removing linear white space (LWS) at places where this is allowed by the corresponding BNF, and/or combining multiple message-header fields with the same field name following the rules about message headers in section 4.2.
A Vary header field-value of ""*"" always fails to match and subsequent requests on that resource can only be properly interpreted by the origin server."
"If the selecting request header fields for the cached entry do not match the selecting request header fields of the new request, then the cache MUST NOT use a cached entry to satisfy the request unless it first relays the new request to the origin server in a conditional request and the server responds with 304 (Not Modified), including an entity tag or Content-Location that indicates the entity to be used."
"If an entity tag was assigned to a cached representation, the forwarded request SHOULD be conditional and include the entity tags in an If-None-Match header field from all its cache entries for the resource."
"This conveys to the server the set of entities currently held by the cache, so that if any one of these entities matches the requested entity, the server can use the ETag header field in its 304 (Not Modified) response to tell the cache which entry is appropriate."
"If any of the existing cache entries contains only partial content for the associated entity, its entity-tag SHOULD NOT be included in the If-None-Match header field unless the request is for a range that would be fully satisfied by that entry."
"If a cache receives a successful response whose Content-Location field matches that of an existing cache entry for the same Request- ]URI, whose entity-tag differs from that of the existing entry, and whose Date is more recent than that of the existing entry, the existing entry SHOULD NOT be returned in response to future requests and SHOULD be deleted from the cache."
A non-shared cache is one that is accessible only to a single user.
Other sections of this specification place certain constraints on the operation of shared caches in order to prevent loss of privacy or failure of access controls.
"A cache that receives an incomplete response (for example, with fewer bytes of data than specified in a Content-Length header) MAY store the response."
"A cache MUST NOT return a partial response to a client without explicitly marking it as such, using the 206 (Partial Content) status code."
A cache MUST NOT return a partial response using a status code of 200 (OK).
"If a cache receives a 5xx response while attempting to revalidate an entry, it MAY either forward this response to the requesting client, or act as if the server failed to respond."
"In the latter case, it MAY return a previously received response unless the cached entry includes the ""must-revalidate"" cache-control directive (see section 14.9)."
"Unless the origin server explicitly prohibits the caching of their responses, the application of GET and HEAD methods to any resources SHOULD NOT have side effects that would lead to erroneous behavior if these responses are taken from a cache."
"They MAY still have side effects, but a cache is not required to consider such side effects in its caching decisions."
Caches are always expected to observe an origin server's explicit restrictions on caching.
"We note one exception to this rule: since some applications have traditionally used GETs and HEADs with query URLs (those containing a ""?"" in the rel_path part) to perform operations with significant side effects, caches MUST NOT treat responses to such URIs as fresh unless the server provides an explicit expiration time."
This specifically means that responses from HTTP/1.0 servers for such URIs SHOULD NOT be taken from a cache.
"That is, although they might continue to be ""fresh,"" they do not accurately reflect what the origin server would return for a new request on that resource."
There is no way for the HTTP protocol to guarantee that all such cache entries are marked invalid.
"For example, the request that caused the change at the origin server might not have gone through the proxy where a cache entry is stored."
"In this section, the phrase ""invalidate an entity"" means that the cache will either remove all instances of that entity from its storage, or will mark these as ""invalid"" and in need of a mandatory revalidation before they can be returned in response to a subsequent request."
"In order to prevent denial of service attacks, an invalidation based on the URI in a Location or Content-Location header MUST only be performed if the host part is the same as in the Request-URI."
A cache that passes through requests for methods it does not understand SHOULD invalidate any entities referred to by the Request-URI.
All methods that might be expected to cause modifications to the origin server's resources MUST be written through to the origin server.
"A cache MUST NOT reply to such a request from a client before having transmitted the request to the inbound server, and having received a corresponding response from the inbound server."
This does not prevent a proxy cache from sending a 100 (Continue) response before the inbound server has sent its final reply.
"The alternative (known as ""write-back"" or ""copy-back"" caching) is not allowed in HTTP/1.1, due to the difficulty of providing consistent updates and the problems arising from server, cache, or network failure prior to write-back."
"If a new cacheable (see sections 14.9.2, 13.2.5, 13.2.6 and 13.8) response is received from a resource while any existing responses for the same resource are cached, the cache SHOULD use the new response to reply to the current request."
"It MAY insert it into cache storage and MAY, if it meets all other requirements, use it to respond to any future requests that would previously have caused the old response to be returned."
Note: a new response that has an older Date header value than existing cached responses is not cacheable.
In particular history mechanisms SHOULD NOT try to show a semantically transparent view of the current state of a resource.
"Rather, a history mechanism is meant to show exactly what the user saw at the time when the resource was retrieved."
"By default, an expiration time does not apply to history mechanisms."
"If the entity is still in storage, a history mechanism SHOULD display it even if the entity has expired, unless the user has specifically configured the agent to refresh expired history documents."
This is not to be construed to prohibit the history mechanism from telling the user that a view might be stale.
"Note: if history list mechanisms unnecessarily prevent users from viewing stale resources, this will tend to force service authors to avoid using HTTP expiration controls and cache controls when they would otherwise like to."
Service authors may consider it important that users not be presented with error messages or warning messages when they use navigation controls (such as BACK) to view previously fetched resources.
"Even though sometimes such resources ought not to cached, or ought to expire quickly, user interface considerations may force service authors to resort to other means of preventing caching (e.g. ""once-only"" URLs) in order not to suffer the effects of improperly functioning history mechanisms."
This section defines the syntax and semantics of all standard HTTP/1.1 header fields.
The Accept request-header field can be used to specify certain media types which are acceptable for the response.
"Each media-range MAY be followed by one or more accept-params, beginning with the ""q"" parameter for indicating a relative quality factor."
"The first ""q"" parameter (if any) separates the media-range parameter(s) from the accept-params."
"If no Accept header field is present, then it is assumed that the client accepts all media types."
"If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response."
Note: A user agent might be provided with a default set of quality values for certain media ranges.
"However, unless the user agent is a closed system which cannot interact with other rendering agents, this default set ought to be configurable by the user."
The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response.
This field allows clients capable of understanding more comprehensive or special- purpose character sets to signal that capability to a server which is capable of representing documents in those character sets.
"The special value ""*"", if present in the Accept-Charset field, matches every character set (including ISO-8859-1) which is not mentioned elsewhere in the Accept-Charset field."
"If no ""*"" is present in an Accept-Charset field, then all character sets not explicitly mentioned get a quality value of 0, except for ISO-8859-1, which gets a quality value of 1 if not explicitly mentioned."
"If no Accept-Charset header is present, the default is that any character set is acceptable."
"If an Accept-Charset header is present, and if the server cannot send a response which is acceptable according to the Accept-Charset header, then the server SHOULD send an error response with the 406 (not acceptable) status code, though the sending of an unacceptable response is also allowed."
"The Accept-Encoding request-header field is similar to Accept, but restricts the content-codings (section 3.5) that are acceptable in the response."
"The special ""*"" symbol in an Accept-Encoding field matches any available content-coding not explicitly listed in the header field."
"If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred."
"The ""identity"" content-coding is always acceptable, unless specifically refused because the Accept-Encoding field includes ""identity;q=0"", or because the field includes ""*;q=0"" and does not explicitly include the ""identity"" content-coding."
"If the Accept-Encoding field-value is empty, then only the ""identity"" encoding is acceptable."
"If an Accept-Encoding field is present in a request, and if the server cannot send a response which is acceptable according to the Accept-Encoding header, then the server SHOULD send an error response with the 406 (Not Acceptable) status code."
"If no Accept-Encoding field is present in a request, the server MAY assume that the client will accept any content coding."
"In this case, if ""identity"" is one of the available content-codings, then the server SHOULD use the ""identity"" content-coding, unless it has additional information that a different content-coding is meaningful to the client."
"If the request does not include an Accept-Encoding field, and if the ""identity"" content-coding is unavailable, then content-codings commonly understood by HTTP/1.0 clients (i.e., ""gzip"" and ""compress"") are preferred; some older clients improperly display messages sent with other content-codings."
Note: Most HTTP/1.0 applications do not recognize or obey qvalues associated with content-codings.
This means that qvalues will not work and are not permitted with x-gzip or x-compress.
"The special range ""*"", if present in the Accept-Language field, matches every tag not matched by any other range present in the Accept-Language field."
"This use of a prefix matching rule does not imply that language tags are assigned to languages in such a way that it is always true that if a user understands a language with a certain tag, then this user will also understand all languages with tags for which this tag is a prefix."
The language quality factor assigned to a language-tag by the Accept-Language field is the quality value of the longest language- range in the field that matches the language-tag.
"If no language- range in the field matches the tag, the language quality factor assigned is 0."
"If no Accept-Language header is present in the request, the server SHOULD assume that all languages are equally acceptable."
"If an Accept-Language header is present, then all languages which are assigned a quality factor greater than 0 are acceptable."
It might be contrary to the privacy expectations of the user to send an Accept-Language header with the complete linguistic preferences of the user in every request.
"As intelligibility is highly dependent on the individual user, it is recommended that client applications make the choice of linguistic preference available to the user."
"If the choice is not made available, then the Accept-Language header field MUST NOT be given in the request."
"When making the choice of linguistic preference available to the user, we remind implementors of  the fact that users are not familiar with the details of language matching as described above, and should provide appropriate guidance."
"As an example, users might assume that on selecting ""en-gb"", they will be served any kind of English document if British English is not available."
"A user agent might suggest in such a case to add ""en"" to get the best matching behavior."
but are not required to do so.
Clients MAY generate byte-range requests without having received this header for the resource involved.
"Range units are defined in section 3.12.
to advise the client not to attempt a range request."
"A cached response is ""fresh"" if its age does not exceed its freshness lifetime."
"Age values are non-negative decimal integers, representing time in seconds."
An HTTP/1.1 server that includes a cache MUST include an Age header field in every response generated from its own cache.
An Allow header field MUST be present in a 405 (Method Not Allowed) response.
"However, the indications given by the Allow header field value SHOULD be followed."
The actual set of allowed methods is defined by the origin server at the time of each request.
The server is not required to support these methods and SHOULD include an Allow header in the response giving the actual supported methods.
"A proxy MUST NOT modify the Allow header field even if it does not understand all the methods specified, since the user agent might have other means of communicating with the origin server."
"A user agent that wishes to authenticate itself with a server-- usually, but not necessarily, after receiving a 401 response--does so by including an Authorization request-header field with the request."
The Authorization field value consists of credentials containing the authentication information of the user agent for the realm of the resource being requested.
"HTTP access authentication is described in ""HTTP Authentication: Basic and Digest Access Authentication"" [43]."
"If a request is authenticated and a realm specified, the same credentials SHOULD be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise, such as credentials that vary according to a challenge value or using synchronized clocks)."
"If the response includes the ""s-maxage"" cache-control directive, the cache MAY use that response in replying to a subsequent request."
"If the response includes ""s- maxage=0"", the proxy MUST always revalidate it before re-using it."
"If the response includes the ""must-revalidate"" cache-control directive, the cache MAY use that response in replying to a subsequent request."
"But if the response is stale, all caches MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request."
"If the response includes the ""public"" cache-control directive, it MAY be returned in reply to any subsequent request."
The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain.
The directives specify behavior intended to prevent caches from adversely interfering with the request or response.
These directives typically override the default caching algorithms.
Cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is to be given in the response.
Note that HTTP/1.0 caches might not implement Cache-Control and might only implement Pragma: no-cache (see section 14.32).
It is not possible to specify a cache- directive for a specific cache.
Restrictions on what are cacheable; these may only be imposed by the origin server.
Restrictions on what may be stored by a cache; these may be imposed by either the origin server or the user agent.
Modifications of the basic expiration mechanism; these may be imposed by either the origin server or the user agent.
Controls over cache revalidation and reload; these may only be imposed by a user agent.
private Indicates that all or part of the response message is intended for a single user and MUST NOT be cached by a shared cache.
This allows an origin server to state that the specified parts of the response are intended for only one user and are not a valid response for requests by other users.
"This usage of the word private only controls where the response may be cached, and cannot ensure the privacy of the message content."
no-cache
"If the no-cache directive does not specify a field-name, then a cache MUST NOT use the response to satisfy a subsequent request without successful revalidation with the origin server."
This allows an origin server to prevent caching even by caches that have been configured to return stale responses to client requests.
"If the no-cache directive does specify one or more field-names, then a cache MAY use the response to satisfy a subsequent request, subject to any other restrictions on caching."
"However, the specified field-name(s) MUST NOT be sent in the response to a subsequent request without successful revalidation with the origin server."
"This allows an origin server to prevent the re-use of certain header fields in a response, while still allowing caching of the rest of the response."
Note: Most HTTP/1.0 caches will not recognize or obey this directive.
"The purpose of the no-store directive is to prevent the inadvertent release or retention of sensitive information (for example, on backup tapes)."
"The no-store directive applies to the entire message, and MAY be sent either in a response or in a request."
"If sent in a request, a cache MUST NOT store any part of either this request or any response to it."
"If sent in a response, a cache MUST NOT store any part of either this response or the request that elicited it."
"This directive applies to both non- shared and shared caches. ""MUST NOT store"" in this context means that the cache MUST NOT intentionally store the information in non-volatile storage, and MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it."
The purpose of this directive is to meet the stated requirements of certain users and service authors who are concerned about accidental releases of information via unanticipated accesses to cache data structures.
"While the use of this directive might improve privacy in some cases, we caution that it is NOT in any way a reliable or sufficient mechanism for ensuring privacy."
"In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping."
"When the max-age cache-control directive is present in a cached response, the response is stale if its current age is greater than the age value given (in seconds) at the time of a new request for that resource."
"The max-age directive on a response implies that the response is cacheable (i.e., ""public"") unless some other, more restrictive cache directive is also present."
"If a response includes both an Expires header and a max-age directive, the max-age directive overrides the Expires header, even if the Expires header is more restrictive."
"This might be useful if certain HTTP/1.0 caches improperly calculate ages or expiration times, perhaps due to desynchronized clocks."
"Many HTTP/1.0 cache implementations will treat an Expires value that is less than or equal to the response Date value as being equivalent to the Cache-Control response directive ""no-cache""."
"If an HTTP/1.1 cache receives such a response, and the response does not include a Cache-Control header field, it SHOULD consider the response to be non-cacheable in order to retain compatibility with HTTP/1.0 servers."
"An origin server might wish to use a relatively new HTTP cache control feature, such as the ""private"" directive, on a network including older caches that do not understand that feature."
The origin server will need to combine the new feature with an Expires field whose value is less than or equal to the Date value.
This will prevent older caches from improperly caching the response.
"If a response includes an s-maxage directive, then for a shared cache (but not for a private cache), the maximum age specified by this directive overrides the maximum age specified by either the max-age directive or the Expires header."
"The s-maxage directive also implies the semantics of the proxy-revalidate directive (see section 14.9.4), i.e., that the shared cache must not use the entry after it becomes stale to respond to a subsequent request without first revalidating it with the origin server."
The s- maxage directive is always ignored by a private cache.
"Note that most older caches, not compliant with this specification, do not implement any cache-control directives."
"An origin server wishing to use a cache-control directive that restricts, but does not prevent, caching by an HTTP/1.1-compliant cache MAY exploit the requirement that the max-age directive overrides the Expires header, and the fact that pre-HTTP/1.1-compliant caches do not observe the max-age directive."
max-age Indicates that the client is willing to accept a response whose age is no greater than the specified time in seconds.
"Unless max- stale directive is also included, the client is not willing to accept a stale response."
min-fresh Indicates that the client is willing to accept a response whose freshness lifetime is no less than its current age plus the specified time in seconds.
"That is, the client wants a response that will still be fresh for at least the specified number of seconds."
max-stale Indicates that the client is willing to accept a response that has exceeded its expiration time.
"If max-stale is assigned a value, then the client is willing to accept a response that has exceeded its expiration time by no more than the specified number of seconds."
"If no value is assigned to max-stale, then the client is willing to accept a stale response of any age."
"If a cache returns a stale response, either because of a max-stale directive on a request, or because the cache is configured to override the expiration time of a response, the cache MUST attach a Warning header to the stale response, using Warning 110 (Response is stale)."
"A cache MAY be configured to return stale responses without validation, but only if this does not conflict with any ""MUST""-level requirements concerning cache validation (e.g., a ""must-revalidate"" cache-control directive)."
"Sometimes a user agent might want or need to insist that a cache revalidate its cache entry with the origin server (and not just with the next cache along the path to the origin server), or to reload its cache entry from the origin server."
End-to-end revalidation might be necessary if either the cache or the origin server has overestimated the expiration time of the cached response.
End-to-end reload may be necessary if the cache entry has become corrupted for some reason.
"The request includes a ""no-cache"" cache-control directive or, for compatibility with HTTP/1.0 clients, ""Pragma: no-cache""."
Field names MUST NOT be included with the no-cache directive in a request.
The server MUST NOT use a cached copy when responding to such a request.
The initial request includes a cache-validating conditional with the client's current validator.
The initial request does not include a cache-validating conditional; the first cache along the path (if any) that holds a cache entry for this resource includes a cache-validating conditional with its current validator.
"When an intermediate cache is forced, by means of a max-age=0 directive, to revalidate its own cache entry, and the client has supplied its own validator in the request, the supplied validator might differ from the validator currently stored with the cache entry."
"In this case, the cache MAY use either validator in making its own request without affecting semantic transparency."
"However, the choice of validator might affect performance."
The best approach is for the intermediate cache to use its own validator when making its request.
"If the server replies with 304 (Not Modified), then the cache can return its now validated copy to the client with a 200 (OK) response."
"If the server replies with a new entity and cache validator, however, the intermediate cache can compare the returned validator with the one provided in the client's request, using the strong comparison function."
"If the client's validator is equal to the origin server's, then the intermediate cache simply returns 304 (Not Modified)."
"If a request includes the no-cache directive, it SHOULD NOT include min-fresh, max-stale, or max-age."
"In some cases, such as times of extremely poor network connectivity, a client may want a cache to return only those responses that it currently has stored, and not to reload or revalidate with the origin server."
"If it receives this directive, a cache SHOULD either respond using a cached entry that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status."
"However, if a group of caches is being operated as a unified system with good internal connectivity, such a request MAY be forwarded within that group of caches."
The must-revalidate directive is necessary to support reliable operation for certain protocol features.
"In all circumstances an HTTP/1.1 cache MUST obey the must-revalidate directive; in particular, if the cache cannot reach the origin server for any reason, it MUST generate a 504 (Gateway Timeout) response."
"Servers SHOULD send the must-revalidate directive if and only if failure to revalidate a request on the entity could result in incorrect operation, such as a silently unexecuted financial transaction."
"Recipients MUST NOT take any automated action that violates this directive, and MUST NOT automatically provide an unvalidated copy of the entity if revalidation fails."
"Although this is not recommended, user agents operating under severe connectivity constraints MAY violate this directive but, if so, MUST explicitly warn the user that an unvalidated response has been provided."
"The warning MUST be provided on each unvalidated access, and SHOULD require explicit user confirmation."
"The proxy-revalidate directive has the same meaning as the must- revalidate directive, except that it does not apply to non-shared user agent caches."
no-transform Implementors of intermediate caches (proxies) have found it useful to convert the media type of certain entity bodies.
"A non- transparent proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link."
"Therefore, if a message includes the no-transform directive, an intermediate cache or proxy MUST NOT change those headers that are listed in section 13.5.2 as being subject to the no-transform directive."
"This implies that the cache or proxy MUST NOT change any aspect of the entity-body that is specified by these headers, including the value of the entity-body itself."
"The Cache-Control header field can be extended through the use of one or more cache-extension tokens, each with an optional assigned value."
Informational extensions (those which do not require a change in cache behavior) MAY be added without changing the semantics of other directives.
Behavioral extensions are designed to work by acting as modifiers to the existing base of cache directives.
"Both the new directive and the standard directive are supplied, such that applications which do not understand the new directive will default to the behavior specified by the standard directive, and those that understand the new directive will recognize it as modifying the requirements associated with the standard directive."
"In this way, extensions to the cache-control directives can be made without requiring changes to the base protocol."
"This extension mechanism depends on an HTTP cache obeying all of the cache-control directives defined for its native HTTP-version, obeying certain extensions, and ignoring all directives that it does not understand."
"A cache seeing this header field will act correctly even if the cache does not understand the community cache-extension, since it will also see and understand the private directive and thus default to the safe behavior."
Unrecognized cache-directives MUST be ignored; it is assumed that any cache-directive likely to be unrecognized by an HTTP/1.1 cache will be combined with standard directives (or the response's default cacheability) such that the cache behavior will remain minimally correct even if the cache does not understand the extension(s).
The Connection general-header field allows the sender to specify options that are desired for that particular connection and MUST NOT be communicated by proxies over further connections.
"HTTP/1.1 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token."
"Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional header field may not be sent if there are no parameters associated with that connection option."
"Message headers listed in the Connection header MUST NOT include end-to-end headers, such as Cache-Control."
in either the request or the response header fields indicates that the connection SHOULD NOT be considered `persistent' (section 8.1) after the current request/response is complete.
"HTTP/1.1 applications that do not support persistent connections MUST include the ""close"" connection option in every message."
This protects against mistaken forwarding of such header fields by pre-HTTP/1.1 proxies.
The Content-Encoding entity-header field is used as a modifier to the media-type.
"When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field."
Content-Encoding is primarily used to allow a document to be compressed without losing the identity of its underlying media type.
"Typically, the entity-body is stored with this encoding and is only decoded before rendering or analogous usage."
"However, a non-transparent proxy MAY modify the content-coding if the new coding is known to be acceptable to the recipient, unless the ""no-transform"" cache-control directive is present in the message."
"If the content-coding of an entity is not ""identity"", then the response MUST include a Content-Encoding entity-header (section 14.11) that lists the non-identity content-coding(s) used."
"If the content-coding of an entity in a request message is not acceptable to the origin server, the server SHOULD respond with a status code of 415 (Unsupported Media Type)."
Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.
"If no Content-Language is specified, the default is that the content is intended for all language audiences."
"This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended."
"However, just because multiple languages are present within an entity does not mean that it is intended for multiple linguistic audiences."
Content-Language MAY be applied to any media type -- it is not limited to textual documents.
"Applications SHOULD use this field to indicate the transfer-length of the message-body, unless this is prohibited by the rules in section 4.4."
Any Content-Length greater than or equal to zero is a valid value.
Section 4.4 describes how to determine the length of a message-body if a Content-Length is not given.
"In HTTP, it SHOULD be sent whenever the message's length can be determined prior to being transferred, unless this is prohibited by the rules in section 4.4."
The Content-Location value is not a replacement for the original requested URI; it is only a statement of the location of the resource corresponding to this particular entity at the time of the request.
A cache cannot assume that an entity with a Content-Location different from the URI used to retrieve it can be used to respond to later requests on that Content-Location URI.
"If the Content-Location is a relative URI, the relative URI is interpreted relative to the Request-URI."
The meaning of the Content-Location header in PUT or POST requests is undefined; servers are free to ignore it in those cases.
"Only origin servers or clients MAY generate the Content-MD5 header field; proxies and gateways MUST NOT generate it, as this would defeat its value as an end-to-end integrity check."
"The MD5 digest is computed based on the content of the entity-body, including any content-coding that has been applied, but not including any transfer-encoding applied to the message-body."
"If the message is received with a transfer-encoding, that encoding MUST be removed prior to checking the Content-MD5 value against the received entity."
"This has the result that the digest is computed on the octets of the entity-body exactly as, and in the order that, they would be sent if no transfer-encoding were being applied."
"HTTP extends RFC 1864 to permit the digest to be computed for MIME composite media-types (e.g., multipart/* and message/rfc822), but this does not change how the digest is computed as defined in the preceding paragraph."
"The entity-body for composite types MAY contain many body-parts, each with its own MIME and HTTP headers (including Content-MD5, Content-Transfer-Encoding, and Content-Encoding headers)."
"If a body-part has a Content-Transfer- Encoding or Content-Encoding header, it is assumed that the content of the body-part has had the encoding applied, and the body-part is included in the Content-MD5 digest as is -- i.e., after the application."
The Transfer-Encoding header field is not allowed within body-parts.
Conversion of all line breaks to CRLF MUST NOT be done before computing or checking the digest: the line break convention used in the text actually transmitted MUST be left unaltered when computing the digest.
"One is that HTTP, unlike MIME, does not use Content-Transfer-Encoding, and does use Transfer-Encoding and Content-Encoding."
"Another is that HTTP more frequently uses binary content types than MIME, so it is worth noting that, in such cases, the byte order used to compute the digest is the transmission byte order defined for the type."
"Lastly, HTTP allows transmission of text types with any of several line break conventions and not just the canonical form using CRLF."
The Content-Range entity-header is sent with a partial entity-body to specify where in the full entity-body the partial body should be applied.
"The header SHOULD indicate the total length of the full entity-body, unless this length is unknown or difficult to determine."
"The asterisk ""*"" character means that the instance-length is unknown at the time when the response was generated."
"byte-pos value is less than its first-byte-pos value, or whose instance-length value is less than or equal to its last-byte-pos value, is invalid."
The recipient of an invalid byte-content-range- spec MUST ignore it and any content transferred along with it.
"A server sending a response with status code 416 (Requested range not satisfiable) SHOULD include a Content-Range field with a byte-range- resp-spec of ""*""."
"A response with status code 206 (Partial Content) MUST NOT include a Content-Range field with a byte-range- resp-spec of ""*""."
"The multipart media type used for this purpose is ""multipart/byteranges"" as defined in appendix 19.2."
A response to a request for a single range MUST NOT be sent using the multipart/byteranges media type.
A client that cannot decode a multipart/byteranges message MUST NOT ask for multiple byte-ranges in a single request.
"When a client requests multiple byte-ranges in one request, the server SHOULD return them in the order that they appeared in the request."
"If the server ignores a byte-range-spec because it is syntactically invalid, the server SHOULD treat the request as if the invalid Range header field did not exist."
"If the server receives a request (other than one including an If- Range request-header field) with an unsatisfiable Range request- header field (that is, all of whose byte-range-spec values have a first-byte-pos value greater than the current length of the selected resource), it SHOULD return a response code of 416 (Requested range not satisfiable) (section 10.4.17)."
"Note: clients cannot depend on servers to send a 416 (Requested range not satisfiable) response instead of a 200 (OK) response for an unsatisfiable Range request-header, since not all servers implement this request-header."
"The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET."
"If the response status code conveys a server error, e.g. 500 (Internal Server Error) or 503 (Service Unavailable), and it is inconvenient or impossible to generate a valid Date."
"If the server does not have a clock that can provide a reasonable approximation of the current time, its responses MUST NOT include a Date header field."
A received message that does not have a Date header field MUST be assigned one by the recipient if the message will be cached by that recipient or gatewayed via a protocol which requires a Date.
An HTTP implementation without a clock MUST NOT cache responses without revalidating them on every use.
A client without a clock MUST NOT send a Date header field in a request.
The HTTP-date sent in a Date header SHOULD NOT represent a date and time subsequent to the generation of the message.
"It SHOULD represent the best available approximation of the date and time of message generation, unless the implementation has no means of generating a reasonably accurate date and time."
"In theory, the date ought to represent the moment just before the entity is generated."
"In practice, the date can be generated at any time during the message origination without affecting its semantic value."
Some origin server implementations might not have a clock available.
"An origin server without a clock MUST NOT assign Expires or Last- Modified values to a response, unless these values were associated with the resource by a system or user with a reliable clock."
"It MAY assign an Expires value that is known, at or before server configuration time, to be in the past (this allows ""pre-expiration"" of responses without storing separate Expires values for each resource)."
The Expect request-header field is used to indicate that particular server behaviors are required by the client.
A server that does not understand or is unable to comply with any of the expectation values in the Expect field of a request MUST respond with appropriate error status.
"The server MUST respond with a 417 (Expectation Failed) status if any of the expectations cannot be met or, if there are other problems with the request, some other 4xx status."
This header field is defined with extensible syntax to allow for future extensions.
"If a server receives a request containing an Expect field that includes an expectation-extension that it does not support, it MUST respond with a 417 (Expectation Failed) status."
"Comparison of expectation values is case-insensitive for unquoted tokens (including the 100-continue token), and is case-sensitive for quoted-string expectation-extensions."
"The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST return a 417 (Expectation Failed) status if it receives a request with an expectation that it cannot meet."
"However, the Expect request-header itself is end-to-end; it MUST be forwarded if the request is forwarded."
Many older HTTP/1.0 and HTTP/1.1 applications do not understand the Expect header.
The Expires entity-header field gives the date/time after which the response is considered stale.
A stale cache entry may not normally be returned by a cache (either a proxy cache or a user agent cache) unless it is first validated with the origin server (or with an intermediate cache that has a fresh copy of the entity).
"The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time."
"HTTP/1.1 clients and caches MUST treat other invalid date formats, especially including the value ""0"", as in the past (i.e., ""already expired"")."
"To mark a response as ""already expired,"" an origin server sends an Expires date that is equal to the Date header value."
"To mark a response as ""never expires,"" an origin server sends an Expires date approximately one year from the time the response is sent."
HTTP/1.1 servers SHOULD NOT send Expires dates more than one year in the future.
"The presence of an Expires header field with a date value of some time in the future on a response that otherwise would by default be non-cacheable indicates that the response is cacheable, unless indicated otherwise by a Cache-Control header field (section 14.9)."
This header field MAY be used for logging purposes and as a means for identifying the source of invalid or unwanted requests.
It SHOULD NOT be used as an insecure form of access protection.
"In particular, robot agents SHOULD include this header so that the person responsible for running the robot can be contacted if problems occur on the receiving end."
"For example, when a request is passed through a proxy the original issuer's address SHOULD be used."
"The client SHOULD NOT send the From header field without the user's approval, as it might conflict with the user's privacy interests or their site's security policy."
"It is strongly recommended that the user be able to disable, enable, and modify the value of this field at any time prior to a request."
"The Host request-header field specifies the Internet host and port number of the resource being requested, as obtained from the original URI given by the user or referring resource (generally an HTTP URL, as described in section 3.2.2)."
"If the requested URI does not include an Internet host name for the service being requested, then the Host header field MUST be given with an empty value."
An HTTP/1.1 proxy MUST ensure that any request message it forwards does contain an appropriate Host header field that identifies the service being requested by the proxy.
All Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message which lacks a Host header field.
The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead.
"It is also used, on updating requests, to prevent inadvertent modification of the wrong version of a resource."
"If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-Match header) on that resource, or if ""*"" is given and any current entity exists for that resource, then the server MAY perform the requested method as if the If-Match header field did not exist."
"If none of the entity tags match, or if ""*"" is given and no current entity exists, the server MUST NOT perform the requested method, and MUST return a 412 (Precondition Failed) response."
"This behavior is most useful when the client wants to prevent an updating method, such as PUT, from modifying a resource that has changed since the client last retrieved it."
"If the request would, without the If-Match header field, result in anything other than a 2xx or 412 status, then the If-Match header MUST be ignored."
"The meaning of ""If-Match: *"" is that the method SHOULD be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section 14.44) exists, and MUST NOT be performed if the representation does not exist."
The result of a request having both an If-Match header field and either an If-None-Match or an If-Modified-Since header fields is undefined by this specification.
"The If-Modified-Since request-header field is used with a method to make it conditional: if the requested variant has not been modified since the time specified in this field, an entity will not be returned from the server; instead, a 304 (not modified) response will be returned without any message-body.
a)"
"If the request would normally result in anything other than a 200 (OK) status, or if the passed If-Modified-Since date is invalid, the response is exactly the same as for a normal GET."
A date which is later than the server's current time is invalid.
"If the variant has been modified since the If-Modified-Since date, the response is exactly the same as for a normal GET.
c)"
"If the variant has not been modified since a valid If- Modified-Since date, the server SHOULD return a 304 (Not Modified) response."
The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead.
"Note: If-Modified-Since times are interpreted by the server, whose clock might not be synchronized with the client."
"Note: When handling an If-Modified-Since header field, some servers will use an exact date comparison function, rather than a less-than function, for deciding whether to send a 304 (Not Modified) response."
"To get best results when sending an If- Modified-Since header field for cache validation, clients are advised to use the exact date string received in a previous Last- Modified header field whenever possible."
"If a client uses an arbitrary date in the If-Modified-Since header instead of a date taken from the Last-Modified header for the same request, the client should be aware of the fact that this date is interpreted in the server's understanding of time."
The client should consider unsynchronized clocks and rounding problems due to the different encodings of time between the client and server.
Corrections for different time bases between client and server are at best approximate due to network latency.
The result of a request having both an If-Modified-Since header field and either an If-Match or an If-Unmodified-Since header fields is undefined by this specification.
The If-None-Match request-header field is used with a method to make it conditional.
A client that has one or more entities previously obtained from the resource can verify that none of those entities is current by including a list of their associated entity tags in the If-None-Match header field.
The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead.
It is also used to prevent a method (e.g. PUT) from inadvertently modifying an existing resource when the client believes that the resource does not exist.
"If any of the entity tags match the entity tag of the entity that would have been returned in the response to a similar GET request (without the If-None-Match header) on that resource, or if ""*"" is given and any current entity exists for that resource, then the server MUST NOT perform the requested method, unless required to do so because the resource's modification date fails to match that supplied in an If-Modified-Since header field in the request."
"Instead, if the request method was GET or HEAD, the server SHOULD respond with a 304 (Not Modified) response, including the cache- related header fields (particularly ETag) of one of the entities that matched."
"For all other request methods, the server MUST respond with a status of 412 (Precondition Failed)."
The weak comparison function can only be used with GET or HEAD requests.
"If none of the entity tags match, then the server MAY perform the requested method as if the If-None-Match header field did not exist, but MUST also ignore any If-Modified-Since header field(s) in the request."
"That is, if no entity tags match, then the server MUST NOT return a 304 (Not Modified) response."
"The meaning of ""If-None-Match: *"" is that the method MUST NOT be performed if the representation selected by the origin server (or by a cache, possibly using the Vary mechanism, see section 14.44) exists, and SHOULD be performed if the representation does not exist."
The result of a request having both an If-None-Match header field and either an If-Match or an If-Unmodified-Since header fields is undefined by this specification.
"However, if the condition fails because the entity has been modified, the client would then have to make a second request to obtain the entire current entity-body."
"The If-Range header allows a client to ""short-circuit"" the second request."
"Informally, its meaning is `if the entity is unchanged, send me the part(s) that I am missing; otherwise, send me the entire new entity'."
"If the entity tag given in the If-Range header matches the current entity tag for the entity, then the server SHOULD provide the specified sub-range of the entity using a 206 (Partial content) response."
"If the entity tag does not match, then the server SHOULD return the entire entity using a 200 (OK) response."
The If-Unmodified-Since request-header field is used with a method to make it conditional.
"If the requested resource has not been modified since the time specified in this field, the server SHOULD perform the requested operation as if the If-Unmodified-Since header were not present."
"If the requested variant has been modified since the specified time, the server MUST NOT perform the requested operation, and MUST return a 412 (Precondition Failed)."
"If the request normally (i.e., without the If-Unmodified-Since header) would result in anything other than a 2xx or 412 status, the If-Unmodified-Since header SHOULD be ignored."
"If the specified date is invalid, the header is ignored."
The result of a request having both an If-Unmodified-Since header field and either an If-None-Match or an If-Modified-Since header fields is undefined by this specification.
The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.
The exact meaning of this header field depends on the implementation of the origin server and the nature of the original resource.
An origin server MUST NOT send a Last-Modified date which is later than the server's time of message origination.
"In such cases, where the resource's last modification would indicate some time in the future, the server MUST replace that date with the message origination date."
An origin server SHOULD obtain the Last-Modified value of the entity as close as possible to the time that it generates the Date value of its response.
"This allows a recipient to make an accurate assessment of the entity's modification time, especially if the entity changes near the time that the response is generated."
HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.
"For 3xx responses, the location SHOULD indicate the server's preferred URI for automatic redirection to the resource."
It is therefore possible for a response to contain header fields for both Location and Content-Location.
The Max-Forwards request-header field provides a mechanism with the TRACE (section 9.8) and OPTIONS (section 9.2) methods to limit the number of proxies or gateways that can forward the request to the next inbound server.
This can be useful when the client is attempting to trace a request chain which appears to be failing or looping in mid-chain.
The Max-Forwards value is a decimal integer indicating the remaining number of times this request message may be forwarded.
"If the received value is zero (0), the recipient MUST NOT forward the request; instead, it MUST respond as the final recipient."
"If the received Max-Forwards value is greater than zero, then the forwarded message MUST contain an updated Max-Forwards field with a value decremented by one (1)."
The Max-Forwards header field MAY be ignored for all other methods defined by this specification and for any extension methods for which it is not explicitly referred to as part of that method definition.
The Pragma general-header field is used to include implementation- specific directives that might apply to any recipient along the request/response chain.
"All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives."
"When the no-cache directive is present in a request message, an application SHOULD forward the request toward the origin server even if it has a cached copy of what is being requested."
This pragma directive has the same semantics as the no-cache cache-directive (see section 14.9) and is defined here for backward compatibility with HTTP/1.0. Clients SHOULD include both header fields when a no-cache request is sent to a server not known to be HTTP/1.1 compliant.
"It is not possible to specify a pragma for a specific recipient; however, any pragma directive not relevant to a recipient SHOULD be ignored by that recipient."
"HTTP/1.1 caches SHOULD treat ""Pragma: no-cache"" as if the client had sent ""Cache-Control: no-cache""."
No new Pragma directives will be defined in HTTP.
The Proxy-Authenticate response-header field MUST be included as part of a 407 (Proxy Authentication Required) response.
"The HTTP access authentication process is described in ""HTTP Authentication: Basic and Digest Access Authentication"" [43]."
"Unlike WWW-Authenticate, the Proxy-Authenticate header field applies only to the current connection and SHOULD NOT be passed on to downstream clients."
"However, an intermediate proxy might need to obtain its own credentials by requesting them from the downstream client, which in some circumstances will appear as if the proxy is forwarding the Proxy-Authenticate header field."
The Proxy-Authorization request-header field allows the client to identify itself (or its user) to a proxy which requires authentication.
"The HTTP access authentication process is described in ""HTTP Authentication: Basic and Digest Access Authentication"" [43] . Unlike Authorization, the Proxy-Authorization header field applies only to the next outbound proxy that demanded authentication using the Proxy- Authenticate field."
"When multiple proxies are used in a chain, the Proxy-Authorization header field is consumed by the first outbound proxy that was expecting to receive credentials."
Byte range specifications in HTTP apply to the sequence of bytes in the entity-body (not necessarily the same as the message-body).
The first-byte-pos value in a byte-range-spec gives the byte-offset of the first byte in a range.
"The last-byte-pos value gives the byte-offset of the last byte in the range; that is, the byte positions specified are inclusive."
Byte offsets start at zero.
"If the last-byte-pos value is present, it MUST be greater than or equal to the first-byte-pos in that byte-range-spec, or the byte- range-spec is syntactically invalid."
The recipient of a byte-range- set that includes one or more syntactically invalid byte-range-spec values MUST ignore the header field that includes that byte-range- set.
"If the last-byte-pos value is absent, or if the value is greater than or equal to the current length of the entity-body, last-byte-pos is taken to be equal to one less than the current length of the entity- body in bytes."
"A suffix-byte-range-spec is used to specify the suffix of the entity-body, of a length given by the suffix-length value."
"(That is, this form specifies the last N bytes of an entity-body.)"
"If the entity is shorter than the specified suffix-length, the entire entity-body is used."
"If a syntactically valid byte-range-set includes at least one byte- range-spec whose first-byte-pos is less than the current length of the entity-body, or at least one suffix-byte-range-spec with a non- zero suffix-length, then the byte-range-set is satisfiable."
"If the byte-range-set is unsatisfiable, the server SHOULD return a response with a status of 416 (Requested range not satisfiable)."
"Otherwise, the server SHOULD return a response with a status of 206 (Partial Content) containing the satisfiable ranges of the entity-body."
The presence of a Range header in an unconditional GET modifies what is returned if the GET is otherwise successful.
"The presence of a Range header in a conditional GET (a request using one or both of If-Modified-Since and If-None-Match, or one or both of If-Unmodified-Since and If-Match) modifies what is returned if the GET is otherwise successful and the condition is true."
It does not affect the 304 (Not Modified) response returned if the conditional is false.
"If a proxy that supports ranges receives a Range request, forwards the request to an inbound server, and receives an entire entity in reply, it SHOULD only return the requested range to its client."
It SHOULD store the entire received response in its cache if that is consistent with its cache allocation policies.
"The Referer[sic] request-header field allows the client to specify, for the server's benefit, the address (URI) of the resource from which the Request-URI was obtained (the ""referrer"", although the header field is misspelled.)"
"The Referer request-header allows a server to generate lists of back-links to resources for interest, logging, optimized caching, etc."
"The Referer field MUST NOT be sent if the Request-URI was obtained from a source that does not have its own URI, such as input from the user keyboard."
"If the field value is a relative URI, it SHOULD be interpreted relative to the Request-URI."
The URI MUST NOT include a fragment.
The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client.
This field MAY also be used with any 3xx (Redirection) response to indicate the minimum time the user-agent is asked wait before issuing the redirected request.
"In the latter example, the delay is 2 minutes."
The Server response-header field contains information about the software used by the origin server to handle the request.
The field can contain multiple product tokens (section 3.8) and comments identifying the server and any significant subproducts.
"If the response is being forwarded through a proxy, the proxy application MUST NOT modify the Server response-header."
Note: Revealing the specific software version of the server might allow the server machine to become more vulnerable to attacks against software that is known to contain security holes.
The TE request-header field indicates what extension transfer-codings it is willing to accept in the response and whether or not it is willing to accept trailer fields in a chunked transfer-coding.
"Its value may consist of the keyword ""trailers"" and/or a comma-separated list of extension transfer-coding names with optional accept parameters (as described in section 3.6)."
"The presence of the keyword ""trailers"" indicates that the client is willing to accept trailer fields in a chunked transfer-coding, as defined in section 3.6.1."
This keyword is reserved for use with transfer-coding values even though it does not itself represent a transfer-coding.
The TE header field only applies to the immediate connection.
"Therefore, the keyword MUST be supplied within a Connection header field (section 14.10) whenever TE is present in an HTTP/1.1 message."
"The ""chunked"" transfer-coding is always acceptable."
"If the keyword ""trailers"" is listed, the client indicates that it is willing to accept trailer fields in the chunked response on behalf of itself and any downstream clients."
"The implication is that, if given, the client is stating that either all downstream clients are willing to accept trailer fields in the forwarded response, or that it will attempt to buffer the response on behalf of downstream recipients."
Note: HTTP/1.1 does not define any means to limit the size of a chunked response such that a client can be assured of buffering the entire response.
"If the transfer-coding being tested is one of the transfer- codings listed in the TE field, then it is acceptable unless it is accompanied by a qvalue of 0."
"(As defined in section 3.9, a qvalue of 0 means ""not acceptable."")"
"3. If multiple transfer-codings are acceptable, then the acceptable transfer-coding with the highest non-zero qvalue is preferred."
"If the TE field-value is empty or if no TE field is present, the only transfer-coding  is ""chunked""."
A message with no transfer-coding is always acceptable.
The Trailer general field value indicates that the given set of header fields is present in the trailer of a message encoded with chunked transfer-coding.
An HTTP/1.1 message SHOULD include a Trailer header field in a message using chunked transfer-coding with a non-empty trailer.
"If no Trailer header field is present, the trailer SHOULD NOT include any header fields."
"See section 3.6.1 for restrictions on the use of trailer fields in a ""chunked"" transfer-coding."
"This differs from the content-coding in that the transfer-coding is a property of the message, not of the entity."
Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.
Many older HTTP/1.0 applications do not understand the Transfer- Encoding header.
The Upgrade general-header allows the client to specify what additional communication protocols it supports and would like to use if the server finds it appropriate to switch protocols.
The server MUST use the Upgrade header field within a 101 (Switching Protocols) response to indicate which protocol(s) are being switched.
"The Upgrade header field is intended to provide a simple mechanism for transition from HTTP/1.1 to some other, incompatible protocol."
"It does so by allowing the client to advertise its desire to use another protocol, such as a later version of HTTP with a higher major version number, even though the current request has been made using HTTP/1.1."
"This eases the difficult transition between incompatible protocols by allowing the client to initiate a request in the more commonly supported protocol while indicating to the server that it would like to use a ""better"" protocol if available (where ""better"" is determined by the server, possibly according to the nature of the method and/or resource being requested)."
Upgrade cannot be used to insist on a protocol change; its acceptance and use by the server is optional.
The Upgrade header field only applies to the immediate connection.
"Therefore, the upgrade keyword MUST be supplied within a Connection header field (section 14.10) whenever Upgrade is present in an HTTP/1.1 message."
The Upgrade header field cannot be used to indicate a switch to a protocol on a different connection.
"This specification only defines the protocol name ""HTTP"" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of section 3.1 and future updates to this specification."
The User-Agent request-header field contains information about the user agent originating the request.
"This is for statistical purposes, the tracing of protocol violations, and automated recognition of user agents for the sake of tailoring responses to avoid particular user agent limitations."
User agents SHOULD include this field with requests.
"For uncacheable or stale responses, the Vary field value advises the user agent about the criteria that were used to select the representation."
"A Vary field value of ""*"" implies that a cache cannot determine from the request headers of a subsequent request whether this response is the appropriate representation."
An HTTP/1.1 server SHOULD include a Vary header field with any cacheable response that is subject to server-driven negotiation.
Doing so allows a cache to properly interpret future requests on that resource and informs the user agent about the presence of negotiation on that resource.
"A server MAY include a Vary header field with a non-cacheable response that is subject to server-driven negotiation, since this might provide the user agent with useful information about the dimensions over which the response varies at the time of the response."
"A cache MAY assume that the same selection will be made for future requests with the same values for the listed field names, for the duration of time for which the response is fresh."
The field-names given are not limited to the set of standard request-header fields defined by this specification.
Field names are case-insensitive.
"A Vary field value of ""*"" signals that unspecified parameters not limited to the request-headers (e.g., the network address of the client), play a role in the selection of the response representation."
"The ""*"" value MUST NOT be generated by a proxy server; it may only be generated by an origin server."
"It is analogous to the ""Received"" field of RFC 822 [9] and is intended to be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of all senders along the request/response chain."
The received-protocol version is appended to the Via field value when the message is forwarded so that information about the protocol capabilities of upstream applications remains visible to all recipients.
The received-by field is normally the host and optional port number of a recipient server or client that subsequently forwarded the message.
"If the port is not given, it MAY be assumed to be the default port of the received-protocol."
Each recipient MUST append its information such that the end result is ordered according to the sequence of forwarding applications.
"Comments MAY be used in the Via header field to identify the software of the recipient proxy or gateway, analogous to the User-Agent and Server header fields."
"However, all comments in the Via field are optional and MAY be removed by any recipient prior to forwarding the message."
"Proxies and gateways used as a portal through a network firewall SHOULD NOT, by default, forward the names and ports of hosts within the firewall region."
This information SHOULD only be propagated if explicitly enabled.
"If not enabled, the received-by host of any host behind the firewall SHOULD be replaced by an appropriate pseudonym for that host."
"Via: 1.0 ricky, 1.1 mertz, 1.0 lucy Applications SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms."
Applications MUST NOT combine entries which have different received-protocol values.
This information is typically used to warn about a possible lack of semantic transparency from caching operations or transformations applied to the entity body of the message.
A response MAY carry more than one Warning header.
The warn-text SHOULD be in a natural language and character set that is most likely to be intelligible to the human user receiving the response.
"Warning headers can in general be applied to any message, however some specific warn-codes are specific to caches and can only be applied to response messages."
New Warning headers SHOULD be added after any existing Warning headers.
A cache MUST NOT delete any Warning header that it received with a message.
"However, if a cache successfully validates a cache entry, it SHOULD remove any Warning headers previously attached to that entry except as specified for specific Warning codes."
It MUST then add any Warning headers received in the validating response.
"In other words, Warning headers are those that would be attached to the most recent relevant response."
Warnings in the user's preferred character set take priority over warnings in other character sets but with identical warn- codes and warn-agents.
Systems that generate multiple Warning headers SHOULD order them with this user agent behavior in mind.
"This is a list of the currently-defined warn-codes, each with a recommended warn-text in English, and a description of its meaning."
Response is stale MUST be included whenever the returned response is stale.
"Revalidation failed MUST be included if a cache returns a stale response because an attempt to revalidate the response failed, due to an inability to reach the server."
Disconnected operation SHOULD be included if the cache is intentionally disconnected from the rest of the network for a period of time.
Heuristic expiration MUST be included if the cache heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours.
"A system receiving this warning MUST NOT take any automated action, besides presenting the warning to the user."
A system receiving this warning MUST NOT take any automated action.
"If an implementation receives a message with a warning-value that includes a warn-date, and that warn-date is different from the Date value in the response, then that warning-value MUST be deleted from the message before storing, forwarding, or using it."
(This prevents bad consequences of naive caching of Warning header fields.)
"If all of the warning-values are deleted for this reason, the Warning header MUST be deleted as well."
The WWW-Authenticate response-header field MUST be included in 401 (Unauthorized) response messages.
"The HTTP access authentication process is described in ""HTTP Authentication: Basic and Digest Access Authentication"" [43]."
"User agents are advised to take special care in parsing the WWW- Authenticate field value as it might contain more than one challenge, or if more than one WWW-Authenticate header field is provided, the contents of a challenge itself can contain a comma-separated list of authentication parameters."
"This section is meant to inform application developers, information providers, and users of the security limitations in HTTP/1.1 as described by this document."
"The discussion does not include definitive solutions to the problems revealed, though it does make some suggestions for reducing security risks."
"HTTP clients are often privy to large amounts of personal information (e.g. the user's name, location, mail address, passwords, encryption keys, etc.), and SHOULD be very careful to prevent unintentional leakage of this information via the HTTP protocol to other sources."
"We very strongly recommend that a convenient interface be provided for the user to control dissemination of such information, and that designers and implementors be particularly careful in this area."
History shows that errors in this area often create serious security and/or privacy problems and generate highly adverse publicity for the implementor's company.
This information is clearly confidential in nature and its handling can be constrained by law in certain countries.
People using the HTTP protocol to provide data are responsible for ensuring that such material is not distributed without the permission of any individuals that are identifiable by the published results.
"Like any generic data transfer protocol, HTTP cannot regulate the content of the data that is transferred, nor is there any a priori method of determining the sensitivity of any particular piece of information within the context of any given request."
"Therefore, applications SHOULD supply as much control over this information as possible to the provider of that information."
"Four header fields are worth special mention in this context: Server, Via, Referer and From."
Revealing the specific software version of the server might allow the server machine to become more vulnerable to attacks against software that is known to contain security holes.
Implementors SHOULD make the Server header field a configurable option.
Proxies which serve as a portal through a network firewall SHOULD take special precautions regarding the transfer of header information that identifies the hosts behind the firewall.
"In particular, they SHOULD remove, or replace with sanitized versions, any Via fields generated behind the firewall."
The Referer header allows reading patterns to be studied and reverse links drawn.
"Although it can be very useful, its power can be abused if user details are not separated from the information contained in the Referer."
"Even when the personal information has been removed, the Referer header might indicate a private document's URI whose publication would be inappropriate."
"The information sent in the From field might conflict with the user's privacy interests or their site's security policy, and hence it SHOULD NOT be transmitted without the user being able to disable, enable, and modify the contents of the field."
The user MUST be able to set the contents of this field within a user preference or application defaults configuration.
"We suggest, though do not require, that a convenient toggle interface be provided for the user to enable or disable the sending of From and Referer information."
The User-Agent (section 14.43) or Server (section 14.38) header fields can sometimes be used to determine that a specific client or server have a particular security hole which might be exploited.
"Unfortunately, this same information is often used for other valuable purposes for which HTTP currently has no better mechanism."
"For example, a browser client could have a toggle switch for browsing openly/anonymously, which would respectively enable/disable the sending of Referer and From information."
Clients SHOULD NOT include a Referer header field in a (non-secure) HTTP request if the referring page was transferred with a secure protocol.
Accept request-headers can reveal information about the user to all servers which are accessed.
User agents which offer the option to configure the contents of an Accept-Language header to be sent in every request are strongly encouraged to let the configuration process include a message which makes the user aware of the loss of privacy involved.
"An approach that limits the loss of privacy would be for a user agent to omit the sending of Accept-Language headers by default, and to ask the user whether or not to start sending Accept-Language headers to a server if it detects, by looking for any Vary response-header fields generated by the server, that such sending could improve the quality of service."
"Elaborate user-customized accept header fields sent in every request, in particular if these include quality values, can be used by servers as relatively reliable and long-lived user identifiers."
"Note that for many users not behind a proxy, the network address of the host running the user agent will also serve as a long-lived user identifier."
"In environments where proxies are used to enhance privacy, user agents ought to be conservative in offering accept header configuration options to end users."
"As an extreme privacy measure, proxies could filter the accept headers in relayed requests."
General purpose user agents which provide a high degree of header configurability SHOULD warn users about the loss of privacy which can be involved.
Implementations of HTTP origin servers SHOULD be careful to restrict the documents returned by HTTP requests to be only those that were intended by the server administrators.
"If an HTTP server translates HTTP URIs directly into file system calls, the server MUST take special care not to serve files that were not intended to be delivered to HTTP clients."
"For example, UNIX, Microsoft Windows, and other operating systems use "".."" as a path component to indicate a directory level above the current one."
"On such a system, an HTTP server MUST disallow any such construct in the Request-URI if it would otherwise allow access to a resource outside those intended to be accessible via the HTTP server."
"Similarly, files intended for reference only internally to the server (such as access control files, configuration files, and script code) MUST be protected from inappropriate retrieval, since they might contain sensitive information."
Experience has shown that minor bugs in such HTTP server implementations have turned into security risks.
"Clients using HTTP rely heavily on the Domain Name Service, and are thus generally prone to security attacks based on the deliberate mis-association of IP addresses and DNS names."
"Many platforms already can cache host name lookups locally when appropriate, and they SHOULD be configured to do so."
"It is proper for these lookups to be cached, however, only when the TTL (Time To Live) information reported by the name server makes it likely that the cached information will remain useful."
"If HTTP clients do not observe this rule, they could be spoofed when a previously-accessed server's IP address changes."
"As network renumbering is expected to become increasingly common [24], the possibility of this form of attack will grow."
Observing this requirement thus reduces this potential security vulnerability.
This requirement also improves the load-balancing behavior of clients for replicated servers using the same DNS name and reduces the likelihood of a user's experiencing failure in accessing sites which use that strategy.
"If a single server supports multiple organizations that do not trust one another, then it MUST check the values of Location and Content- Location headers in responses that are generated under control of said organizations to make sure that they do not attempt to invalidate resources over which they have no authority."
"Content-Disposition is not part of the HTTP standard, but since it is widely implemented, we are documenting its use and risks for implementors."
Clients which have been idle for an extended period following which the server might wish to cause the client to reprompt the user for credentials.
Applications which include a session termination indication (such as a `logout' or `commit' button on a page) after which the server side of the application `knows' that there is no further reason for the client to retain the credentials.
"There are a number of work- arounds to parts of this problem, and we encourage the use of password protection in screen savers, idle time-outs, and other methods which mitigate the security problems inherent in this problem."
"In particular, user agents which cache credentials are encouraged to provide a readily accessible mechanism for discarding cached credentials under user control."
Compromise of the systems on which the proxies run can result in serious security and privacy problems.
"A compromised proxy, or a proxy implemented or configured without regard to security and privacy considerations, might be used in the commission of a wide range of potential attacks."
Proxy operators should protect the systems on which proxies run as they would protect any system that contains or transports sensitive information.
"In particular, log information gathered at proxies often contains highly sensitive personal information, and/or information about organizations."
"Log information should be carefully guarded, and appropriate guidelines for use developed and followed."
"Caching proxies provide additional potential vulnerabilities, since the contents of the cache represent an attractive target for malicious exploitation."
"Because cache contents persist after an HTTP request is complete, an attack on the cache can reveal information long after a user believes that the information has been removed from the network."
"Therefore, cache contents should be protected as sensitive information."
"Proxy implementors should consider the privacy and security implications of their design and coding decisions, and of the configuration options they provide to proxy operators (especially the default configuration)."
Users of a proxy need to be aware that they are no trustworthier than the people who run the proxy; HTTP itself cannot solve this problem.
This specification makes heavy use of the augmented BNF and generic constructs defined by David H. Crocker for RFC 822 [9].
We hope that their inclusion in this specification will help reduce past confusion over the relationship between HTTP and Internet mail message formats.
The HTTP protocol has evolved considerably over the years.
"Thanks to the ""cave men"" of Palo Alto."
"And thanks go particularly to Jeff Mogul and Scott Lawrence for performing the ""MUST/MAY/SHOULD"" audit."
"The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik Frystyk implemented RFC 2068 early, and we wish to thank them for the discovery of many of the problems that this document attempts to rectify."
"In addition to defining the HTTP/1.1 protocol, this document serves as the specification for the Internet media type ""message/http"" and ""application/http""."
"When an HTTP 206 (Partial Content) response message includes the content of multiple ranges (a response to a request for multiple non-overlapping ranges), these are transmitted as a multipart message-body."
"A number of browsers and servers were coded to an early draft of the byteranges specification to use a media type of multipart/x-byteranges, which is almost, but not quite compatible with the version documented in HTTP/1.1."
"Although this document specifies the requirements for the generation of HTTP/1.1 messages, not all applications will be correct in their implementation."
We therefore recommend that operational applications be tolerant of deviations whenever those deviations can be interpreted unambiguously.
Clients SHOULD be tolerant in parsing the Status-Line and servers tolerant when parsing the Request-Line.
The line terminator for message-header fields is the sequence CRLF.
"However, we recommend that applications, when parsing such headers, recognize a single LF as a line terminator and ignore the leading CR."
"The character set of an entity-body SHOULD be labeled as the lowest common denominator of the character codes used within that body, with the exception that not labeling the entity is preferred over labeling the entity with the labels US-ASCII or ISO-8859-1."
"An HTTP/1.1 implementation MAY internally represent a parsed Expires date as earlier than the proper value, but MUST NOT internally represent a parsed Expires date as later than the proper value."
All expiration-related calculations MUST be done in GMT.
The local time zone MUST NOT influence the calculation or comparison of an age or expiration time.
"If an HTTP header incorrectly carries a date value with a time zone other than GMT, it MUST be converted into GMT using the most conservative possible conversion."
"These differences were carefully chosen to optimize performance over binary connections, to allow greater freedom in the use of new media types, to make date comparisons easier, and to acknowledge the practice of some early HTTP servers and clients."
Proxies and gateways to strict MIME environments SHOULD be aware of these differences and provide the appropriate conversions where necessary.
HTTP is not a MIME-compliant protocol.
"However, HTTP/1.1 messages MAY include a single MIME-Version general-header field to indicate what version of the MIME protocol was used to construct the message."
Proxies/gateways are responsible for ensuring full compliance (where possible) when exporting HTTP messages to strict MIME environments.
"However, HTTP/1.1 message parsing and semantics are defined by this document and not the MIME specification."
"Section 3.7.1 of this document describes the forms allowed for subtypes of the ""text"" media type when transmitted over HTTP."
"RFC 2046 requires that content with a type of ""text"" represent line breaks as CRLF and forbids the use of CR or LF outside of line break sequences."
"HTTP allows CRLF, bare CR, and bare LF to indicate a line break within text content when a message is transmitted over HTTP."
"Where it is possible, a proxy or gateway from HTTP to a strict MIME environment SHOULD translate all line breaks within the text media types described in section 3.7.1 of this document to the RFC 2049 canonical form of CRLF."
"Note, however, that this might be complicated by the presence of a Content-Encoding and by the fact that HTTP allows the use of some character sets which do not use octets 13 and 10 to represent CR and LF, as is the case for some multi-byte character sets."
Implementors should note that conversion will break any cryptographic checksums applied to the original content unless the original content is already in canonical form.
"Therefore, the canonical form is recommended for any content that uses such checksums in HTTP."
HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC 2045.
"Proxies and gateways from MIME-compliant protocols to HTTP MUST remove any non-identity CTE (""quoted-printable"" or ""base64"") encoding prior to delivering the response message to an HTTP client."
"Proxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where ""safe transport"" is defined by the limitations of the protocol being used."
Such a proxy or gateway SHOULD label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over the destination protocol.
Proxies/gateways MUST remove any transfer-coding prior to forwarding a message via a MIME-compliant protocol.
"Since HTTP does not have this limitation, HTTP does not fold long lines."
"MHTML messages being transported by HTTP follow all conventions of MHTML, including line length limitations and folding, canonicalization, etc., since HTTP transports all message-bodies as payload (see section 3.7.2) and does not interpret the content or any MIME header lines that might be contained therein."
"RFC 1945 and RFC 2068 document protocol elements used by some existing HTTP implementations, but not consistently and correctly across most HTTP/1.1 applications."
"Some of these describe proposed experimental features, and some describe features that experimental deployment found lacking that are now addressed in the base HTTP/1.1 specification."
The Content-Disposition response-header field has been proposed as a means for the origin server to suggest a default filename if the user requests that the content is saved to a file.
"The receiving user agent SHOULD NOT respect any directory path information present in the filename-parm parameter, which is the only parameter believed to apply to HTTP implementations at this time."
The filename SHOULD be treated as a terminal component only.
"If this header is used in a response with the application/octet- stream content-type, the implied suggestion is that the user agent should not display the response, but directly enter a `save response as...' dialog."
"For most implementations of HTTP/1.0, each connection is established by the client prior to the request and closed by the server after sending the response."
"The requirements that clients and servers support the Host request- header, report an error if the Host request-header (section 14.23) is missing from an HTTP/1.1 request, and accept absolute URIs (section 5.1.2) are among the most important changes defined by this specification."
Both clients and servers MUST support the Host request-header.
Servers MUST report a 400 (Bad Request) error if an HTTP/1.1 request does not include a Host request-header.
Some clients and servers might wish to be compatible with some previous implementations of persistent connections in HTTP/1.0 clients and servers.
Persistent connections in HTTP/1.0 are explicitly negotiated as they are not the default behavior.
"HTTP/1.0 experimental implementations of persistent connections are faulty, and the new facilities in HTTP/1.1 are designed to rectify these problems."
"The problem was that some existing 1.0 clients may be sending Keep-Alive to a proxy server that doesn't understand Connection, which would then erroneously forward it to the next inbound server, which would establish the Keep-Alive connection and result in a hung HTTP/1.0 proxy waiting for the close on the response."
The result is that HTTP/1.0 clients must be prevented from using Keep-Alive when talking to proxies.
"However, talking to proxies is the most important use of persistent connections, so that prohibition is clearly unacceptable."
"Therefore, we need some other mechanism for indicating a persistent connection is desired, which is safe to use even when talking to an old proxy that ignores Connection."
This specification has been carefully audited to correct and disambiguate key word usage; RFC 2068 had many problems in respect to the conventions laid out in RFC 2119 [34].
Clarified which error code should be used for inbound server failures (e.g. DNS failures).
CREATE had a race that required an Etag be sent when a resource is first created.
"Content-Base was deleted from the specification: it was not implemented widely, and there is no simple, safe way to introduce it without a robust extension mechanism."
"Made it clear that user-agents should retry requests, not ""clients"" in general."
"Converted requirements for clients to ignore unexpected 100 (Continue) responses, and for proxies to forward 100 responses, into a general requirement for 1xx responses."
"Modified some TCP-specific language, to make it clearer that non-TCP transports are possible for HTTP."
Require that the origin server MUST NOT wait for the request body before it sends a required 100 (Continue) response.
Allow servers to defend against denial-of-service attacks and broken clients.
"The PATCH, LINK, UNLINK methods were defined but not commonly implemented in previous versions of this specification."
"The Alternates, Content-Version, Derived-From, Link, URI, Public and Content-Base header fields were defined in previous versions of this specification, but not commonly implemented."
"However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English."
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
"This document and the information contained herein is provided on an ""AS IS"" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE."
