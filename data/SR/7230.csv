sentences
HTTP is a generic interface protocol for information systems.
It is designed to hide the details of how a service is implemented by presenting a uniform interface to clients that is independent of the types of resources provided.
"Likewise, servers do not need to be aware of each client's purpose: an HTTP request can be considered in isolation rather than being associated with a specific type of client or a predetermined sequence of application steps."
HTTP is also designed for use as an intermediation protocol for translating communication to and from non-HTTP information systems.
One consequence of this flexibility is that the protocol cannot be defined in terms of what occurs behind the interface.
"The key words ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"", ""SHOULD"", ""SHOULD NOT"", ""RECOMMENDED"", ""MAY"", and ""OPTIONAL"" in this document are to be interpreted as described in [RFC2119]."
Conformance criteria and considerations regarding error handling are defined in Section 2.5.
"This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] with a list extension, defined in Section 7, that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition)."
"As a convention, ABNF rule names prefixed with ""obs-"" denote ""obsolete"" grammar rules that appear for historical reasons."
"HTTP is a stateless request/response protocol that operates by exchanging messages (Section 3) across a reliable transport- or session-layer ""connection"" (Section 6)."
"An HTTP ""server"" is a program that accepts connections in order to service HTTP requests by sending HTTP responses."
"The term ""user agent"" refers to any of the various client programs that initiate a request, including (but not limited to) browsers, spiders (web-based robots), command-line tools, custom applications, and mobile apps."
"The term ""origin server"" refers to the program that can originate authoritative responses for a given target resource."
Most HTTP communication consists of a retrieval request (GET) for a representation of some resource identified by a URI.
"A server responds to a client's request by sending one or more HTTP response messages, each beginning with a status line that includes the protocol version, a success or error code, and textual reason phrase (Section 3.1.2), possibly followed by header fields containing server information, resource metadata, and representation metadata (Section 3.2), an empty line to indicate the end of the header section, and finally a message body containing the payload body (if any, Section 3.3)."
My payload includes a trailing CRLF.
"The term ""user agent"" does not imply that there is a human user directly interacting with the software agent at the time of a request."
The implementation diversity of HTTP means that not all user agents can make interactive suggestions to their user or provide adequate warning for security or privacy concerns.
"In the few cases where this specification requires reporting of errors to the user, it is acceptable for such reporting to only be observable in an error console or log file."
"Likewise, requirements that an automated action be confirmed by the user before proceeding might be met via advance configuration choices, run-time options, or simple avoidance of the unsafe action; confirmation does not imply any specific user interface or interruption of normal processing if the user has already made that choice."
"The terms ""upstream"" and ""downstream"" are used to describe directional requirements in relation to the message flow: all messages flow from upstream to downstream."
"Some proxies are designed to apply transformations to selected messages or payloads while they are being forwarded, as described in Section 5.7.2.
A ""gateway"" (a.k.a. ""reverse proxy"") is an intermediary that acts as an origin server for the outbound connection but translates received requests and forwards them inbound to another server or servers."
"Gateways are often used to encapsulate legacy or untrusted information services, to improve server performance through ""accelerator"" caching, and to enable partitioning or load balancing of HTTP services across multiple machines."
"However, an HTTP-to-HTTP gateway that wishes to interoperate with third-party HTTP servers ought to conform to user agent requirements on the gateway's inbound connection."
"Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel might have been initiated by an HTTP request."
"There are also intermediaries that can act on lower layers of the network protocol stack, filtering or redirecting HTTP traffic without the knowledge or permission of message senders."
"Network intermediaries are indistinguishable (at a protocol level) from a man-in-the-middle attack, often introducing security flaws or interoperability problems due to mistakenly violating HTTP semantics."
"For example, an ""interception proxy"" [RFC3040] (also commonly known as a ""transparent proxy"" [RFC1919] or ""captive portal"") differs from an HTTP proxy because it is not selected by the client."
"Instead, an interception proxy filters or redirects outgoing TCP port 80 packets (and occasionally other common port traffic)."
"Interception proxies are commonly found on public network access points, as a means of enforcing account subscription prior to allowing use of non-local Internet services, and within corporate firewalls to enforce network usage policies."
"Hence, a server MUST NOT assume that two requests on the same connection are from the same user agent unless the connection is secured and specific to that agent."
"Some non-standard HTTP extensions (e.g., [RFC4559]) have been known to violate this requirement, resulting in security and interoperability problems."
"A ""cache"" is a local store of previous response messages and the subsystem that controls its message storage, retrieval, and deletion."
"A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests."
"Any client or server MAY employ a cache, though a cache cannot be used by a server while it is acting as a tunnel."
The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request.
The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request that has not been cached by UA or A.
"A response is ""cacheable"" if a cache is allowed to store a copy of the response message for use in answering subsequent requests."
"Even when a response is cacheable, there might be additional constraints placed by the client or by the origin server on when that cached response can be used for a particular request."
There is a wide variety of architectures and configurations of caches deployed across the World Wide Web and inside large organizations.
"The verb ""generate"" is used instead of ""send"" where a requirement differentiates between creating a protocol element and merely forwarding a received element downstream."
An implementation is considered conformant if it complies with all of the requirements associated with the roles it partakes in HTTP.
A sender MUST NOT generate protocol elements that convey a meaning that is known by that sender to be false.
A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.
"Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message)."
"Note, however, that some received protocol elements might not be parsed."
"HTTP does not have specific length limitations for many of its protocol elements because the lengths that might be appropriate will vary widely, depending on the deployment context and purpose of the implementation."
"Hence, interoperability between senders and recipients depends on shared expectations regarding what is a reasonable length for each protocol element."
"Furthermore, what is commonly understood to be a reasonable length for some protocol elements has changed over the course of the past two decades of HTTP use and is expected to continue changing in the future."
"At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages."
"A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics."
"For example, an origin server might disregard the contents of a received Accept-Encoding header field if inspection of the User-Agent header field indicates a specific implementation version that is known to fail on receipt of certain content codings."
"Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct."
"HTTP does not define specific error handling mechanisms except when they have a direct impact on security, since different applications of the protocol require different error handling strategies."
"For example, a Web browser might wish to transparently recover from a response where the Location header field doesn't parse according to the ABNF, whereas a systems control client might consider any form of error recovery to be dangerous."
"HTTP uses a ""<major>.<minor>"" numbering scheme to indicate versions of the protocol."
The version of an HTTP message is indicated by an HTTP-version field in the first line of the message.
"The HTTP version number consists of two decimal digits separated by a ""."" (period or decimal point)."
"The first digit (""major version"") indicates the HTTP messaging syntax, whereas the second digit (""minor version"") indicates the highest minor version within that major version to which the sender is conformant and able to understand for future communication."
"The minor version advertises the sender's communication capabilities even when the sender is only using a backwards-compatible subset of the protocol, thereby letting the recipient know that more advanced features can be used in response (by servers) or in future requests (by clients)."
"When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [RFC1945] or a recipient whose version is unknown, the HTTP/1.1 message is constructed such that it can be interpreted as a valid HTTP/1.0 message if all of the newer features are ignored."
"The interpretation of a header field does not change between minor versions of the same major HTTP version, though the default behavior of a recipient in the absence of such a field can change."
New header fields can be introduced without changing the protocol version if their defined semantics allow them to be safely ignored by recipients that do not recognize them.
"In other words, they are not allowed to blindly forward the first line of an HTTP message without ensuring that the protocol version in that message matches a version to which that intermediary is conformant for both the receiving and sending of messages."
Forwarding an HTTP message without rewriting the HTTP-version might result in communication errors when downstream recipients use the message sender's version to determine what features are safe to use for later communication with that sender.
"A client SHOULD send a request version equal to the highest version to which the client is conformant and whose major version is no higher than the highest version supported by the server, if this is known."
A client MUST NOT send a version to which it is not conformant.
"A client MAY send a lower request version if it is known that the server incorrectly implements the HTTP specification, but only after the client has attempted at least one normal request and determined from the response status code or header fields (e.g., Server) that the server improperly handles higher request versions."
A server SHOULD send a response version equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request.
A server MUST NOT send a version to which it is not conformant.
"A server can send a 505 (HTTP Version Not Supported) response if it wishes, for any reason, to refuse service of the client's major protocol version."
"A server MAY send an HTTP/1.0 response to a request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol."
"Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error."
"The intention of HTTP's versioning design is that the major number will only be incremented if an incompatible message syntax is introduced, and that the minor number will only be incremented when changes made to the protocol have the effect of adding to the message semantics or implying additional capabilities of the sender."
"However, the minor version was not incremented for the changes introduced between [RFC2068] and [RFC2616], and this revision has specifically avoided any such changes to the protocol."
"When an HTTP message is received with a major version number that the recipient implements, but a higher minor version number than what the recipient implements, the recipient SHOULD process the message as if it were in the highest minor version within that major version to which the recipient is conformant."
"A recipient can assume that a message with a higher minor version, when sent to a recipient that has not yet indicated support for that higher version, is sufficiently backwards-compatible to be safely processed by any implementation of the same major version."
"The definitions of ""URI-reference"", ""absolute-URI"", ""relative-part"", ""scheme"", ""authority"", ""port"", ""host"", ""path-abempty"", ""segment"", ""query"", and ""fragment"" are adopted from the URI generic syntax."
"An ""absolute-path"" rule is defined for protocol elements that can contain a non-empty path component."
"(This rule differs slightly from the path-abempty rule of RFC 3986, which allows for an empty path to be used in references, and path-absolute rule, which does not allow paths that begin with ""//"".)"
"A ""partial-URI"" rule is defined for protocol elements that can contain a relative URI but not a fragment component."
"A sender MUST NOT generate an ""http"" URI with an empty host identifier."
A recipient that processes such a URI reference MUST reject it as invalid.
"If the port subcomponent is empty or not given, TCP port 80 (the reserved port for WWW services) is the default."
Note that the presence of a URI with a given authority component does not imply that there is always an HTTP server listening for connections on that host and port.
"Although HTTP is independent of the transport protocol, the ""http"" scheme is specific to TCP-based services because the name delegation process depends on TCP for establishing authority."
"An HTTP service based on some other underlying connection protocol would presumably be identified using a different URI scheme, just as the ""https"" scheme (below) is used for resources that require an end-to-end secured connection."
"The URI generic syntax for authority also includes a deprecated userinfo subcomponent ([RFC3986], Section 3.2.1) for including user authentication information in the URI."
"A sender MUST NOT generate the userinfo subcomponent (and its ""@"" delimiter) when an ""http"" URI reference is generated within a message as a request target or header field value."
"Before making use of an ""http"" URI reference received from an untrusted source, a recipient SHOULD parse for userinfo and treat its presence as an error; it is likely being used to obscure the authority for the sake of phishing attacks."
"All of the requirements listed above for the ""http"" scheme are also requirements for the ""https"" scheme, except that TCP port 443 is the default if the port subcomponent is empty or not given, and the user agent MUST ensure that its connection to the origin server is secured through the use of strong encryption, end-to-end, prior to sending the first HTTP request."
"Resources made available via the ""https"" scheme have no shared identity with the ""http"" scheme even if their resource identifiers indicate the same authority (the same host listening to the same TCP port)."
"Since the ""http"" and ""https"" schemes conform to the URI generic syntax, such URIs are normalized and compared according to the algorithm defined in Section 6 of [RFC3986], using the defaults described above for each scheme."
"When not being used in absolute form as the request target of an OPTIONS request, an empty path component is equivalent to an absolute path of ""/"", so the normal form is to provide a path of ""/"" instead."
The scheme and host are case-insensitive and normally provided in lowercase; all other components are compared in a case-sensitive manner.
"Characters other than those in the ""reserved"" set are equivalent to their percent-encoded octets: the normal form is to not encode them (see Sections 2.1 and 2.2 of [RFC3986])."
"All HTTP/1.1 messages consist of a start-line followed by a sequence of octets in a format similar to the Internet Message Format [RFC5322]: zero or more header fields (collectively referred to as the ""headers"" or the ""header section""), an empty line indicating the end of the header section, and an optional message body."
"String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field-value after message parsing has delineated the individual fields."
"However, recipients cannot rely on incremental delivery of partial messages, since some implementations will buffer or delay message forwarding for the sake of network efficiency, security checks, or payload transformations."
A sender MUST NOT send whitespace between the start-line and the first header field.
"A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated)."
"The presence of such whitespace in a request might be an attempt to trick a server into ignoring that field or processing the line after it as a new request, either of which might result in a security vulnerability if other implementations within the request chain interpret the same message differently."
"Likewise, the presence of such whitespace in a response might be ignored by some clients or cause others to cease parsing."
"In theory, a client could receive requests and a server could receive responses, distinguishing them by their different start-line formats, but, in practice, servers are implemented to only expect a request (a response is interpreted as an unknown or invalid request method) and clients are implemented to only expect a response."
"A request-line begins with a method token, followed by a single space (SP), the request-target, another single space (SP), the protocol version, and ends with CRLF."
"Recipients typically parse the request-line into its component parts by splitting on whitespace (see Section 3.5), since no whitespace is allowed in the three components."
"Unfortunately, some user agents fail to properly encode or exclude whitespace found in hypertext references, resulting in those disallowed characters being sent in a request-target."
Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded.
"A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain."
"HTTP does not place a predefined limit on the length of a request-line, as described in Section 2.5."
A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code.
"The first line of a response message is the status-line, consisting of the protocol version, a space (SP), the status code, another space, a possibly empty textual phrase describing the status code, and ending with CRLF."
A client SHOULD ignore the reason-phrase content.
"Header fields are fully extensible: there is no limit on the introduction of new field names, each presumably defining new semantics, nor on the number of header fields used in a given message."
"A proxy MUST forward unrecognized header fields unless the field-name is listed in the Connection header field (Section 6.1) or the proxy is specifically configured to block, or otherwise transform, such fields."
The order in which header fields with differing field names are received is not significant.
"However, it is good practice to send header fields that contain control data first, such as Host on requests and Date on responses, so that implementations can decide when not to handle a message as early as possible."
"A server MUST NOT apply a request to the target resource until the entire request header section is received, since later header fields might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that would impact request processing."
"A sender MUST NOT generate multiple header fields with the same field name in a message unless either the entire field value for that header field is defined as a comma-separated list [i.e., #(values)] or the header field is a well-known exception (as noted below)."
"A recipient MAY combine multiple header fields with the same field name into one ""field-name: field-value"" pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma."
The order in which header fields with the same field name are received is therefore significant to the interpretation of the combined field value; a proxy MUST NOT change the order of these field values when forwarding a message.
"This specification uses three rules to denote the use of linear whitespace: OWS (optional whitespace), RWS (required whitespace), and BWS (""bad"" whitespace)."
"For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to white out invalid or unwanted protocol elements during in-place message filtering."
"Messages are parsed using a generic algorithm, independent of the individual header field names."
The contents within a given field value are not parsed until a later stage of message interpretation (usually after the message's entire header section has been processed).
"Consequently, this specification does not use ABNF rules to define each ""Field-Name: Field Value"" pair, as was done in previous editions."
"Instead, this specification uses ABNF rules that are named according to each registered field name, wherein the rule defines the valid grammar for that field's corresponding field values (i.e., after the field-value has been extracted from the header section by a generic field parser)."
No whitespace is allowed between the header field-name and colon.
"In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling."
A server MUST reject any received request message that contains whitespace between a header field-name and colon with a response code of 400 (Bad Request).
A proxy MUST remove any such whitespace from a response message before forwarding the message downstream.
A field value might be preceded and/or followed by optional whitespace (OWS); a single SP preceding the field-value is preferred for consistent readability by humans.
The field value does not include any leading or trailing whitespace: OWS occurring before the first non-whitespace octet of the field value or after the last non-whitespace octet of the field value ought to be excluded by parsers when extracting the field value from a header field.
"A sender MUST NOT generate a message that includes line folding (i.e., that has any field-value that contains a match to the obs-fold rule) unless the message is intended for packaging within the message/http media type."
"A server that receives an obs-fold in a request message that is not within a message/http container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream."
"A proxy or gateway that receives an obs-fold in a response message that is not within a message/http container MUST either discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream."
A user agent that receives an obs-fold in a response message that is not within a message/http container MUST replace each received obs-fold with one or more SP octets prior to interpreting the field value.
"HTTP does not place a predefined limit on the length of each header field or on the length of the header section as a whole, as described in Section 2.5."
"Various ad hoc limitations on individual header field length are found in practice, often depending on the specific field semantics."
Ignoring such header fields would increase the server's vulnerability to request smuggling attacks (Section 9.5).
A client MAY discard or truncate received header fields that are larger than the client wishes to process if the field semantics are such that the dropped value(s) can be safely ignored without changing the message framing or response semantics.
"Delimiters are chosen from the set of US-ASCII visual characters not allowed in a token (DQUOTE and ""(),/:;<=>?@[\]{}"")."
A string of text is parsed as a single value if it is quoted using double-quote marks.
Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.
A sender SHOULD NOT generate a quoted-pair in a quoted-string except where necessary to quote DQUOTE and backslash octets occurring within that string.
"A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses [""("" and "")""] and backslash octets occurring within that comment."
The presence of a message body in a request is signaled by a Content-Length or Transfer-Encoding header field.
"Request message framing is independent of method semantics, even if the method does not define any use for a message body."
"Responses to the HEAD request method (Section 4.3.2 of [RFC7231]) never include a message body because the associated response header fields (e.g., Transfer-Encoding, Content-Length, etc.), if present, indicate only what their values would have been if the request method had been GET (Section 4.3.1 of [RFC7231])."
"All 1xx (Informational), 204 (No Content), and 304 (Not Modified) responses do not include a message body."
"Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6)."
"However, safe transport has a different focus for an 8bit-clean transfer protocol."
A recipient MUST be able to parse the chunked transfer coding (Section 4.1) because it plays a crucial role in framing messages when the payload body size is not known in advance.
"A sender MUST NOT apply chunked more than once to a message body (i.e., chunking an already chunked message is not allowed)."
"If any transfer coding other than chunked is applied to a request payload body, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed."
"If any transfer coding other than chunked is applied to a response payload body, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection."
indicates that the payload body has been compressed using the gzip coding and then chunked using the chunked coding while forming the message body.
"Unlike Content-Encoding (Section 3.1.2.1 of [RFC7231]), Transfer-Encoding is a property of the message, not of the representation, and any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field-value."
Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
"Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 4.1 of [RFC7232]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET."
"This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed."
A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content).
A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of [RFC7231]).
It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process a transfer-encoded payload.
A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 (or later) requests; such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.
A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later).
A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).
"When a message does not have a Transfer-Encoding header field, a Content-Length header field can provide the anticipated size, as a decimal number of octets, for a potential payload body."
"For messages that do not include a payload body, the Content-Length indicates the size of the selected representation (Section 3 of [RFC7231])."
A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.
A user agent SHOULD send a Content-Length in a request message when no Transfer-Encoding is sent and the request method defines a meaning for an enclosed payload body.
"For example, a Content-Length header field is normally sent in a POST request even when the value is 0 (indicating an empty payload body)."
A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body.
A server MAY send a Content-Length header field in a response to a HEAD request (Section 4.3.2 of [RFC7231]); a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload body of a response if the same request had used the GET method.
A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 4.1 of [RFC7232]); a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload body of a 200 (OK) response to the same request.
A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content).
A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of [RFC7231]).
"Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the payload body size is known prior to sending the complete header section."
"Since there is no predefined limit to the length of a payload, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows (Section 9.3)."
"Any response to a HEAD request and any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body."
Any 2xx (Successful) response to a CONNECT request implies that the connection will become a tunnel immediately after the empty line that concludes the header fields.
"If a Transfer-Encoding header field is present and the chunked transfer coding (Section 4.1) is the final encoding, the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete."
"If a Transfer-Encoding header field is present in a response and the chunked transfer coding is not the final encoding, the message body length is determined by reading the connection until it is closed by the server."
"If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection."
"If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length."
Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error.
A sender MUST remove the received Content-Length field prior to forwarding such a message downstream.
"If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error."
"If this is a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection."
"If this is a response message received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client."
"If this is a response message received by a user agent, the user agent MUST close the connection to the server and discard the received response."
"If this is a request message and none of the above are true, then the message body length is zero (no message body is present)."
"Since there is no way to distinguish a successfully completed, close-delimited message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible."
A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).
"Unless a transfer coding other than chunked has been applied, a client that sends a request containing a message body SHOULD use a valid Content-Length header field if the message body length is known in advance, rather than the chunked transfer coding, since some existing services respond to chunked with a 411 (Length Required) status code even though they understand the chunked transfer coding."
This is typically because such services are implemented via a gateway that requires a content-length in advance of being called and the server is unable or unwilling to buffer the entire request before processing.
A user agent that sends a request containing a message body MUST send a valid Content-Length header field if it does not know the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response.
"If the final response to the last request on a connection has been completely received and there remains additional data to read, a user agent MAY discard the remaining data or attempt to determine if that data belongs as part of the prior response body, which might be the case if the prior message's Content-Length value is incorrect."
"A client MUST NOT process, cache, or forward such extra data as a separate response, since such behavior would be vulnerable to cache poisoning."
"A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection."
"A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete."
"If a response terminates in the middle of the header section (before the empty line is received) and the status code might rely on header fields to convey the full meaning of the response, then the client cannot assume that meaning has been conveyed; the client might need to repeat the request in order to determine what action to take next."
A message body that uses the chunked transfer coding is incomplete if the zero-sized chunk that terminates the encoding has not been received.
A message that uses a valid Content-Length is incomplete if the size of the message body received (in octets) is less than the value given by Content-Length.
"A response that has neither chunked transfer coding nor Content-Length is terminated by closure of the connection and, thus, is considered complete regardless of the number of message body octets received, provided that the header section was received intact."
Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending.
An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF.
"If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length."
"In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line."
"Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR."
"Although the request-line and status-line grammar rules require that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR."
"When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response."
"Transfer coding names are used to indicate an encoding transformation that has been, can be, or might need to be applied to a payload body in order to ensure ""safe transport"" through the network."
This differs from a content coding in that the transfer coding is a property of the message rather than a property of the representation that is being transferred.
"All transfer-coding names are case-insensitive and ought to be registered within the HTTP Transfer Coding registry, as defined in Section 8.4."
"Chunked enables content streams of unknown size to be transferred as a sequence of length-delimited buffers, which enables the sender to retain connection persistence and the recipient to know when it has received the entire message."
The chunk-size field is a string of hex digits indicating the size of the chunk-data in octets.
"The chunked transfer coding is complete when a chunk with a chunk-size of zero is received, possibly followed by a trailer, and finally terminated by an empty line."
"The chunked encoding allows each chunk to include zero or more chunk extensions, immediately following the chunk-size, for the sake of supplying per-chunk metadata (such as a signature or hash), mid-message control information, or randomization of message body size."
The chunked encoding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions.
"Hence, use of chunk extensions is generally limited to specialized HTTP services such as ""long polling"" (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection."
"A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded."
"The trailer fields are identical to header fields, except they are sent in a chunked trailer instead of the message's header section."
"A sender MUST NOT generate a trailer that contains a field necessary for message framing (e.g., Transfer-Encoding and Content-Length), routing (e.g., Host), request modifiers (e.g., controls and conditionals in Section 5 of [RFC7231]), authentication (e.g., see [RFC7235] and [RFC6265]), response control data (e.g., see Section 7.1 of [RFC7231]), or determining how to process the payload (e.g., Content-Encoding, Content-Type, Content-Range, and Trailer)."
"When a chunked message containing a non-empty trailer is received, the recipient MAY process the fields (aside from those forbidden above) as if they were appended to the message's header section."
"A recipient MUST ignore (or consider as an error) any fields that are forbidden to be sent in a trailer, since processing them as if they were present in the header section might bypass external security filters."
"Unless the request includes a TE header field indicating ""trailers"" is acceptable, as described in Section 4.3, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive."
"Without a TE containing ""trailers"", the server ought to assume that the trailer fields might be silently discarded along the path to the user agent."
This requirement allows intermediaries to forward a de-chunked message to an HTTP/1.0 recipient without buffering the entire response.
"A recipient SHOULD consider ""x-compress"" to be equivalent to ""compress""."
"The ""deflate"" coding is a ""zlib"" data format [RFC1950] containing a ""deflate"" compressed data stream [RFC1951] that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and Huffman coding."
"Note: Some non-conformant implementations send the ""deflate"" compressed data without the zlib wrapper."
"The ""gzip"" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check (CRC) that is commonly produced by the gzip file compression program [RFC1952]."
"A recipient SHOULD consider ""x-gzip"" to be equivalent to ""gzip""."
"The ""TE"" header field in a request indicates what transfer codings, besides chunked, the client is willing to accept in response, and whether or not the client is willing to accept trailer fields in a chunked transfer coding."
A client MUST NOT send the chunked transfer coding name in TE; chunked is always acceptable for HTTP/1.1 recipients.
"The presence of the keyword ""trailers"" indicates that the client is willing to accept trailer fields in a chunked transfer coding, as defined in Section 4.1.2, on behalf of itself and any downstream clients."
Note that HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response.
"When multiple transfer codings are acceptable, the client MAY rank the codings by preference using a case-insensitive ""q"" parameter (similar to the qvalues used in content negotiation fields, Section 5.3.1 of [RFC7231])."
"The rank value is a real number in the range 0 through 1, where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means ""not acceptable""."
"If the TE field-value is empty or if no TE field is present, the only acceptable transfer coding is chunked."
A message with no transfer coding is always acceptable.
"Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a ""TE"" connection option within the Connection header field (Section 6.1) in order to prevent the TE field from being forwarded by intermediaries that do not support its semantics."
"When a message includes a message body encoded with the chunked transfer coding and the sender desires to send metadata in the form of trailer fields at the end of the message, the sender SHOULD generate a Trailer header field before the message body to indicate which fields will be present in the trailers."
"This allows the recipient to prepare for receipt of that metadata before it starts processing the body, which is useful if the message is being streamed and the recipient wishes to confirm an integrity check on the fly."
"However, most HTTP clients rely on the same resource identification mechanism and configuration techniques as general-purpose Web browsers."
"A URI reference (Section 2.7) is typically used as an identifier for the ""target resource"", which a user agent would resolve to its absolute form in order to obtain the ""target URI""."
"If the request is not satisfied by a cache, then a typical client will check its configuration to determine whether a proxy is to be used to satisfy the request."
"If the target URI's path component is empty, the client MUST send ""/"" as the path within the origin-form of request-target."
"Requirements on such ""forwarding"" of messages are defined in Section 5.7.
GET http://www.example.org/pub/WWW/TheProject.html"
"If a proxy receives an OPTIONS request with an absolute-form of request-target in which the URI has an empty path and no query component, then the last proxy on the request chain MUST send a request-target of ""*"" when it forwards the request to the indicated origin server."
"If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field-value."
"Since the Host field-value is critical information for handling a request, a user agent SHOULD generate Host as the first header field following the request-line."
"When a proxy receives a request with an absolute-form of request-target, the proxy MUST ignore the received Host header field (if any) and instead replace it with the host information of the request-target."
A proxy that forwards such a request MUST generate a new Host field-value based on the received request-target rather than forward the received Host field-value.
"Since the Host header field acts as an application-level routing mechanism, it is a frequent target for malware seeking to poison a shared cache or redirect a request to an unintended server."
"An interception proxy is particularly vulnerable if it relies on the Host field-value for redirecting requests to internal servers, or for use as a cache key in a shared cache, without first verifying that the intercepted connection is targeting a valid IP address for that host."
A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field or a Host header field with an invalid field-value.
"Since the request-target often contains only part of the user agent's target URI, a server reconstructs the intended target as an ""effective request URI"" to properly service the request."
"Otherwise, if the request is received over a TLS-secured TCP connection, the effective request URI's scheme is ""https""; if not, the scheme is ""http""."
"If not, then if a Host header field is supplied with a non-empty field-value, the authority component is the same as the Host field-value."
"Otherwise, the authority component is assigned the default name configured for the server and, if the connection's incoming TCP port number differs from the default port for the effective request URI's scheme, then a colon ("":"") and the incoming port number (in decimal form) are appended to the authority component."
"If the request-target is in authority-form or asterisk-form, the effective request URI's combined path and query component is empty."
"Recipients of an HTTP/1.0 request that lacks a Host header field might need to use heuristics (e.g., examination of the URI path for something unique to a particular host) in order to guess the effective request URI's authority component."
"Once the effective request URI has been constructed, an origin server needs to decide whether or not to provide service for that URI via the connection in which the request was received."
"For example, the request might have been misdirected, deliberately or accidentally, such that the information within a received request-target or Host header field differs from the host or port upon which the connection has been made."
HTTP does not include a request identifier for associating a given request message with its corresponding one or more response messages.
A client that has more than one outstanding request on a connection MUST maintain a list of outstanding requests in the order sent and MUST associate each received response message on that connection to the highest ordered request that has not yet received a final (non-1xx) response.
"Since an HTTP stream has characteristics similar to a pipe-and-filter architecture, there are no inherent limits to the extent an intermediary can enhance (or interfere) with either direction of the stream."
"An intermediary not acting as a tunnel MUST implement the Connection header field, as specified in Section 6.1, and exclude fields from being forwarded that are only intended for the incoming connection."
An intermediary MUST NOT forward a message to itself unless it is protected from an infinite request loop.
An HTTP-to-HTTP gateway MUST send an appropriate Via header field in each inbound request message and MAY send a Via header field in forwarded response messages.
"For brevity, the protocol-name is omitted when the received protocol is HTTP."
"If a port is not provided, a recipient MAY interpret that as meaning it was received on the default TCP port, if any, for the received-protocol."
A sender SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms.
A sender MUST NOT combine entries that have different received-protocol values.
"A proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link."
"However, operational problems might occur when these transformations are applied to payloads intended for critical applications, such as medical imaging or scientific data analysis, particularly when integrity checks or digital signatures are used to ensure that the payload received is identical to the original."
"For example, a transforming proxy might be acting as a shared annotation server (modifying responses to include references to a local annotation database), a malware filter, a format transcoder, or a privacy filter."
A proxy MUST NOT transform the payload (Section 3.3 of [RFC7231]) of a message that contains a no-transform cache-control directive (Section 5.2 of [RFC7234]).
A proxy MAY transform the payload of a message that does not contain a no-transform cache-control directive.
"A proxy SHOULD NOT modify header fields that provide information about the endpoints of the communication chain, the resource state, or the selected representation (other than the payload) unless the field's definition specifically allows such modification or the modification is deemed necessary for privacy or security."
HTTP only presumes a reliable transport with in-order delivery of requests and the corresponding in-order delivery of responses.
"For example, the ""http"" URI scheme (Section 2.7.1) indicates a default connection of TCP over IP, with a default TCP port of 80, but the client might be configured to use a proxy via some other connection, port, or protocol."
"HTTP implementations are expected to engage in connection management, which includes maintaining the state of current connections, establishing a new connection or reusing an existing connection, processing messages received on a connection, detecting connection failures, and closing each connection."
"Most servers are designed to maintain thousands of concurrent connections, while controlling request queues to enable fair use and detect denial-of-service attacks."
"In order to avoid confusing downstream recipients, a proxy or gateway MUST remove or replace any received connection options before forwarding the message."
Connection options are case-insensitive.
A sender MUST NOT send a connection option corresponding to a header field that is intended for all recipients of the payload.
"For example, Cache-Control is never appropriate as a connection option (Section 5.2 of [RFC7234])."
"The connection options do not always correspond to a header field present in the message, since a connection-specific header field might not be needed if there are no parameters associated with a connection option."
"In contrast, a connection-specific header field that is received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient."
"When defining new connection options, specification authors ought to survey existing header field names and ensure that the new connection option does not share the same name as an already deployed header field."
"Defining a new connection option essentially reserves that potential field-name for carrying additional information related to the connection option, since it would be unwise for senders to use that field-name for anything else."
in either the request or the response header fields indicates that the sender is going to close the connection after the current request/response is complete (Section 6.6).
"A client that does not support persistent connections MUST send the ""close"" connection option in every request message."
"A server that does not support persistent connections MUST send the ""close"" connection option in every response message that does not have a 1xx (Informational) status code."
"In order to remain persistent, all messages on a connection need to have a self-defined message length (i.e., one not defined by closure of the connection), as described in Section 3.3."
"A server MUST read the entire request message body or close the connection after sending its response, since otherwise the remaining data on a persistent connection would be misinterpreted as the next request."
A proxy server MUST NOT maintain a persistent connection with an HTTP/1.0 client (see Section 19.7.1 of [RFC2068] for information and discussion of the problems with the Keep-Alive header field implemented by many HTTP/1.0 clients).
"When an inbound connection is closed prematurely, a client MAY open a new connection and automatically retransmit an aborted sequence of requests if all of those requests have idempotent methods (Section 4.2.2 of [RFC7231])."
A proxy MUST NOT automatically retry non-idempotent requests.
"A user agent MUST NOT automatically retry a request with a non- idempotent method unless it has some means to know that the request semantics are actually idempotent, regardless of the method, or some means to detect that the original request was never applied."
"Likewise, a user agent designed specifically to operate on a version control repository might be able to recover from partial failure conditions by checking the target resource revision(s) after a failed connection, reverting or fixing any changes that were partially applied, and then automatically retrying the requests that failed."
A client SHOULD NOT automatically retry a failed automatic retry.
A client that pipelines requests SHOULD retry unanswered requests if the connection closes before it receives all of the corresponding responses.
"When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 6.6)."
Idempotent methods (Section 4.2.2 of [RFC7231]) are significant to pipelining because they can be automatically retried after a connection failure.
"A user agent SHOULD NOT pipeline requests after a non-idempotent method, until the final response status code for that method has been received, unless the user agent has a means to detect and recover from partial failure conditions involving the pipelined sequence."
"If the inbound connection fails before receiving a response, the pipelining intermediary MAY attempt to retry a sequence of requests that have yet to receive a response if the requests all have idempotent methods; otherwise, the pipelining intermediary SHOULD forward any received responses and then close the corresponding outbound connection(s) so that the outbound user agent(s) can recover accordingly."
"Previous revisions of HTTP gave a specific number of connections as a ceiling, but this was found to be impractical for many applications."
"As a result, this specification does not mandate a particular maximum number of connections but, instead, encourages clients to be conservative when opening multiple connections."
"Multiple connections are typically used to avoid the ""head-of-line blocking"" problem, wherein a request that takes significant server-side processing and/or has a large payload blocks subsequent requests on the same connection."
"Furthermore, using multiple connections can cause undesirable side effects in congested networks."
"Note that a server might reject traffic that it deems abusive or characteristic of a denial-of-service attack, such as an excessive number of open connections from a single client."
Servers will usually have some timeout value beyond which they will no longer maintain an inactive connection.
The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.
A client or server that wishes to time out SHOULD issue a graceful close on the connection.
"For example, a client might have started to send a new request at the same time that the server has decided to close the ""idle"" connection."
"From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress."
"A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads, rather than terminate connections with the expectation that clients will retry."
The latter technique can exacerbate network congestion.
A client sending a message body SHOULD monitor the network connection for an error response while it is transmitting the request.
"If the client sees a response that indicates the server does not wish to receive the message body and is closing the connection, the client SHOULD immediately cease transmitting the body and close its side of the connection."
"A client that sends a ""close"" connection option MUST NOT send further requests on that connection (after the one containing ""close"") and MUST close the connection after reading the final response message corresponding to this request."
The server MUST NOT process any further requests received on that connection.
"A server that sends a ""close"" connection option MUST initiate a close of the connection (see below) after it sends the response containing ""close""."
The server MUST NOT process any further requests received on that connection.
"A client that receives a ""close"" connection option MUST cease sending requests on that connection and close the connection after reading the response message containing the ""close""; if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server."
"If a server performs an immediate close of a TCP connection, there is a significant risk that the client will not be able to read the last HTTP response."
"If the server receives additional data from the client on a fully closed connection, such as another request that was sent by the client before receiving the server's response, the server's TCP stack will send a reset packet to the client; unfortunately, the reset packet might erase the client's unacknowledged input buffers before they can be read and interpreted by the client's HTTP parser."
"To avoid the TCP reset problem, servers typically close a connection in stages."
"The server then continues to read from the connection until it receives a corresponding close by the client, or until the server is reasonably certain that its own TCP stack has received the client's acknowledgement of the packet(s) containing the server's last response."
It is unknown whether the reset problem is exclusive to TCP or might also be found in other transport connection protocols.
A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection.
A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.
"However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated)."
"When Upgrade is sent, the sender MUST also send a Connection header field (Section 6.1) that contains an ""upgrade"" connection option, in order to prevent Upgrade from being accidentally forwarded by intermediaries that might not implement the listed protocols."
A server MUST ignore an Upgrade header field that is received in an HTTP/1.0 request.
"A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message)."
"HTTP header fields are registered within the ""Message Headers"" registry maintained at <http://www.iana.org/assignments/message-headers/>."
"This document defines the following URI schemes, so the ""Permanent URI Schemes"" registry has been updated accordingly."
"This document serves as the specification for the Internet media types ""message/http"" and ""application/http""."
"Encoding considerations:  HTTP messages enclosed by this type are in ""binary"" format; use of an appropriate Content-Transfer-Encoding is required when transmitted via email."
"Names of transfer codings MUST NOT overlap with names of content codings (Section 3.1.2.1 of [RFC7231]) unless the encoding transformation is identical, as is the case for the compression codings defined in Section 4.2."
Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.
"IANA maintains the ""HTTP Content Coding Registry"" at <http://www.iana.org/assignments/http-parameters>."
The registry is maintained at <http://www.iana.org/assignments/http-upgrade-tokens>.
"Unfortunately, establishing authority can be difficult."
"For example, phishing is an attack on the user's perception of authority, where that perception can be misled by presenting similar branding in hypertext, possibly aided by userinfo obfuscating the authority component (see Section 2.7.1)."
"When a registered name is used in the authority component, the ""http"" URI scheme (Section 2.7.1) relies on the user's local name resolution service to determine where it can find authoritative responses."
"This means that any attack on a user's network host table, cached names, or name resolution libraries becomes an avenue for attack on establishing authority."
"Furthermore, after an IP address is obtained, establishing authority for an ""http"" URI is vulnerable to attacks on Internet Protocol routing."
Users need to be aware that intermediaries are no more trustworthy than the people who run them; HTTP itself cannot solve this problem.
"Because HTTP uses mostly textual, character-delimited fields, parsers are often vulnerable to attacks based on sending very long (or very slow) streams of data, particularly where an implementation is expecting a protocol element with no predefined length."
"These are minimum recommendations, chosen to be supportable even by implementations with limited resources; it is expected that most implementations will choose substantially higher limits."
A server can reject a message that has a request-target that is too long (Section 6.5.12 of [RFC7231])
"Recipients ought to carefully limit the extent to which they process other protocol elements, including (but not limited to) request methods, response status phrases, header field-names, numeric values, and body chunks."
"Failure to limit such processing can result in buffer overflows, arithmetic overflows, or increased vulnerability to denial-of-service attacks."
"Response splitting (a.k.a, CRLF injection) is a common technique, used in various attacks on Web usage, that exploits the line-based nature of HTTP message framing and the ordered association of requests to responses on persistent connections [Klein]."
This technique can be particularly damaging when the requests pass through a shared cache.
Response splitting exploits a vulnerability in servers (usually within an application server) where an attacker can send encoded data within some parameter of the request that is later decoded and echoed within any of the response header fields of the response.
"If the decoded data is crafted to look like the response has ended and a subsequent response has begun, the response has been split and the content within the apparent second response is controlled by the attacker."
The attacker can then make any other request on the same persistent connection and trick the recipients (including intermediaries) into believing that the second half of the split is an authoritative answer to the second request.
"For example, a parameter within the request-target might be read by an application server and reused within a redirect, resulting in the same parameter being echoed in the Location header field of the response."
"If the parameter is decoded by the application and not properly encoded when placed in the response field, the attacker can send encoded CRLF octets and other content that will make the application's single response look like two or more responses."
"A common defense against response splitting is to filter requests for data that looks like encoded CR and LF (e.g., ""%0D"" and ""%0A"")."
"However, that assumes the application server is only performing URI decoding, rather than more obscure data transformations like charset transcoding, XML entity translation, base64 decoding, sprintf reformatting, etc."
"A more effective mitigation is to prevent anything other than the server's core protocol libraries from sending a CR or LF within the header section, which means restricting the output of header fields to APIs that filter for bad octets and not allowing application servers to write directly to the protocol stream."
Request smuggling ([Linhart]) is a technique that exploits differences in protocol parsing among various recipients to hide additional requests (which might otherwise be blocked or disabled by policy) within an apparently harmless request.
"HTTP does not define a specific mechanism for ensuring message integrity, instead relying on the error-detection ability of underlying transport protocols and the use of length or chunk-delimited framing to detect completeness."
"Historically, the lack of a single integrity mechanism has been justified by the informal nature of most HTTP communication."
"However, the prevalence of HTTP as an information access mechanism has resulted in its increasing use within environments where verification of message integrity is crucial."
User agents are encouraged to implement configurable means for detecting and reporting failures of message integrity such that those means can be enabled within environments for which integrity is necessary.
"For example, a browser being used to view medical history or drug interaction information needs to indicate to the user when such information is detected by the protocol to be incomplete, expired, or corrupted during transfer."
Such mechanisms might be selectively enabled via user agent extensions or the presence of message integrity metadata in a response.
"At a minimum, user agents ought to provide some indication that allows a user to distinguish between a complete and incomplete response message (Section 3.4) when such verification is desired."
"Anonymization of personal information within individual entries helps, but it is generally not sufficient to prevent real log traces from being re-identified based on correlation with other access characteristics."
"As such, access traces that are keyed to a specific client are unsafe to publish even if the key is pseudonymous."
"To minimize the risk of theft or accidental publication, log information ought to be purged of personally identifiable information, including user identifiers, IP addresses, and user-provided query parameters, as soon as that information is no longer necessary to support operational needs for security, auditing, or fraud control."
"The first version, later referred to as HTTP/0.9, was a simple protocol for hypertext data transfer across the Internet, using only a single request method (GET) and no metadata."
"However, HTTP/1.0 did not sufficiently take into consideration the effects of hierarchical proxies, caching, the need for persistent connections, or name-based virtual hosts."
"The proliferation of incompletely implemented applications calling themselves ""HTTP/1.0"" further necessitated a protocol version change in order for two communicating applications to determine each other's true capabilities."
"HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent requirements that enable reliable implementations, adding only those features that can either be safely ignored by an HTTP/1.0 recipient or only be sent when communicating with a party advertising conformance with HTTP/1.1.
HTTP/1.1 has been designed to make supporting previous versions easy."
"Likewise, an HTTP/1.1 client can be expected to understand any valid HTTP/1.0 response."
"Since HTTP/0.9 did not support header fields in a request, there is no mechanism for it to support name-based virtual hosts (selection of resource by inspection of the Host header field)."
"Most requests that appear to be HTTP/0.9 are, in fact, badly constructed HTTP/1.x requests caused by a client failing to properly encode the request-target."
"The requirements that clients and servers support the Host header field (Section 5.4), report an error if it is missing from an HTTP/1.1 request, and accept absolute URIs (Section 5.3) are among the most important changes defined by HTTP/1.1. Older HTTP/1.0 clients assumed a one-to-one relationship of IP addresses and servers; there was no other established mechanism for distinguishing the intended server of a request than the IP address to which that request was directed."
"At the time of this writing, most HTTP-based services are dependent upon the Host header field for targeting requests."
"In HTTP/1.0, each connection is established by the client prior to the request and closed by the server after sending the response."
"However, some experimental implementations of HTTP/1.0 persistent connections are faulty; for example, if an HTTP/1.0 proxy server doesn't understand Connection, it will erroneously forward that header field to the next inbound server, which would result in a hung connection."
"In practice, this was also unworkable, because proxies are often deployed in multiple layers, bringing about the same problem discussed above."
"As a result, clients are encouraged not to send the Proxy-Connection header field in any requests."
"Clients are also encouraged to consider the use of Connection: keep-alive in requests carefully; while they can enable persistent connections with HTTP/1.0 servers, clients using them will need to monitor the connection for ""hung"" requests (which indicate that the client ought stop sending the header field), and this mechanism ought not be used by clients at all when a proxy is being used."
