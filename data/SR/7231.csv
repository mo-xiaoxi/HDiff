sentences
"A server listens on a connection for a request, parses each message received, interprets the message semantics in relation to the identified request target, and responds to that request with one or more response messages."
"A client constructs request messages to communicate specific intentions, examines received responses to see if the intentions were carried out, and determines how to interpret the results."
"This document also defines representation metadata that describe how a payload is intended to be interpreted by a recipient, the request header fields that might influence content selection, and the various selection algorithms that are collectively referred to as ""content negotiation"" (Section 3.4)."
"The key words ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"", ""SHOULD"", ""SHOULD NOT"", ""RECOMMENDED"", ""MAY"", and ""OPTIONAL"" in this document are to be interpreted as described in [RFC2119]."
Conformance criteria and considerations regarding error handling are defined in Section 2.5 of [RFC7230].
"The target of an HTTP request is called a ""resource""."
HTTP does not limit the nature of a resource; it merely defines an interface that might be used to interact with resources.
"If there is a conflict between the method semantics and any semantic implied by the URI itself, as described in Section 4.2.1, the method semantics take precedence."
"Considering that a resource could be anything, and that the uniform interface provided by HTTP is similar to a window through which one can observe and act upon such a thing only through the communication of messages to some independent actor on the other side, an abstraction is needed to represent (""take the place of"") the current or desired state of that thing in our communications."
"This ""selected representation"" is used to provide the constructing the payload for 200 (OK) and 304 (Not Modified) responses to GET (Section 4.3.1)."
"media-type = type ""/"" subtype *( OWS "";"" OWS parameter ) type       = token subtype    = token"
"parameter      = token ""="" ( token / quoted-string ) Parameter values might or might not be case-sensitive, depending on the semantics of the parameter name."
The quoted and unquoted values are equivalent.
"For example, the following examples are all equivalent, but the first is preferred for consistency: text/html;charset=utf-8 text/html;charset=UTF-8 Text/HTML;Charset=""utf-8"" text/html; charset=""utf-8"""
"Unlike some similar constructs in other header fields, media type parameters do not allow whitespace (even ""bad"" whitespace) around the ""="" character."
A charset is identified by a case-insensitive token.
"Furthermore, MIME's constraints for the sake of compatibility with older mail transfer protocols do not apply to HTTP (see Appendix A)."
"An HTTP sender MAY generate, and a recipient MUST be able to parse, line breaks in text media that consist of CRLF, bare CR, or bare LF."
"In addition, text media in HTTP is not limited to charsets that use octets 13 and 10 for CR and LF, respectively."
"This flexibility regarding line breaks applies only to text within a representation that has been assigned a ""text"" media type; it does not apply to ""multipart"" types or HTTP elements outside the payload body (e.g., header fields)."
The message body is itself a protocol element; a sender MUST generate only CRLF to represent line breaks between body parts.
"HTTP message framing does not use the multipart boundary as an indicator of message body length, though it might be used by implementations that generate or process the payload."
Content-Type = media-type is Content-Type: text/html; charset=ISO-8859-4
A sender that generates a message containing a payload body SHOULD generate a Content-Type header field in that message unless the intended media type of the enclosed representation is unknown to the sender.
"If a Content-Type header field is not present, the recipient MAY either assume a media type of ""application/octet-stream"" ([RFC2046], Section 4.5.1) or examine the data to determine its type."
"In practice, resource owners do not always properly configure their origin server to provide the correct Content-Type for a given representation, with the result that some clients will examine a payload's content and override the specified type."
"Clients that do so risk drawing incorrect conclusions, which might expose additional security risks (e.g., ""privilege escalation"")."
"Furthermore, it is impossible to determine the sender's intent by examining the data format: many data formats match multiple media types that differ only in processing semantics."
"Implementers are encouraged to provide a means of disabling such ""content sniffing"" when it is used."
Content codings are primarily used to allow a representation to be compressed or otherwise usefully transformed without losing the identity of its underlying media type and without loss of information.
"All content-coding values are case-insensitive and ought to be registered within the ""HTTP Content Coding Registry"", as defined in Section 8.4."
"The ""Content-Encoding"" header field indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the Content-Type header field."
Content-Encoding is primarily used to allow a representation's data to be compressed without losing the identity of its underlying media type.
Content-Encoding = 1#content-coding
An example of its use is Content-Encoding: gzip
"If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied."
Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
"Typically, the representation is only decoded just prior to rendering or analogous usage."
"If the media type includes an inherent encoding, such as a data format that is always compressed, then that encoding would not be restated in Content-Encoding even if it happens to be the same algorithm as one of the content codings."
"Likewise, an origin server might choose to publish the same data as multiple representations that differ only in whether the coding is defined as part of Content-Type in their handling of each response (e.g., open a ""Save as ..."" dialog instead of automatic decompression and rendering of content)."
An origin server MAY respond with a status code of 415 (Unsupported Media Type) if a representation in the request message has a content coding that is not acceptable.
"Thus, if the content is intended only for a Danish-literate audience, the appropriate field is Content-Language: da If no Content-Language is specified, the default is that the content is intended for all language audiences."
"This might mean that the sender does not consider it to be specific to any natural language, or that the sender does not know for which language it is intended."
"For example, a rendition of the ""Treaty of Waitangi"", presented simultaneously in the original Maori and English versions, would call for Content-Language: mi, en However, just because multiple languages are present within a representation does not mean that it is intended for multiple linguistic audiences."
Content-Language MAY be applied to any media type -- it is not limited to textual documents.
"When a complete or partial representation is transferred in a message payload, it is often desirable for the sender to supply, or the recipient to determine, an identifier for a resource corresponding to that representation."
"If the request has a Content-Location header field, then the sender asserts that the payload is a representation of the resource identified by the Content-Location field-value."
"However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification)."
"For a response message, the following rules are applied in order until a match is found: 1.  If the request method is GET or HEAD and the response status code is 200 (OK), 204 (No Content), 206 (Partial Content), or 304 (Not Modified), the payload is a representation of the resource identified by the effective request URI (Section 5.5 of [RFC7230])."
"4.  If the response has a Content-Location header field and its field-value is a reference to a URI different from the effective request URI, then the sender asserts that the payload is a representation of the resource identified by the Content-Location field-value."
"However, such an assertion cannot be trusted unless it can be verified by other means (not defined by this specification)."
"5.  Otherwise, the payload is unidentified."
"The ""Content-Location"" header field references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's payload."
Content-Location = absolute-URI / partial-URI
The Content-Location value is not a replacement for the effective Request URI (Section 5.5 of [RFC7230]).
"message and its value refers (after conversion to absolute form) to a URI that is the same as the effective request URI, then the recipient MAY consider the payload to be a current representation of that resource at the time indicated by the message origination date."
"For a GET (Section 4.3.1) or HEAD (Section 4.3.2) request, this is the same as the default semantics when no Content-Location is provided by the server."
"If Content-Location is included in a 2xx (Successful) response message and its field-value refers to a URI that differs from the effective request URI, then the origin server claims that the URI is an identifier for a different resource corresponding to the enclosed representation."
"Such a claim can only be trusted if both identifiers share the same resource owner, which cannot be programmatically determined via HTTP."
message MUST treat the information as transitory request context rather than as metadata to be saved verbatim as part of the representation.
"However, an origin server MUST NOT use such context information to alter the request semantics."
"Some HTTP messages transfer a complete or partial representation as the message ""payload""."
The purpose of a payload in a request is defined by the method semantics.
"Response messages with an error status code usually contain a payload that represents the error condition, such that it describes the error state and what next steps are suggested for resolving it."
"Header fields that specifically describe the payload, rather than the associated representation, are referred to as ""payload header fields""."
"When responses convey payload information, whether indicating a success or an error, the origin server often has different ways of representing that information; for example, in different formats, languages, or encodings."
"Likewise, different users or user agents might have differing capabilities, characteristics, or preferences that could influence which representation, among those available, would be best to deliver."
"Note that, in all cases, HTTP is not aware of the resource semantics."
HTTP pays no attention to the man behind the curtain.
"When content negotiation preferences are sent by the user agent in a request to encourage an algorithm located at the server to select the preferred representation, it is called proactive negotiation (a.k.a., server-driven negotiation)."
"Proactive negotiation is advantageous when the algorithm for selecting from among the available representations is difficult to describe to a user agent, or when the server desires to send its ""best guess"" to the user agent along with the first response (hoping to avoid the round trip delay of a subsequent request if the ""best guess"" is good enough for the user)."
"It is impossible for the server to accurately determine what might be ""best"" for any given user, since that would require complete knowledge of both the capabilities of the user agent and the intended use for the response (e.g., does the user want to view it on screen or print it on paper?); o"
Having the user agent describe its capabilities in every request can be both very inefficient (given that only a small percentage of responses have multiple representations) and a potential risk to the user's privacy; o
"It complicates the implementation of an origin server and the algorithms for generating responses to a request; and, A user agent cannot rely on proactive negotiation preferences being consistently honored, since the origin server might not implement proactive negotiation for the requested resource or might decide that sending a response that doesn't conform to the user agent's preferences is better than sending a 406 (Not Acceptable) response."
"With reactive negotiation (a.k.a., agent-driven negotiation), selection of the best response representation (regardless of the status code) is performed by the user agent after receiving an initial response from the origin server that contains a list of resources for alternative representations."
"If the user agent is not satisfied by the initial response representation, it can perform a GET request on one or more of the alternative resources, selected based on metadata included in the list, to obtain a different form of representation for that response."
"A server might choose not to send an initial representation, other than the list of alternatives, and thereby indicate that reactive negotiation by the user agent is preferred."
"For example, the alternatives listed in responses with the 300 (Multiple Choices) and 406 (Not Acceptable) status codes include information about the available representations so that the user or user agent can react by making a selection."
"Reactive negotiation is advantageous when the response would vary over commonly used dimensions (such as type, language, or encoding), when the origin server is unable to determine a user agent's capabilities from examining the request, and generally when public caches are used to distribute server load and reduce network usage."
"list of alternatives to the user agent, which degrades user-perceived latency if transmitted in the header section, and needing a second request to obtain an alternate representation."
"Furthermore, this specification does not define a mechanism for supporting automatic selection, though it does not prevent such a mechanism from being developed as an extension."
The request method token is the primary source of request semantics; it indicates the purpose for which the client has made this request and what is expected by the client as a successful result.
method = token HTTP was originally designed to be usable as an interface to distributed object systems.
The request method was envisioned as applying semantics to a target resource in much the same way as invoking a defined method on an identified object would apply semantics.
"Unlike distributed objects, the standardized request methods in HTTP are not resource-specific, since uniform interfaces provide for better visibility and reuse in network-based systems [REST]."
"Once defined, a standardized method ought to have the same semantics when applied to any resource, though each resource determines for itself whether those semantics are implemented or allowed."
"When a request method is received that is unrecognized or not implemented by an origin server, the origin server SHOULD respond with the 501 (Not Implemented) status code."
"When a request method is received that is known by an origin server but not allowed for the target resource, the origin server SHOULD respond with the 405 (Method Not Allowed) status code."
"Request methods are considered ""safe"" if their defined semantics are essentially read-only; i.e., the client does not request, and does not expect, any state change on the origin server as a result of applying a safe method to a target resource."
"Likewise, reasonable use of a safe method is not expected to cause any harm, loss of property, or unusual burden on the origin server."
"from including behavior that is potentially harmful, that is not entirely read-only, or that causes side effects while invoking a safe method."
"What is important, however, is that the client did not request that additional behavior and cannot be held accountable for it."
"For example, most servers append request information to access log files at the completion of every response, regardless of the method, and that is considered safe even though the log storage might become full and crash the server."
"Likewise, a safe request initiated by selecting an advertisement on the Web will often have the side effect of charging an advertising account."
The purpose of distinguishing between safe and unsafe methods is to allow automated retrieval processes (spiders) and cache performance optimization (pre-fetching) to work without fear of causing harm.
"In addition, it allows a user agent to apply appropriate constraints on the automated use of unsafe methods when processing potentially untrusted content."
"A user agent SHOULD distinguish between safe and unsafe methods when presenting potential actions to a user, such that the user can be made aware of an unsafe action before it is requested."
"If the purpose of such a resource is to perform an unsafe action, then the resource owner MUST disable or disallow that action when it is accessed using a safe request method."
"Failure to do so will result in unfortunate side effects when automated processes perform a GET on every URI reference for the sake of link maintenance, pre-fetching, building a search index, etc."
"Of the request methods defined by this specification, PUT, DELETE, and safe request methods are idempotent."
Idempotent methods are distinguished because the request can be repeated automatically if a communication failure occurs before the client is able to read the server's response.
"Request methods can be defined as ""cacheable"" to indicate that responses to them are allowed to be stored for future reuse; for specific requirements see [RFC7234]."
"In general, safe methods that do not depend on a current or authoritative response are defined as cacheable; this specification defines GET, HEAD, and POST as cacheable, although the overwhelming majority of cache implementations only support GET and HEAD."
GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations.
"However, there are no such limitations in practice."
"Even when the URI mapping mechanism is tied to a file system, an origin server might be configured to execute the files with the request as input and send the output as the representation rather than transfer the files directly."
A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.
The response to a GET request is cacheable; a cache MAY use it to satisfy subsequent GET and HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [RFC7234]).
"The HEAD method is identical to GET except that the server MUST NOT send a message body in the response (i.e., the response terminates at the end of the header section)."
"The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request had been a GET, except that the payload header fields (Section 3.3) MAY be omitted."
A payload within a HEAD request message has no defined semantics; sending a payload body on a HEAD request might cause some existing implementations to reject the request.
The response to a HEAD request is cacheable; a cache MAY use it to satisfy subsequent HEAD requests unless otherwise indicated by the Cache-Control header field (Section 5.2 of [RFC7234]).
"An origin server indicates response semantics by choosing an appropriate status code depending on the result of processing the POST request; almost all of the status codes defined by this specification might be received in a response to POST (the exceptions being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not Satisfiable))."
Responses to POST requests are only cacheable when they include explicit freshness information (see Section 4.2.1 of [RFC7234]).
"However, POST caching is not widely implemented."
"If the result of processing a POST would be equivalent to a representation of an existing resource, an origin server MAY redirect the user agent to that resource by sending a 303 (See Other) response with the existing resource's identifier in the Location field."
"This has the benefits of providing the user agent a resource identifier and transferring the representation via a method more amenable to shared caching, though at the cost of an extra request if the user agent does not already have the representation cached."
"However, there is no guarantee that might be acted upon by other user agents in parallel, or might be subject to dynamic processing by the origin server, before any subsequent GET is received."
A successful response only implies that the user agent's intent was achieved at the time of its processing by the origin server.
"If the target resource does not have a current representation and the PUT successfully creates one, then the origin server MUST inform the user agent by sending a 201 (Created) response."
"If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server MUST send either a 200 (OK) or a 204 (No Content) response to indicate successful completion of the request."
"An origin server SHOULD ignore unrecognized header fields received in a PUT request (i.e., do not save them as part of the resource state)."
An origin server SHOULD verify that the PUT representation is consistent with any constraints the server has for the target resource that cannot or will not be changed by the PUT.
"When a PUT representation is inconsistent with the target resource, the origin server SHOULD either make them consistent, by transforming the representation or changing the resource configuration, or respond with an appropriate error message containing sufficient information to explain why the representation is unsuitable."
origin server beyond what can be expressed by the intent of the user agent request and the semantics of the origin server response.
"It does not define what a resource might be, in any sense of that word, beyond the interface provided via HTTP."
"It does not define how resource state is ""stored"", nor how such storage might change as a result of a change in resource state, nor how the origin server translates resource state into representations."
"Generally speaking, all implementation details behind the resource interface are intentionally hidden by the server."
"An origin server MUST NOT send a validator header field (Section 7.2), such as an ETag or Last-Modified field, in a successful response to PUT unless the request's representation data was saved without any transformation applied to the body (i.e., the resource's new representation data is identical to the representation data received in the PUT request) and the validator field value reflects the new representation."
"This requirement allows a user agent to know when the representation body it has in memory remains current as a result of the PUT, thus not in need of being retrieved again from the origin server, and that the new validator(s) received in the response can be used for future conditional requests in order to prevent accidental overwrites (Section 5.2)."
"A service that selects a proper URI on behalf of the client, after receiving a state-changing request, SHOULD be implemented using the POST method rather than PUT."
"If the origin server will not make the requested PUT state change to the target resource and instead wishes to have it applied to a different resource, such as when the resource has been moved to a different URI, then the origin server MUST send an appropriate 3xx (Redirection) response; the user agent MAY then make its own decision regarding whether or not to redirect the request."
"An origin server that allows PUT on a given target resource MUST send a 400 (Bad Request) response to a PUT request that contains a Content-Range header field (Section 4.2 of [RFC7233]), since the payload is likely to be partial content that has been mistakenly PUT as a full representation."
Responses to the PUT method are not cacheable.
"If a successful PUT request passes through a cache that has one or more stored responses for the effective request URI, those stored responses will be invalidated (see Section 4.4 of [RFC7234])."
"In effect, this method is similar to the rm command in UNIX: it expresses a deletion operation on the URI mapping of the origin server rather than an expectation that the previously associated information be deleted."
"In general, it is assumed that the origin server will only allow DELETE on resources for which it has a prescribed mechanism for accomplishing the deletion."
"Relatively few resources allow the DELETE method -- its primary use is for remote authoring environments, where the user has some direction regarding its effect."
"For example, a resource that was previously created using a PUT request, or identified via the Location header field after a 201 (Created) response to a POST request, might allow a corresponding DELETE request to undo those actions."
"Similarly, custom user agent implementations that implement for remote operations, might use DELETE based on an assumption that the server's URI space has been crafted to correspond to a version repository."
"If a DELETE method is successfully applied, the origin server SHOULD send a 202 (Accepted) status code if the action will likely succeed but has not yet been enacted, a 204 (No Content) status code if the action has been enacted and no further information is to be supplied, or a 200 (OK) status code if the action has been enacted and the response message includes a representation describing the status."
A payload within a DELETE request message has no defined semantics; sending a payload body on a DELETE request might cause some existing implementations to reject the request.
Responses to the DELETE method are not cacheable.
"If a DELETE request passes through a cache that has one or more stored responses for the effective request URI, those stored responses will be invalidated (see Section 4.4 of [RFC7234])."
"The CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the tunnel is closed."
"However, most origin servers do not implement CONNECT."
Any response other than a successful response indicates that the tunnel has not yet been formed and that the connection remains governed by HTTP.
"A tunnel is closed when a tunnel intermediary detects that either side has closed its connection: the intermediary MUST attempt to send any outstanding data that came from the closed side to the other side, close both connections, and then discard any remaining data left undelivered."
"There are significant risks in establishing a tunnel to arbitrary servers, particularly when the destination is a well-known or reserved TCP port that is not intended for Web traffic."
Proxies that support CONNECT SHOULD restrict its use to a limited set of known ports or a configurable whitelist of safe request targets.
A server MUST NOT send any Transfer-Encoding or Content-Length header fields in a 2xx (Successful) response to CONNECT.
A client MUST ignore any Content-Length or Transfer-Encoding header fields received in a successful response to CONNECT.
A payload within a CONNECT request message has no defined semantics; sending a payload body on a CONNECT request might cause some existing implementations to reject the request.
Responses to the CONNECT method are not cacheable.
"The OPTIONS method requests information about the communication options available for the target resource, at either the origin server or an intervening intermediary."
"Since a server's communication options typically depend on the resource, the ""*"" request is only useful as a ""ping"" or ""no-op"" type of method; it does nothing beyond allowing the client to test the capabilities of the server."
"For example, this can be used to test a proxy for HTTP/1.1 conformance (or lack thereof)."
"If the request-target is not an asterisk, the OPTIONS request applies to the options that are available when communicating with the target resource."
"A server generating a successful response to OPTIONS SHOULD send any header fields that might indicate optional features implemented by the server and applicable to the target resource (e.g., Allow), including potential extensions not defined by this specification."
"A standard format for such a representation is not defined by this specification, but might be defined by future extensions to HTTP."
"A server MUST generate a Content-Length field with a value of ""0"" if no payload body is to be sent in the response."
A proxy MUST NOT generate a Max-Forwards header field while forwarding a request unless that request was received with a Max-Forwards field.
A client that generates an OPTIONS request containing a payload body MUST send a valid Content-Type header field describing the representation media type.
"Although this specification does not define any use for such a payload, future extensions to HTTP might use the OPTIONS body to make more detailed queries about the target resource."
Responses to the OPTIONS method are not cacheable.
The final recipient is either the origin server or the first server to receive a Max-Forwards value of zero (0) in the request (Section 5.1.2).
"For example, it would be foolish for a user agent to send stored user credentials [RFC7235] or cookies [RFC6265] in a TRACE request."
A client MUST NOT send a message body in a TRACE request.
Responses to the TRACE method are not cacheable.
"Expect  = ""100-continue"" The Expect field-value is case-insensitive."
A server that receives an Expect field-value other than 100-continue MAY respond with a 417 (Expectation Failed) status code to indicate that the unexpected expectation cannot be met.
"A 100-continue expectation informs recipients that the client is about to send a (presumably large) message body in this request and wishes to receive a 100 (Continue) interim response if the request-line and header fields are not sufficient to cause an immediate success, redirect, or error response."
"This allows the client to wait for an indication that it is worthwhile to send the message body before actually doing so, which can improve efficiency when the message body is huge or when the client anticipates that an error is likely (e.g., when sending a state-changing method, for the first time, without previously verified authentication credentials)."
"For example, a request that begins with PUT /somewhere/fun HTTP/1.1 Host: origin.example.com"
"Expect: 100-continue allows the origin server to immediately respond with an error message, such as 401 (Unauthorized) or 405 (Method Not Allowed), before the client starts filling the pipes with an unnecessary data transfer."
Requirements for clients: o  A client MUST NOT generate a 100-continue expectation in a request that does not include a message body.
o  A client that will wait for a 100 (Continue) response before sending the request message body MUST send an Expect header field containing a 100-continue expectation.
wait for any specific length of time; such a client MAY proceed to send the message body even if it has not yet received a response.
"Furthermore, since 100 (Continue) responses cannot be sent through an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an indefinite period before sending the message body."
"o  A client that receives a 417 (Expectation Failed) status code in response to a request containing a 100-continue expectation SHOULD repeat that request without a 100-continue expectation, since the 417 response merely indicates that the response chain does not support expectations (e.g., it passes through an HTTP/1.0 server)."
Requirements for servers: o  A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore that expectation.
"o  A server MAY omit sending a 100 (Continue) response if it has already received some or all of the message body for the corresponding request, or if the framing indicates that there is no message body."
"o  A server that sends a 100 (Continue) response MUST ultimately send a final status code, once the message body is received and processed, unless the connection is closed prematurely."
The origin server MUST NOT wait for the message body before sending the 100 (Continue) response.
"However, the extension mechanism has not been used by clients and the must-understand requirements have not been implemented by many servers, rendering the extension mechanism useless."
"The ""Max-Forwards"" header field provides a mechanism with the TRACE (Section 4.3.8) and OPTIONS (Section 4.3.7) request methods to limit the number of times that the request is forwarded by proxies."
This can be useful when the client is attempting to trace a request that appears to be failing or looping mid-chain.
Max-Forwards = 1*DIGIT
"If the received value is zero (0), the intermediary MUST NOT forward the request; instead, the intermediary MUST respond as the final recipient."
"If the received Max-Forwards value is greater than zero, the intermediary MUST generate an updated Max-Forwards field in the forwarded message with a field-value that is the lesser of a) the received value decremented by one (1) or b) the recipient's maximum supported value for Max-Forwards."
A recipient MAY ignore a Max-Forwards header field received with any other request methods.
"The HTTP conditional request header fields [RFC7232] allow a client to place a precondition on the state of the target resource, so that the action corresponding to the method semantics will not be applied if the precondition evaluates to false."
"Many of the request header fields for proactive negotiation use a common parameter, named ""q"" (case-insensitive), to assign a relative ""weight"" to the preference for that associated kind of content."
"This weight is referred to as a ""quality value"" (or ""qvalue"") because the same parameter name is often used within server configurations to assign a weight to the relative quality of the various representations that can be selected for a resource."
"where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means ""not acceptable""."
"If no ""q"" parameter is present, the default weight is 1. weight = OWS "";"" OWS ""q="" qvalue qvalue = ( ""0"" [ ""."""
A sender of qvalue MUST NOT generate more than three digits after the decimal point.
"However, unless the user agent is a closed system that cannot interact with other rendering agents, this default set ought to be configurable by the user."
"The ""Accept-Charset"" header field can be sent by a user agent to indicate what charsets are acceptable in textual response content."
This field allows user agents capable of understanding more comprehensive or special-purpose charsets to signal that capability to an origin server that is capable of representing information in those charsets.
"Accept-Charset = 1#( ( charset / ""*"" ) [ weight ] )"
"An example is Accept-Charset: iso-8859-5, unicode-1-1;q=0.8"
"The special value ""*"", if present in the Accept-Charset field, matches every charset that is not mentioned elsewhere in the Accept-Charset field."
"If no ""*"" is present in an Accept-Charset field, then any charsets not explicitly mentioned in the field are considered ""not acceptable"" to the client."
A request without any Accept-Charset header field implies that the user agent will accept any charset in response.
"Most general-purpose user agents do not send Accept-Charset, unless specifically makes it easier for a server to identify an individual by virtue of the user agent's request characteristics (Section 9.7)."
"If an Accept-Charset header field is present in a request and none of the available representations for the response has a charset that is listed as acceptable, the origin server can either honor the header field, by sending a 406 (Not Acceptable) response, or disregard the header field by treating the resource as if it is not subject to content negotiation."
"The ""Accept-Encoding"" header field can be used by user agents to indicate what response content-codings (Section 3.1.2.1) are acceptable in the response."
"An ""identity"" token is used as a synonym for ""no encoding"" in order to communicate when no encoding is preferred."
"Accept-Encoding  = #( codings [ weight ] ) codings          = content-coding / ""identity"" / ""*"""
"The asterisk ""*"" symbol in an Accept-Encoding field matches any available content-coding not explicitly listed in the header field."
"For example, Accept-Encoding: compress, gzip Accept-Encoding: Accept-Encoding: * Accept-Encoding: compress;q=0.5, gzip;q=1.0 Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0"
A request without an Accept-Encoding header field implies that the user agent has no preferences regarding content-codings.
"Although this allows the server to use any content-coding in a response, it does not imply that the user agent will be able to correctly process all encodings."
"A server tests whether a content-coding for a given representation is acceptable using these rules: 1.  If no Accept-Encoding field is in the request, any content-coding is considered acceptable by the user agent."
"(As defined in Section 5.3.1, a qvalue of 0 means ""not acceptable"".)"
"4.  If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred."
An Accept-Encoding header field with a combined field-value that is empty implies that the user agent does not want any content-coding in response.
"If an Accept-Encoding header field is present in a request and none of the available representations for the response have a content-coding that is listed as acceptable, the origin server SHOULD send a response without any content-coding."
Note: Most HTTP/1.0 applications do not recognize or obey qvalues associated with content-codings.
This means that qvalues might not work and are not permitted with x-gzip or x-compress.
"Each language-range can be given an associated quality value representing an estimate of the user's preference for the languages specified by that range, as defined in Section 5.3.1."
"If the header field is present in a request and none of the available representations for the response have a matching language tag, the origin server can either disregard the header field by treating the response as if it sending a 406 (Not Acceptable) response."
"However, the latter is not encouraged, as doing so can prevent users from accessing content that they might be able to use (with translation software, for example)."
"Note that some recipients treat the order in which language tags are listed as an indication of descending priority, particularly for tags that are assigned equal quality values (no value is the same as q=1)."
"For consistency and to maximize interoperability, many user agents assign each language tag a unique quality value while also listing them in order of decreasing quality."
"Since intelligibility is highly dependent on the individual user, user agents need to allow user control over the linguistic preference (either through configuration of the user agent itself or by defaulting to a user controllable system setting)."
A user agent that does not provide such control to the user MUST NOT send an Accept-Language header field.
"For example, users might assume that on selecting ""en-gb"", they will be served any kind of English document if British English is not available."
"A user agent SHOULD NOT send a From header field without explicit configuration by the user, since that might conflict with the user's privacy interests or their site's security policy."
"the person responsible for running the robot can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests."
"A server SHOULD NOT use the From header field for access control or authentication, since most recipients will assume that the field value is public information."
"The ""Referer"" [sic] header field allows the user agent to specify a URI reference for the resource from which the target URI was obtained (i.e., the ""referrer"", though the field name is misspelled)."
"A user agent MUST NOT include the fragment and userinfo components of the URI reference [RFC3986], if any, when generating the Referer field value."
Referer = absolute-URI / partial-URI
"The Referer header field allows servers to generate back-links to other resources for simple analytics, logging, optimized caching, etc."
"Some servers use the Referer header field as a means of denying links from other sites (so-called ""deep linking"") or restricting cross-site request forgery (CSRF), but not all requests contain it."
"If the target URI was obtained from a source that does not have its own URI (e.g., input from the user keyboard, or an entry within the user's bookmarks/favorites), the user agent MUST either exclude the Referer field or send it with a value of ""about:blank""."
"Most general-purpose user agents do not send the Referer header field when the referring resource is a local ""file"" or ""data"" URI."
A user agent MUST NOT send a Referer header field in an unsecured HTTP request if the referring page was received with a secure protocol.
"This has the unfortunate side effect of interfering with protection against CSRF attacks, which can be far more harmful to their users."
"Intermediaries and user agent extensions that wish to limit information disclosure in Referer ought to restrict their changes to specific edits, such as replacing internal domain names with pseudonyms or truncating the query and/or path components."
An intermediary SHOULD NOT modify or delete the Referer header field when the field value shares the same scheme and host as the request target.
"The ""User-Agent"" header field contains information about the user agent originating the request, which is often used by servers to help identify the scope of reported interoperability problems, to work around or tailor responses to avoid particular user agent limitations, and for analytics regarding browser or operating system use."
A user agent SHOULD send a User-Agent field in each request unless specifically configured not to do so.
User-Agent = product *( RWS ( product / comment ) )
"product         = token [""/"" product-version] product-version = token A sender SHOULD limit generated product identifiers to what is necessary to identify the product; a sender MUST NOT generate advertising or other nonessential information within the product identifier."
"A sender SHOULD NOT generate information in product-version that is not a version identifier (i.e., successive versions of the same product name ought to differ only in the product-version portion of the product identifier)."
Example: User-Agent: CERN-LineMode/2.15 libwww/2.17b3 needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties.
"Overly long and detailed User-Agent field values increase request latency and the risk of a user being identified against their wishes (""fingerprinting"")."
"Likewise, implementations are encouraged not to use the product tokens of other implementations in order to declare compatibility with them, as this circumvents the purpose of the field."
"If a user agent masquerades as a different user agent, recipients can assume that the user intentionally desires to see responses tailored for that identified user agent, even if they might not work as well for the actual user agent being used."
"Responses with status codes that are defined as cacheable by default (e.g., 200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501 in this specification) can be reused by a cache with heuristic expiration unless otherwise indicated by the method definition or explicit cache controls [RFC7234]; all other status codes are not cacheable by default."
The 1xx (Informational) class of status code indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response.
1xx responses are terminated by the first empty line after the status-line (the empty line signaling the end of the header section).
"Since HTTP/1.0 did not define any 1xx status codes, a server MUST NOT send a 1xx response to an HTTP/1.0 client."
"A client MUST be able to parse one or more 1xx responses received prior to a final response, even if the client does not expect one."
A proxy MUST forward 1xx responses unless the proxy itself requested the generation of the 1xx response.
"For example, if a proxy adds an ""Expect: 100-continue"" field when it forwards a request, then it need not forward the corresponding 100 (Continue) response(s)."
The 100 (Continue) status code indicates that the initial part of a request has been received and has not yet been rejected by the server.
The client ought to continue sending the request and discard the 100 response.
"If the request did not contain an Expect header field containing the 100-continue expectation, the client can simply discard this interim response."
The server which protocol(s) will be switched to immediately after the empty line that terminates the 101 response.
"The 2xx (Successful) class of status code indicates that the client's request was successfully received, understood, and accepted."
"Aside from responses to CONNECT, a 200 response always has a payload, though an origin server MAY generate a payload body of zero length."
"If no payload is desired, an origin server ought to send 204 (No Content) instead."
"For CONNECT, no payload is allowed because the successful result is a tunnel, which begins immediately after the 200 response header section."
"A 200 response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [RFC7234])."
The 201 (Created) status code indicates that the request has been fulfilled and has resulted in one or more new resources being created.
"The primary resource created by the request is identified by either a Location header field in the response or, if no Location field is received, by the effective request URI."
"The 202 (Accepted) status code indicates that the request has been accepted for processing, but the processing has not been completed."
There is no facility in HTTP for re-sending a status code from an asynchronous operation.
The 202 response is intentionally noncommittal.
Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed.
"For example, future cache validation requests for the content might only be applicable along the same request path (through the same proxies)."
The 204 (No Content) status code indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body.
"For example, if a 204 status code is received in response to a PUT request and the response contains an ETag header field, then the PUT was successful and the ETag field-value contains the entity-tag for the new representation of that target resource."
"The 204 response allows a server to indicate that the action has been successfully applied to the target resource, while implying that the user agent does not need to traverse away from its current ""document view"" (if any)."
"For example, a 204 status code is commonly used with document editing interfaces corresponding to a ""save"" action, such that the document being saved remains available to the user for editing."
A 204 response is terminated by the first empty line after the header fields because it cannot contain a message body.
"A 204 response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [RFC7234])."
"The 205 (Reset Content) status code indicates that the server has fulfilled the request and desires that the user agent reset the ""document view"", which caused the request to be sent, to its original state as received from the origin server."
"Since the 205 status code implies that no additional content will be provided, a server MUST NOT generate a payload in a 205 response."
"In other words, a server MUST do one of the following for a 205 response: a) indicate a zero-length body for the response by including a Content-Length header field with a value of 0; b) indicate a zero-length payload for the response by including a Transfer-Encoding header field with a value of chunked and a message body consisting of a single chunk of zero-length; or, c) close the connection immediately after sending the blank line terminating the header section."
"If a Location header field (Section 7.1.2) is provided, the user agent MAY automatically redirect its request to the URI referenced by the Location field value, even if the specific status code is not understood."
"Automatic redirection needs to done with care for methods not known to be safe, as defined in Section 4.2.1, since the user might not wish to redirect an unsafe request."
"2.  Redirection that offers a choice of matching resources, each capable of representing the original request target, as in the 300 (Multiple Choices) status code."
"4.  Redirection to a previously cached result, as in the 304 (Not Modified) status code."
"Early user agents split on whether the method applied to the redirect target would be the same as the originally defined the former semantics for 301 and 302 (to match its original implementation at CERN), and defined 303 (See Other) to match the latter semantics, prevailing practice gradually converged on the latter semantics for 301 and 302 as well."
"Over 10 years later, most user agents still do method rewriting for 301 and 302; therefore, this specification makes that behavior conformant when the original request is POST."
"A client SHOULD detect and intervene in cyclical redirections (i.e., ""infinite"" redirection loops)."
"If the server has a preferred choice, the server SHOULD generate a Location header field containing a preferred choice's URI reference."
A specific format for automatic selection is not defined by this specification because HTTP tries to remain orthogonal to the definition of its payloads.
"However, lack of deployment and disagreement over syntax led to both URI and Alternates (a subsequent proposal) being dropped from this specification."
"It is possible to communicate the list using a set of Link header fields [RFC5988], each with a relationship of ""alternate"", though deployment is a chicken-and-egg problem."
"Clients with link-editing capabilities ought to automatically re-link references to the effective request URI to one or more of the new references sent by the server, where possible."
"A 301 response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [RFC7234])."
"Since the redirection might be altered on occasion, the client ought to continue to use the effective request URI for future requests."
"The 303 (See Other) status code indicates that the server is redirecting the user agent to a different resource, as indicated by a URI in the Location header field, which is intended to provide an indirect response to the original request."
Note that the new URI in the Location header field is not considered equivalent to the effective request URI.
A 303 response to a GET request indicates that the origin server does not have a representation of the target resource that can be transferred by the server over HTTP.
"However, the Location field value refers to a resource that is descriptive of the target resource, such that making a retrieval request on that other resource might result in a representation that is useful to recipients without implying that it represents the original target resource."
The 305 (Use Proxy) status code was defined in a previous version of this specification and is now deprecated (Appendix B).
"The 306 status code was defined in a previous version of this specification, is no longer used, and the code is reserved."
The 307 (Temporary Redirect) status code indicates that the target resource resides temporarily under a different URI and the user agent MUST NOT change the request method if it performs an automatic redirection to that URI.
"Since the redirection can change over time, the client ought to continue using the original effective request URI for future requests."
"This status code is similar to 302 (Found), except that it does not allow changing the request method from POST to GET."
The 4xx (Client Error) class of status code indicates that the client seems to have erred.
"Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent condition."
"The 400 (Bad Request) status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing)."
The 403 (Forbidden) status code indicates that the server understood the request but refuses to authorize it.
A server that wishes to make public why the request has been forbidden can describe that reason in the response payload (if any).
"If authentication credentials were provided in the request, the server considers them insufficient to grant access."
The client SHOULD NOT automatically repeat the request with the same credentials.
"An origin server that wishes to ""hide"" the current existence of a forbidden target resource MAY instead respond with a status code of 404 (Not Found)."
The 404 (Not Found) status code indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists.
"A 404 status code does not indicate whether this lack of representation is temporary or permanent; the 410 (Gone) status code is preferred over 404 if the origin server knows, presumably through some configurable means, that the condition is likely to be permanent."
"A 404 response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [RFC7234])."
The 405 (Method Not Allowed) status code indicates that the method received in the request-line is known by the origin server but not supported by the target resource.
"A 405 response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [RFC7234])."
"The 406 (Not Acceptable) status code indicates that the target resource does not have a current representation that would be acceptable to the user agent, according to the proactive negotiation header fields received in the request (Section 5.3), and the server is unwilling to supply a default representation."
The server SHOULD generate a payload containing a list of available representation characteristics and corresponding resource identifiers from which the user or user agent can choose the one most appropriate.
"However, this specification does not define any standard for such automatic selection, as described in Section 6.4.1."
The 408 (Request Timeout) status code indicates that the server did not receive a complete request message within the time that it was prepared to wait.
"A server SHOULD send the ""close"" connection option (Section 6.1 of [RFC7230]) in the response, since 408 implies that the server has decided to close the connection rather than continue waiting."
"If the client has an outstanding request in transit, the client MAY repeat that request on a new connection."
The 409 (Conflict) status code indicates that the request could not be completed due to a conflict with the current state of the target resource.
The server SHOULD generate a payload that includes enough information for a user to recognize the source of the conflict.
The 410 (Gone) status code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.
"If the origin server does not is permanent, the status code 404 (Not Found) ought to be used instead."
The 410 response is primarily intended to assist the task of web maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed.
"It is not necessary to mark all permanently unavailable resources as ""gone"" or to keep the mark for any length of time -- that is left to the discretion of the server owner."
"A 410 response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [RFC7234])."
The 411 (Length Required) status code indicates that the server refuses to accept the request without a defined Content-Length (Section 3.3.2 of [RFC7230]).
The 413 (Payload Too Large) status code indicates that the server is refusing to process a request because the request payload is larger than the server is willing or able to process.
"If the condition is temporary, the server SHOULD generate a Retry-After header field to indicate that it is temporary and after what time the client MAY try again."
The 414 (URI Too Long) status code indicates that the server is refusing to service the request because the request-target (Section 5.3 of [RFC7230]) is longer than the server is willing to interpret.
"This rare condition is only likely to occur when a client has improperly converted a POST request to a GET request with long query information, when the client has descended into a ""black hole"" of redirection (e.g., a redirected URI prefix that points to a suffix of itself) or when the server is under attack by a client attempting to exploit potential security holes."
The 415 (Unsupported Media Type) status code indicates that the origin server is refusing to service the request because the payload is in a format not supported by this method on the target resource.
The 417 (Expectation Failed) status code indicates that the expectation given in the request's Expect header field (Section 5.1.1) could not be met by at least one of the inbound servers.
The 426 (Upgrade Required) status code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.
Example: HTTP/1.1 426 Upgrade Required Upgrade: HTTP/3.0 Connection: Upgrade Content-Length: 53 Content-Type: text/plain
The 5xx (Server Error) class of status code indicates that the server is aware that it has erred or is incapable of performing the requested method.
"Except when responding to a HEAD request, the server SHOULD send a representation containing an explanation of the error situation, and whether it is a temporary or permanent to the user."
The 500 (Internal Server Error) status code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.
The 501 (Not Implemented) status code indicates that the server does not support the functionality required to fulfill the request.
This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.
"A 501 response is cacheable by default; i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [RFC7234])."
"The 502 (Bad Gateway) status code indicates that the server, while acting as a gateway or proxy, received an invalid response from an inbound server it accessed while attempting to fulfill the request."
"The 503 (Service Unavailable) status code indicates that the server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay."
The server MAY send a Retry-After header field (Section 7.1.3) to suggest an appropriate amount of time for the client to wait before retrying the request.
The existence of the 503 status code does not imply that a server has to use it when becoming overloaded.
"The 504 (Gateway Timeout) status code indicates that the server, while acting as a gateway or proxy, did not receive a timely response from an upstream server it needed to access in order to complete the request."
"The 505 (HTTP Version Not Supported) status code indicates that the server does not support, or refuses to support, the major version of HTTP that was used in the request message."
"The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in Section 2.6 of [RFC7230], other than with this error message."
The server SHOULD generate a representation for the 505 response that describes why that version is not supported and what other protocols are supported by that server.
The response header fields allow the server to pass additional information about the response beyond what is placed in the status-line.
"Response header fields can supply control data that supplements the status code, directs caching, or instructs the client where to go next."
"The first two formats indicate UTC by the three-letter abbreviation for Greenwich Mean Time, ""GMT"", a predecessor of the UTC name; values in the asctime format are assumed to be in UTC."
"Preferred format: IMF-fixdate  = day-name "","" SP date1 SP time-of-day SP GMT ; fixed length/zone/capitalization subset of the format ; see Section 3.3 of [RFC5322] day-name     = %x4D.6F.6E ; ""Mon"", case-sensitive / %x54.75.65 ; ""Tue"", case-sensitive / %x57.65.64 ; ""Wed"", case-sensitive / %x54.68.75 ; ""Thu"", case-sensitive / %x46.72.69 ; ""Fri"", case-sensitive / %x53.61.74 ; ""Sat"", case-sensitive / %x53.75.6E ; ""Sun"", case-sensitive ; e.g., 02 Jun 1982 day          = 2DIGIT month        = %x4A.61.6E ; ""Jan"", case-sensitive / %x46.65.62 ; ""Feb"", case-sensitive / %x4D.61.72 ; ""Mar"", case-sensitive / %x41.70.72 ; ""Apr"", case-sensitive / %x4D.61.79 ; ""May"", case-sensitive / %x4A.75.6E ; ""Jun"", case-sensitive / %x4A.75.6C ; ""Jul"", case-sensitive / %x41.75.67 ; ""Aug"", case-sensitive / %x53.65.70 ; ""Sep"", case-sensitive / %x4F.63.74 ; ""Oct"", case-sensitive / %x4E.6F.76 ; ""Nov"", case-sensitive / %x44.65.63 ; ""Dec"", case-sensitive year         = 4DIGIT GMT          = %x47.4D.54 ; ""GMT"", case-sensitive time-of-day  = hour "":"" minute "":"" second ; 00:00:00 - 23:59:60 (leap second) hour         = 2DIGIT minute       = 2DIGIT second       = 2DIGIT Obsolete formats: obs-date     = rfc850-date / asctime-date rfc850-date  = day-name-l "","" SP date2 SP time-of-day SP GMT date2        = day ""-"" month ""-"" 2DIGIT ; e.g., 02-Jun-82 day-name-l   = %x4D.6F.6E.64.61.79    ; ""Monday"", case-sensitive / %x54.75.65.73.64.61.79       ; ""Tuesday"", case-sensitive / %x57.65.64.6E.65.73.64.61.79 ; ""Wednesday"", case-sensitive / %x54.68.75.72.73.64.61.79    ; ""Thursday"", case-sensitive / %x46.72.69.64.61.79          ; ""Friday"", case-sensitive / %x53.61.74.75.72.64.61.79    ; ""Saturday"", case-sensitive / %x53.75.6E.64.61.79          ; ""Sunday"", case-sensitive asctime-date = day-name SP date3 SP time-of-day SP year date3        = month SP ( 2DIGIT / ( SP 1DIGIT )) ; e.g., Jun  2 whitespace in an HTTP-date beyond that specifically included as SP in the grammar."
"Recipients of a timestamp value in rfc850-date format, which uses a two-digit year, MUST interpret a timestamp that appears to be more than 50 years in the future as representing the most recent year in the past that had the same last two digits."
"For example, messages are occasionally forwarded over HTTP from a non-HTTP source that might generate any of the date and time specifications defined by the Internet Message Format."
"Implementations are not required to use these formats for user presentation, request logging, etc."
"The ""Date"" header field represents the date and time at which the message was originated, having the same semantics as the Origination Date Field (orig-date) defined in Section 3.6.1 of [RFC5322]."
"When a Date header field is generated, the sender SHOULD generate its field value as the best available approximation of the date and time of message generation."
"In theory, the date ought to represent the moment just before the payload is generated."
An origin server MUST NOT send a Date header field if it does not have a clock capable of providing a reasonable approximation of the current instance in Coordinated Universal Time.
Date header field MUST record the time it was received and append a corresponding Date header field to the message's header section if it is cached or forwarded downstream.
"A user agent MAY send a Date header field in a request, though generally will not do so unless it is believed to convey useful information to the server."
"For example, custom applications of HTTP might convey a Date if the server is expected to adjust its interpretation of the user's request based on differences between the user agent and server clocks."
"When it has the form of a relative reference ([RFC3986], Section 4.2), the final value is computed by resolving it against the effective request URI ([RFC3986], Section 5)."
"If the Location value provided in a 3xx (Redirection) response does not have a fragment component, a user agent MUST process the redirection as if the value inherits the fragment component of the URI reference used to generate the request target (i.e., the redirection inherits the original reference's fragment, if any)."
"For example, a GET request generated for the URI reference ""http://www.example.org/~tim"" might result in a 303 (See Other) response containing the header field: Location: /People.html#tim which suggests that the user agent redirect to ""http://www.example.org/People.html#tim"""
"""http://www.example.org/index.html#larry"" might result in a 301 (Moved Permanently) response containing the header field: Location: http://www.example.net/index.html which suggests that the user agent redirect to ""http://www.example.net/index.html#larry"", preserving the original fragment identifier."
There are circumstances in which a fragment identifier in a Location value would not be appropriate.
"For example, the Location header field in a 201 (Created) response is supposed to provide a URI that is specific to the created resource."
Note: Some recipients attempt to recover from Location fields that are not valid URI references.
"This specification does not mandate or define such processing, but does allow it for the sake of robustness."
Note: The Content-Location header field (Section 3.1.4.2) differs from Location in that the Content-Location refers to the most specific resource corresponding to the enclosed representation.
It is therefore possible for a response to contain both the Location and Content-Location header fields.
"Servers send the ""Retry-After"" header field to indicate how long the user agent ought to wait before making a follow-up request."
"When sent with a 503 (Service Unavailable) response, Retry-After indicates how long the service is expected to be unavailable to the client."
"When sent with any 3xx (Redirection) response, Retry-After indicates the minimum time that the user agent is asked to wait before issuing the redirected request."
The value of this field can be either an HTTP-date or a number of seconds to delay after the response is received.
Retry-After = HTTP-date / delay-seconds
"A delay-seconds value is a non-negative decimal integer, representing time in seconds."
"delay-seconds  = 1*DIGIT Retry-After: Fri, 31 Dec 1999 23:59:59 GMT"
"In the latter example, the delay is 2 minutes."
"The value consists of either a single asterisk (""*"") or a list of header field names (case-insensitive)."
"Vary = ""*"" / 1#field-name A Vary field value of ""*"" signals that anything about the request might play a role in selecting the response representation, possibly including elements outside the message syntax (e.g., the client's network address)."
A recipient will not be able to determine whether this response is appropriate for a later request without forwarding the request to the origin server.
"A proxy MUST NOT generate a Vary field with a ""*"" value."
The potential selecting header fields are not limited to those defined by this specification.
"For example, a response that contains Vary: accept-encoding, accept-language indicates that the origin server might have used the request's Accept-Encoding and Accept-Language fields (or lack thereof) as determining factors while choosing the content for this response."
An origin server might send Vary with a list of fields for two purposes: 1.  To inform cache recipients that they MUST NOT use this response to satisfy a later request unless the later request has the same values for the listed fields as the original request (Section 4.1 of [RFC7234]).
"An origin server SHOULD send a Vary header field when its algorithm for selecting a representation varies based on aspects of the request message other than the method and request target, unless the variance cannot be crossed or the origin server has been deliberately configured to prevent cache transparency."
"For example, there is no need to send the Authorization field name in Vary because reuse across users is constrained by the field definition (Section 4.2 of [RFC7235])."
"Likewise, an origin server might use Cache-Control directives (Section 5.2 of [RFC7234]) to supplant Vary if it considers the variance less significant than the performance cost of Vary's impact on caching."
"Note that, depending on the status code semantics, the selected representation for a given response is not necessarily the same as the representation enclosed as response payload."
"In a successful response to a state-changing request, validator fields describe the new representation that has replaced the prior selected representation as a result of processing the request."
"For example, an ETag header field in a 201 (Created) response communicates the entity-tag of the newly created resource's representation, so that it can be used in later conditional requests to prevent the ""lost update"" problem [RFC7232]."
Authentication challenges indicate what mechanisms are available for the client to provide authentication credentials in future requests.
An origin server MUST generate an Allow field in a 405 (Method Not Allowed) response and MAY do so in any other response.
"An empty Allow field value indicates that the resource allows no methods, which might occur in a 405 response if the resource has been temporarily disabled by configuration."
A proxy MUST NOT modify the Allow header field -- it does not need to understand all of the indicated methods in order to handle them according to the generic message handling rules.
"The ""Server"" header field contains information about the software used by the origin server to handle the request, which is often used by clients to help identify the scope of reported interoperability problems, to work around or tailor requests to avoid particular server limitations, and for analytics regarding server or operating system use."
Server = product *( RWS ( product / comment ) )
"The Server field-value consists of one or more product identifiers, each followed by zero or more comments (Section 3.2 of [RFC7230]), which together identify the origin server software and its significant subproducts."
An origin server SHOULD NOT generate a Server field containing needlessly fine-grained detail and SHOULD limit the addition of subproducts by third parties.
Overly long and detailed Server field values increase response latency and potentially reveal internal implementation details that might make it (slightly) easier for attackers to find and exploit known security holes.
"The ""Hypertext Transfer Protocol (HTTP) Method Registry"" defines the namespace for the request method token (Section 4)."
The method registry has been created and is now maintained at <http://www.iana.org/assignments/http-methods>.
"The ""Hypertext Transfer Protocol (HTTP) Status Code Registry"" defines the namespace for the response status-code token (Section 6)."
The status code registry is maintained at <http://www.iana.org/assignments/http-status-codes>.
"When it is necessary to express semantics for a response that are not defined by current status codes, a new status code can be registered."
"Status codes are generic; they are potentially applicable to any resource, not just one particular media type, kind of resource, or application of HTTP."
"As such, it is preferred that new status codes be registered in a document that isn't specific to a single application."
"To allow existing parsers to process the response message, new status codes cannot disallow a payload, although they can mandate a zero-length payload body."
"Proposals for new status codes that are not yet widely deployed ought to avoid allocating a specific number for the code until there is clear consensus that it will be registered; instead, early drafts can use a notation such as ""4NN"", or ""3N0"" .. ""3N9"", to indicate the class of the proposed status code(s) without consuming a number prematurely."
The definition of a new status code ought to specify whether or not it is cacheable.
"Note that all status codes can be cached if the response they occur in has explicit freshness information; however, status codes that are defined as being cacheable are allowed to be cached without explicit freshness information."
"Authors of specifications defining new fields are advised to keep the name as short as practical and not to prefix the name with ""X-"" unless the header field will never be used on the Internet."
"(The ""X-"" prefix idiom has been extensively misused in practice; it was intended to only be used as a mechanism for avoiding name collisions inside proprietary software or intranet processing, since the prefix would ensure that private names never collide with a newly registered Internet name; see [BCP178] for further information)."
Field definitions where leading or trailing whitespace in values is significant will have to use a container syntax such as quoted-string (Section 3.2.6 of [RFC7230]).
"Because commas ("","") are used as a generic delimiter between field-values, they need to be treated with care if they are allowed in the field-value."
"For example, a textual date and a URI (either of which might contain a comma) could be safely carried in field-values like these: Example-URI-Field: ""http://example.com/a.html,foo"", ""http://without-a-comma.example.com/"""
"Example-Date-Field: ""Sat, 04 May 1996"", ""Wed, 14 Sep 2005"" Note that double-quote delimiters almost always are used with the quoted-string production; using a different syntax inside double-quotes will likely cause unnecessary confusion."
Allowing both unquoted (token) and quoted (quoted-string) syntax for the parameter value enables recipients to use existing parser components.
"If it does not use the list syntax, document how to treat messages where the field occurs multiple times (a sensible default would be to ignore the field, but this might not always be the right choice)."
"Note that intermediaries and software libraries might combine multiple header field instances into a single one, despite the field's definition not allowing the list syntax."
"A robust format enables recipients to discover these situations (good example: ""Content-Type"", as the comma can only appear inside quoted strings; bad example: ""Location"", as a comma can occur inside a URI)."
"Under what conditions intermediaries are allowed to insert, delete, or modify the field's value."
"The ""HTTP Content Coding Registry"" defines the namespace for content coding names (Section 4.2 of [RFC7230])."
"Content coding registrations MUST include the following fields: o  Name o  Description o  Pointer to specification text Names of content codings MUST NOT overlap with names of transfer codings (Section 4 of [RFC7230]), unless the encoding transformation is identical (as is the case for the compression codings defined in Section 4.2 of [RFC7230])."
"This section is meant to inform developers, information providers, and users of known security concerns relevant to HTTP semantics and its use for transferring information over the Internet."
The list of considerations below is not exhaustive.
Most file systems are not designed to protect against malicious file or path names.
"Therefore, an origin server needs to avoid accessing names that have a special significance to the system when mapping the request target to files, folders, or directories."
"Likewise, local storage systems have an annoying tendency to prefer user-friendliness over security when handling invalid or unexpected characters, recomposition of decomposed characters, and case-normalization of case-insensitive names."
"Attacks based on such special names tend to focus on either denial- of-service (e.g., telling the server to read from a COM port) or disclosure of configuration and source files that are not meant to be served."
"An attacker could construct any of the request data elements (method, request-target, header fields, or body) to contain data that might be misinterpreted as a command, code, or query when passed through a command invocation, language interpreter, or database interface."
"If the received data is used directly within a SELECT statement, the query language might be interpreted as a database command instead of a simple string value."
"This type of implementation vulnerability is extremely common, in spite of being easy to prevent."
"Parameters ought to be compared to fixed strings and acted upon as a result of that comparison, rather than passed through an interface that is not prepared for untrusted data."
Received data that isn't based on fixed parameters ought to be carefully filtered or encoded to avoid being misinterpreted.
"URIs are intended to be shared, not secured, even when they identify secure resources."
"URIs are often shown on displays, added to templates when a page is printed, and stored in a variety of unprotected bookmark lists."
"It is therefore unwise to include information within a URI that is sensitive, personally identifiable, or a risk to disclose."
Authors of services ought to avoid GET-based forms for the submission of sensitive data because that data will be placed in the request-target.
"Many existing servers, proxies, and user agents log or display the request-target in places where it might be visible to third parties."
Limitations on the Referer header field are described in Section 5.5.2 to address some of its security considerations.
"Although fragment identifiers used within URI references are not sent in requests, implementers ought to be aware that they will be visible to the user agent and any extensions or scripts running as a result of the response."
"If the first site uses personal information in fragments, it ought to ensure that redirects to other sites include a (possibly empty) fragment component in order to block that inheritance."
"In theory, this can make it easier for an attacker to exploit known security holes; in practice, attackers tend to try all potential holes regardless of the apparent software versions being used."
Proxies that serve as a portal through a network firewall ought to take special precautions regarding the transfer of header information that might identify hosts behind the firewall.
There are a number of request header fields that might reveal information to servers that is sufficiently unique to enable fingerprinting.
"The From header field is the most obvious, though it is expected that From will only be sent when self-identification is desired by the user."
"Likewise, Cookie header fields are deliberately apply to situations where cookies are disabled or restricted by the user agent's configuration."
"The User-Agent header field might contain enough information to uniquely identify a specific device, usually when combined with other characteristics, particularly if the user agent sends excessive details about the user's system or extensions."
"However, the source of unique information that is least expected by users is proactive negotiation (Section 5.3), including the Accept, Accept-Charset, Accept-Encoding, and Accept-Language header fields."
"An approach that limits such loss of privacy would be for a user agent to omit the sending of Accept-Language except for sites that have been whitelisted, perhaps via interaction after detecting a Vary header field that indicates language negotiation might be useful."
"In environments where proxies are used to enhance privacy, user agents ought to be conservative in sending proactive negotiation header fields."
General-purpose user agents that provide a high degree of header field configurability ought to inform users about the loss of privacy that might result if too much detail is provided.
"As an extreme privacy measure, proxies could filter the proactive negotiation header fields in relayed requests."
HTTP is not a MIME-compliant protocol.
"However, messages can include a single MIME-Version header field to indicate what version of the MIME protocol was used to construct the message."
"[RFC2046] requires that content with a type of ""text"" represent line breaks as CRLF and forbids the use of CR or LF outside of line break sequences."
"HTTP allows CRLF, bare CR, and bare LF to indicate a line break within text content."
A proxy or gateway from HTTP to a strict MIME environment ought to translate all line breaks within the text media types described in Section 3.1.1.3 of this document to the RFC 2049 canonical form of CRLF.
"Note, however, this might be complicated by the presence of a Content-Encoding and by the fact that HTTP allows the use of some charsets that do not use octets 13 and 10 to represent CR and LF, respectively."
"Therefore, the canonical form is recommended for any content that uses such checksums in HTTP."
MIME does not include any concept equivalent to HTTP/1.1's Content-Encoding header field.
"However, this parameter is not part of the MIME standards)."
HTTP does not use the Content-Transfer-Encoding field of MIME.
"Proxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where ""safe transport"" is defined by the limitations of the protocol being used."
"Since HTTP does not have this limitation, HTTP does not fold long lines."
"MHTML messages being transported by HTTP follow all conventions of MHTML, including line length limitations and folding, canonicalization, etc., since HTTP transfers message-bodies as of [RFC7233]), does not interpret the content or any MIME header lines that might be contained therein."
"The primary changes in this revision have been editorial in nature: extracting the messaging syntax and partitioning HTTP semantics into separate documents for the core features, conditional requests, partial requests, caching, and authentication."
The conformance language has been revised to clearly target requirements and the terminology has been improved to distinguish payload from representations and representations from resources.
"A new requirement has been added that semantics embedded in a URI be disabled when those semantics are inconsistent with the request method, since this is a common cause of interoperability failure."
The default charset of ISO-8859-1 for text media types has been removed; the default is now whatever the media type definition says.
"Likewise, special treatment of ISO-8859-1 has been removed from the Accept-Charset header field."
"The definition of Content-Location has been changed to no longer affect the base URI for resolving relative URI references, due to poor implementation support and the undesirable effect of potentially breaking relative links in content-negotiated resources."
"To be consistent with the method-neutral parsing algorithm of [RFC7230], the definition of GET has been relaxed so that requests can have a body, even though a body has no meaning for GET."
Servers are no longer required to handle all Content-* header fields and use of Content-Range has been explicitly banned in PUT requests.
"(Section 5.1.1) The Max-Forwards header field has been restricted to the OPTIONS and TRACE methods; previously, extension methods could have used it as well."
"(Section 5.1.2) The ""about:blank"" URI has been suggested as a value for the Referer header field when no referring URI is applicable, which distinguishes that case from others where the Referer field is not sent or has been removed."
"(Section 5.5.2) The following status codes are now cacheable (that is, they can be stored and reused by a cache without explicit freshness information present): 204, 404, 405, 414, 501.  (Section 6) The 201 (Created) status description has been changed to allow for the possibility that more than one resource has been created."
(Section 6.3.4) The set of request methods that are safe to automatically redirect is no longer closed; user agents are able to make that determination based upon the request method semantics.
(Section 6.4.4) The 305 (Use Proxy) status code has been deprecated due to security concerns regarding in-band configuration of a proxy.
(Section 6.4.5) The 400 (Bad Request) status code has been relaxed so that it isn't limited to syntax errors.
"The syntax of the Location header field has been changed to allow all URI references, including relative references and fragments, along with some clarifications as to when use of fragments would not be appropriate."
"(Section 7.1.2) Allow has been reclassified as a response header field, removing the option to specify it in a PUT request."
"Requirements relating to the content of Allow have been relaxed; correspondingly, clients are not required to always trust its value."
(Section 8.4) The Content-Disposition header field has been removed since it is now defined by [RFC6266].
The Content-MD5 header field has been removed because it was inconsistently implemented with respect to partial responses.
