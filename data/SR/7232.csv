sentences
"Conditionals can also be applied to state-changing methods, such as PUT and DELETE, to prevent the ""lost update"" problem: one client accidentally overwriting the work of another client that has been acting in parallel."
"Regardless, if the mapping is inconsistent and the server is unable to select the appropriate representation, then no harm will result when the precondition evaluates to false."
"The key words ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"", ""SHOULD"", ""SHOULD NOT"", ""RECOMMENDED"", ""MAY"", and ""OPTIONAL"" in this document are to be interpreted as described in [RFC2119]."
"A resource metadata value is referred to as a ""validator"" when it is used within a precondition."
Validators come in two flavors: strong or weak.
Weak validators are easy to generate but are far less useful for comparisons.
Strong validators are ideal for comparisons but can be very difficult (and occasionally impossible) to generate efficiently.
"Rather than impose that all forms of resource adhere to the same strength of validator, HTTP exposes the type of validator in use and imposes restrictions on when weak validators can be used as preconditions."
"A strong validator might change for reasons other than a change to the representation data, such as when a semantically significant part of the representation metadata is changed (e.g., Content-Type), but it is in the best interests of the origin server to only change the value when it is necessary to invalidate the stored responses held by remote caches and authoring tools."
A strong validator is unique across all versions of all representations associated with a particular resource over time.
"However, there is no implication of uniqueness across representations of different resources (i.e., the same strong validator might be in use for representations of multiple resources at the same time and does not imply that those representations are equivalent)."
A collision-resistant hash function applied to the representation data is also sufficient if the data is available prior to the response header fields being sent and the digest does not need to be recalculated every time a validation request is received.
"In contrast, a ""weak validator"" is representation metadata that might not change for every change to the representation data."
"This weakness might be due to limitations in how the value is calculated, such as clock resolution, an inability to ensure uniqueness for all possible representations of the resource, or a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data."
An origin server SHOULD change a weak entity-tag whenever it considers prior representations to be unacceptable as a substitute for the current representation.
"In other words, a weak entity-tag ought to change whenever the origin server wants caches to invalidate old responses."
"For example, the representation of a weather report that changes in content every second, based on dynamic measurements, might be grouped into sets of equivalent representations (from the origin server's perspective) with the same weak validator in order to allow cached representations to be valid for a reasonable period of time (perhaps adjusted dynamically based on server load or weather quality)."
"Likewise, a representation's modification time, if defined with only one-second resolution, might be a weak validator if it is possible for the representation to be modified twice during a single second and retrieved between those modifications."
"Likewise, a validator is weak if it is shared by two or more representations of a given resource at the same time, unless those representations have identical representation data."
"For example, if the origin server sends the same validator for a representation with a gzip content coding applied as it does for a representation with no content coding, then that validator is weak."
"cache validation, partial content ranges, and ""lost update"" avoidance."
"Weak validators are only usable when the client does not require exact equality with previously obtained representation data, such as when validating a cache entry or limiting a web traversal to recent changes."
"An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([RFC7234]) results in a substantial reduction of HTTP traffic on the Internet and can be a significant factor in improving service scalability and reliability."
An origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time that it generates the Date field value for its response.
"This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated."
An origin server with a clock MUST NOT send a Last-Modified date that is later than the server's time of message origination (Date).
An origin server without a clock MUST NOT assign Last-Modified values to a response unless these values were associated with the resource by some other system or user with a reliable clock.
"A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules: o"
"The validator is being compared by an origin server to the actual current validator for the representation and, o  That origin server reliably knows that the associated representation did not change twice during the second covered by the presented validator."
"The validator is being compared by an intermediate cache to the validator stored in its cache entry for the representation, and o  That cache entry includes a Date value, which gives the time when the origin server sent the original response, and o  The presented Last-Modified time is at least 60 seconds before the Date value."
"An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short."
"The ""ETag"" header field in a response provides the current entity-tag for the selected representation, as determined at the conclusion of handling the request."
"An entity-tag is an opaque validator for differentiating between multiple representations of the same resource, regardless of whether those multiple representations are due to resource state changes over time, content negotiation resulting in multiple representations being valid at the same time, or both."
"An entity-tag consists of an opaque quoted string, possibly prefixed by a weakness indicator."
"ETag       = entity-tag entity-tag = [ weak ] opaque-tag weak       = %x57.2F ; ""W/"", case-sensitive opaque-tag = DQUOTE *etagc DQUOTE etagc      = %x21 / %x23-7E / obs-text ; VCHAR except double quotes, plus obs-text Note: Previously, opaque-tag was defined to be a quoted-string ([RFC2616], SectionÂ 3.11); thus, some recipients might perform backslash unescaping."
Servers therefore ought to avoid backslash characters in entity tags.
"An entity-tag can be more reliable for validation than a modification date in situations where it is inconvenient to store modification dates, where the one-second resolution of HTTP date values is not sufficient, or where modification dates are not consistently maintained."
"Examples: ETag: ""xyzzy"" ETag: W/""xyzzy"" ETag: """" being the default."
"If an origin server provides an entity-tag for a representation and the generation of that entity-tag does not satisfy all of the characteristics of a strong validator (Section 2.1), then the origin server MUST mark the entity-tag as weak by prefixing its opaque value with ""W/"" (case-sensitive)."
"The principle behind entity-tags is that only the service author knows the implementation of a resource well enough to select the most accurate and efficient validation mechanism for that resource, and that any such mechanism can be mapped to a simple sequence of octets for easy comparison."
"Since the value is opaque, there is no need for the client to be aware of how each entity-tag is constructed."
"Other implementations might use a collision-resistant hash of representation content, a combination of various file attributes, or a modification timestamp that has sub-second resolution."
"An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity-tag's use in conditional requests and evaluating cache freshness ([RFC7234]) can result in a substantial reduction of HTTP network traffic and can be a significant factor in improving service scalability and reliability."
"In this case, the response might or might not use the gzip content coding."
"ETag: ""123-b"" Content-Length: 43 Vary: Accept-Encoding Content-Type: text/plain Content-Encoding: gzip ...binary data..."
"In 200 (OK) responses to GET or HEAD, an origin server: o  SHOULD send an entity-tag validator unless it is not feasible to generate one."
"o  MAY send a weak entity-tag instead of a strong entity-tag, if performance considerations support the use of weak entity-tags, or if it is unfeasible to send a strong entity-tag."
"The user agent SHOULD provide a way to disable this, in case of difficulty."
o  SHOULD send both validators in cache validation requests if both an entity-tag and a Last-Modified value have been provided by the origin server.
"If-Match = ""*"" / 1#entity-tag Examples: If-Match: ""xyzzy"" If-Match: ""xyzzy"", ""r2d2xxxx"", ""c3piozzzz"" If-Match: * If-Match is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource (i.e., to methods to abort a request if the selected representation does not match one already stored (or partially stored) from a prior request."
"If the field-value is ""*"", the condition is false if the origin server does not have a current representation for the target resource."
"If the field-value is a list of entity-tags, the condition is false if none of the listed tags match the entity-tag of the selected representation."
"An origin server MUST NOT perform the requested method if a received If-Match condition evaluates to false; instead, the origin server MUST respond with either a) the 412 (Precondition Failed) status code or b) one of the 2xx (Successful) status codes if the origin server has verified that a state change is being requested and the final state is already reflected in the current state of the target resource (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or a compatible change was made by some other user agent)."
"In the latter case, the origin server MUST NOT send a validator header field in the response unless it can verify that the request is a duplicate of an immediately prior change made by the same user agent."
The If-Match header field can be ignored by caches and intermediaries because it is not applicable to a stored response.
"The ""If-None-Match"" header field makes the request method conditional on a recipient cache or origin server either not having any current representation of the target resource, when the field-value is ""*"", or having a selected representation with an entity-tag that does not match any of those listed in the field-value."
"A recipient MUST use the weak comparison function when comparing entity-tags for If-None-Match (Section 2.3.2), since weak entity-tags can be used for cache validation even if there have been changes to the representation data."
"If-None-Match = ""*"" / 1#entity-tag If-None-Match: ""xyzzy"" If-None-Match: W/""xyzzy"" If-None-Match: ""xyzzy"", ""r2d2xxxx"", ""c3piozzzz"" If-None-Match: W/""xyzzy"", W/""r2d2xxxx"", W/""c3piozzzz"" If-None-Match: * If-None-Match is primarily used in conditional GET requests to enable efficient updates of cached information with a minimum amount of transaction overhead."
"When a client desires to update one or more stored responses that have entity-tags, the client SHOULD generate an If-None-Match header field containing a list of those entity-tags when making a GET request; this allows recipient servers to send a 304 (Not Modified) response to indicate when one of those stored responses matches the selected representation."
"If-None-Match can also be used with a value of ""*"" to prevent an unsafe request method (e.g., PUT) from inadvertently modifying an existing representation of the target resource when the client believes that the resource does not have a current representation (SectionÂ 4.2.1 of [RFC7231])."
"This is a variation on the ""lost update"" problem that might arise if more than one client attempts to create an initial representation for the target resource."
"If the field-value is ""*"", the condition is false if the origin server has a current representation for the target resource."
"If the field-value is a list of entity-tags, the condition is false if one of the listed tags match the entity-tag of the selected representation."
"An origin server MUST NOT perform the requested method if the condition evaluates to false; instead, the origin server MUST respond with either a) the 304 (Not Modified) status code if the request method is GET or HEAD or b) the 412 (Precondition Failed) status code for all other request methods."
Transfer of the selected representation's data is avoided if that data has not changed.
If-Modified-Since = HTTP-date
"A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field; the condition in If-None-Match is considered to be a more accurate replacement for the condition in If-Modified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-None-Match."
"A recipient MUST ignore the If-Modified-Since header field if the received field-value is not a valid HTTP-date, or if the request method is neither GET nor HEAD."
If-Modified-Since is typically used for two distinct purposes: 1) to allow efficient updates of a cached representation that does not have an entity-tag and 2) to limit the scope of a web traversal to resources that have recently changed.
"This behavior is most interoperable for cases where clocks are poorly synchronized or when the server has chosen to only honor exact timestamp matches (due to a problem with Last-Modified dates that appear to go ""back in time"" when the origin server's clock is corrected or a representation is restored from an archived backup)."
"However, caches occasionally generate the field value based on other data, such as the Date header field of the cached message or the local clock time that the message was received, particularly when the cached message does not contain a Last-Modified field."
Origin servers that choose an exact timestamp match based on the selected representation's Last-Modified field will not be able to help the user agent limit its data transfers to only those changed during the specified window.
"The origin server SHOULD NOT perform the requested method if the selected representation's last modification date is earlier than or equal to the date provided in the field-value; instead, the origin server SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response."
This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation.
If-Unmodified-Since = HTTP-date
"A recipient MUST ignore If-Unmodified-Since if the request contains an If-Match header field; the condition in If-Match is considered to be a more accurate replacement for the condition in If-Unmodified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-Match."
A recipient MUST ignore the If-Unmodified-Since header field if the received field-value is not a valid HTTP-date.
"(e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on a resource that does not supply entity-tags with its representations (i.e., to prevent the ""lost update"" problem)."
It can also be used with safe methods to abort a request if the selected representation does not match one already stored (or partially stored) from a prior request.
"The origin server MUST NOT perform the requested method if the selected representation's last modification date is more recent than the date provided in the field-value; instead the origin server MUST respond with either a) the 412 (Precondition Failed) status code or b) one of the 2xx (Successful) status codes if the origin server has verified that a state change is being requested and the final state is already reflected in the current state of the target resource (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of that because the prior response message was lost or a compatible change was made by some other user agent)."
"In the latter case, the origin server MUST NOT send a validator header field in the response unless it can verify that the request is a duplicate of an immediately prior change made by the same user agent."
The If-Unmodified-Since header field can be ignored by caches and intermediaries because it is not applicable to a stored response.
"The ""If-Range"" header field provides a special conditional request mechanism that is similar to the If-Match and If-Unmodified-Since header fields but that instructs the recipient to ignore the Range header field if the validator doesn't match, resulting in transfer of the new selected representation instead of a 412 (Precondition Failed) response."
The 304 (Not Modified) status code indicates that a conditional GET or HEAD request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition evaluated to false.
"In other words, there is no need for the server to transfer a representation of the target resource because the request indicates that the client, which made the request therefore redirecting the client to make use of that stored representation as if it were the payload of a 200 (OK) response."
"Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field)."
A 304 response cannot contain a message-body; it is always terminated by the first empty line after the header fields.
The 412 (Precondition Failed) status code indicates that one or more conditions given in the request header fields evaluated to false when tested on the server.
A server MUST ignore all received preconditions if its response to the same request without those conditions would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed).
"In other words, redirects and failures take precedence over the evaluation of preconditions in conditional requests."
"cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation."
"Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE."
"Although conditional request header fields are defined as being usable with the HEAD method (to keep HEAD's semantics consistent with those of GET), there is no point in sending a conditional HEAD because a successful response is around the same size as a 304 (Not Modified) response and more useful than a 412 (Precondition Failed) response."
"In practice, the fields defined in this document are consistently implemented in a single, logical order, since ""lost update"" preconditions have more strict requirements than cache validation, a validated cache is more efficient than a partial response, and entity tags are presumed to be more accurate than date validators."
"A recipient cache or origin server MUST evaluate the request preconditions defined by this specification in the following order: 1.  When recipient is the origin server and If-Match is present, evaluate the If-Match precondition: *  if true, continue to step 3 *  if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 3.1)"
"If-Unmodified-Since is present, evaluate the If-Unmodified-Since precondition: *  if true, continue to step 3 *  if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 3.4) 3."
"When If-None-Match is present, evaluate the If-None-Match precondition: *  if true, continue to step 5 *  if false for GET/HEAD, respond 304 (Not Modified) *  if false for other methods, respond 412 (Precondition Failed) 4."
"When the method is GET or HEAD, If-None-Match is not present, and If-Modified-Since is present, evaluate the If-Modified-Since precondition: *  if true, continue to step 5 *  if false, respond 304 (Not Modified) 5."
"6.  Otherwise, *  all conditions are met, so perform the requested action and respond according to its success or failure."
"More general security considerations are addressed in HTTP ""Message Syntax and Routing"" [RFC7230] and ""Semantics and Content"" [RFC7231]."
"At best, they enable more efficient cache updates and optimistic concurrent writes when all participants are behaving nicely."
"At worst, the conditions will fail and the client will receive a response that is no more harmful than an HTTP exchange without conditional requests."
"For example, a site might deliberately construct a semantically invalid entity-tag that is unique to the user or user agent, send it in a cacheable response with a long freshness time, and then read that entity-tag in later conditional requests as a means of re-identifying that user or user agent."
