sentences
"The key words ""MUST"", ""MUST NOT"", ""REQUIRED"", ""SHALL"", ""SHALL NOT"", ""SHOULD"", ""SHOULD NOT"", ""RECOMMENDED"", ""MAY"", and ""OPTIONAL"" in this document are to be interpreted as described in [RFC2119]."
"It uses a case- insensitive token as a means to identify the authentication scheme, followed by additional information necessary for achieving separated list of parameters or a single sequence of characters capable of holding base64-encoded information."
"auth-scheme    = token auth-param     = token BWS ""="" BWS ( token / quoted-string ) token68        = 1*( ALPHA / DIGIT / ""-"" / ""."" / ""_"" / ""~"" / ""+"" / ""/"" ) *""="""
challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
Note: Many clients fail to parse a challenge that contains an unknown scheme.
"A workaround for this problem is to list well- supported schemes (such as ""basic"") first."
credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]
"Upon receipt of a request for a protected resource that omits credentials, contains invalid credentials (e.g., a bad password) or partial credentials (e.g., when the authentication scheme requires more than one round trip), an origin server SHOULD send a 401 (Unauthorized) response that contains a WWW-Authenticate header field with at least one (possibly new) challenge applicable to the requested resource."
A server that receives valid credentials that are not adequate to gain access ought to respond with the 403 (Forbidden) status code (Section 6.5.3 of [RFC7231]).
HTTP does not restrict applications to this simple challenge-response framework for access authentication.
"However, such additional mechanisms are not defined by this specification."
The 401 (Unauthorized) status code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.
"If the request included authentication credentials, then the 401 response indicates that authorization has been refused for those credentials."
"If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user agent SHOULD present the enclosed representation to the user, since it usually contains relevant diagnostic information."
A proxy forwarding a response MUST NOT modify any WWW-Authenticate fields in that response.
"User agents are advised to take special care in parsing the field value, as it might contain more than one challenge, and each challenge can contain a comma-separated list of authentication parameters."
"For instance: WWW-Authenticate: Newauth realm=""apps"", type=1, title=""Login to \""apps\"""", Basic realm=""simple"""
The challenge grammar production uses the list syntax as well.
"Therefore, a sequence of comma, whitespace, and comma can be considered either as applying to the preceding challenge, or to be an empty entry in the list of challenges."
"In practice, this ambiguity does not affect the semantics of the header field value and thus is harmless."
"The ""Authorization"" header field allows a user agent to authenticate itself with an origin server -- usually, but not necessarily, after receiving a 401 (Unauthorized) response."
"If a request is authenticated and a realm specified, the same credentials are presumed to be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise, such as credentials that vary according to a challenge value or using synchronized clocks)."
A proxy forwarding a request MUST NOT modify any Authorization fields in that request.
"However, when multiple proxies are used within the same administrative domain, such as office and regional caching proxies within a large corporate network, it is common for credentials to be generated by the user agent and passed through the hierarchy until consumed."
"Proxy-Authorization = credentials Unlike Authorization, the Proxy-Authorization header field applies only to the next inbound proxy that demanded authentication using the Proxy-Authenticate field."
"When multiple proxies are used in a chain, the Proxy-Authorization header field is consumed by the first inbound proxy that was expecting to receive credentials."
"There are certain aspects of the HTTP Authentication Framework that put constraints on how new authentication schemes can work: o  HTTP authentication is presumed to be stateless: all of the information necessary to authenticate a request MUST be provided in the request, rather than be dependent on the server remembering prior requests."
"Authentication based on, or bound to, the underlying connection is outside the scope of this specification and inherently flawed unless steps are taken to ensure that the connection cannot be used by any party other than the authenticated user (see Section 2.3 of [RFC7230])."
New schemes MUST NOT use it in a way incompatible with that definition.
"Thus, new schemes ought to use the auth-param syntax instead, because otherwise future extensions will be impossible."
This is necessary so that recipients can use a generic parser that applies to all authentication schemes.
"The fact that the value syntax for the ""realm"" parameter is restricted to quoted-string was a bad design choice not to be repeated for new parameters."
"Furthermore, it's good to describe the policy for defining new parameters (such as ""update the specification"" or ""use this registry"")."
"Therefore, new authentication schemes that choose not to carry credentials in the Authorization header field (e.g., using a newly defined header field) will need to explicitly disallow caching, by mandating the use of either Cache-Control request directives (e.g., ""no-store"", Section 5.2.1.5 of [RFC7234]) or response directives (e.g., ""private"")."
"HTTP header fields are registered within the ""Message Headers"" registry maintained at <http://www.iana.org/assignments/message-headers/>."
"Everything about the topic of HTTP authentication is a security consideration, so the list of considerations below is not exhaustive."
"The HTTP authentication framework does not define a single mechanism for maintaining the confidentiality of credentials; instead, each authentication scheme defines how the credentials are encoded prior to transmission."
"While this provides flexibility for the development of future authentication schemes, it is inadequate for the protection of existing schemes that provide no confidentiality on their own, or that do not sufficiently protect against replay attacks."
"Furthermore, if the server expects credentials that are specific to each individual user, the exchange of those credentials will have the effect of identifying that user even if the content within credentials remains confidential."
Existing HTTP clients and user agents typically retain authentication information indefinitely.
"HTTP does not provide a mechanism for the origin server to direct clients to discard these cached credentials, since the protocol has no awareness of how credentials are obtained revoking credentials can be specified as part of an authentication scheme definition."
"Circumstances under which credential caching can interfere with the application's security model include but are not limited to: o  Clients that have been idle for an extended period, following which the server might wish to cause the client to re-prompt the user for credentials."
"o  Applications that include a session termination indication (such as a ""logout"" or ""commit"" button on a page) after which the server side of the application ""knows"" that there is no further reason for the client to retain the credentials."
User agents that cache credentials are encouraged to provide a readily accessible mechanism for discarding cached credentials under user control.
"Possible mitigation strategies include restricting direct access to authentication credentials (i.e., not making the content of the Authorization request header field available), and separating protection spaces by using a different host name (or port number) for each party."
