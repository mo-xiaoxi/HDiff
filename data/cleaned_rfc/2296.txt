HTTP allows web site authors to put multiple versions (variants) of the same information under a single URL.  Transparent content negotiation [2] is a mechanism for automatically selecting the best variant when the URL is accessed.  A remote variant selection algorithm can be used by a HTTP server to choose a best variant on behalf of a negotiating user agent.  The use of a remote algorithm can speed up the transparent negotiation process by eliminating a request-response round trip.
This document defines the remote variant selection algorithm with the version number 1.0.  The algorithm computes whether the Accept- headers in the request contain sufficient information to allow a choice, and if so, which variant must be chosen.
This specification uses the terminology and notation of the HTTP transparent content negotiation specification [2].
This section defines the remote variant selection algorithm with the version number 1.0.  To implement this definition, a server MAY run any algorithm which gives equal results.
Note: According to [2], servers are always free to return a list response instead of running a remote algorithm.  Therefore, whenever a server may run a remote algorithm, it may also run a partial implementation of the algorithm, provided that the partial implementation always returns List_response when it cannot compute the real result.
The algorithm is always run for a particular request on a particular transparently negotiable resource.  It takes the following information as input.
The variant list of the resource, as present in the Alternates header of the resource. 2. (Partial) Information about capabilities and preferences of the user agent for this particular request, as given in the Accept- headers of the request.
The extremely low source quality value ensures that the fallback variant only gets chosen if all other options are exhausted.
The Accept- headers contain sufficient information to make a choice on behalf of the user agent possible, and the best variant MAY be returned in a choice response.
The Accept- headers do not contain sufficient information to make a choice on behalf of the user agent possible.  A list response MUST be returned, allowing the user agent to make the choice itself.
As a first step in the remote variant selection algorithm, the overall qualities of the individual variants in the list are computed.
where round5 is a function which rounds a floating point value to 5 decimal places after the point, and where the factors qs, qt, qc, ql, and qf are determined as follows. qs Is the source quality factor in the variant description.
qt The media type quality factor is 1 if there is no type attribute in the variant description, or if there is no Accept header in the request.  Otherwise, it is the quality assigned by the Accept header to the media type in the type attribute.
Note: If a type is matched by none of the elements of an Accept header, the Accept header assigns the quality factor 0 to that type.
qc The charset quality factor is 1 if there is no charset attribute in the variant description, or if there is no Accept-Charset header in the request.  Otherwise, the charset quality factor is the quality assigned by the Accept-Charset header to the charset in the charset attribute.
ql The language quality factor is 1 if there is no language attribute in the variant description, or if there is no Accept-Language header in the request.  Otherwise, the language quality factor is the highest quality factor assigned by the Accept-Language header to any one of the languages listed in the language attribute.
qf The features quality factor is 1 if there is no features attribute in the variant description, or if there is no Accept-Features header in the request.  Otherwise, it is the quality degradation factor for the features attribute, see section 6.4 of [2].
A computed overall quality value can be either definite or speculative.  An overall quality value is definite if it was computed without using any wildcard characters '*' in the Accept- headers, and without the need to use the absence of a particular Accept- header. An overall quality value is speculative otherwise.
As an example, in the previous section, the quality values of paper.html.en and paper.html.fr are definite, and the quality value of paper.ps.en is speculative because the type application/postscript was matched to the range */*.
If an Accept, Accept-Charset, Accept-Language, or Accept-Features header is missing from the request, add this header with an empty field.
Delete any media ranges containing a wildcard character '*' from the Accept header.  Delete any wildcard '*' from the Accept-Charset, Accept-Language, and Accept-Features headers.
The best variant, as determined by the remote variant selection algorithm, is the one variant with the highest overall quality value, or, if there are multiple variants which share the highest overall quality, the first variant in the list with this value.
c. the variant resource is a neighbor of the negotiable resource.  This last condition exists to ensure that a security-related restriction on the generation of choice responses is met, see sections 10.2 and 14.2 of [2].
In all other cases, the end result is List_response.
I accept image/gif with a quality of 0.9, and assign quality factors up to 1.0 to other media types.  If this information is insufficient to make a choice on my behalf, do not make a choice but send the list of variants'.
I accept image/gif with a quality of 0.9, and all other media types with a quality of 1.0'.
This section discusses how user agents can use the remote algorithm in an optimal way.  This section is not normative, it is included for informational purposes only.
then the algorithm would choose the Greek variant.  In general, the Accept- header with the biggest spread between its quality factors gets the highest precedence.  If a user agent allows the user to set the quality factors for some headers, while other factors are hard- coded, it should use a low spread on the hard-coded factors and a high spread on the user-supplied factors, so that the user settings take precedence over the built-in settings.
the remote algorithm will compute a definite overall quality of 0.9 for x.gif and a speculative overall quality value of 1.0 for x.tiff. As the best variant has a speculative quality value, the algorithm will not choose x.tiff, but return a list response, after which the selection algorithm of the user agent will correctly choose x.gif. The end result is the same as if the long Accept- header above had been sent.
Thus, user agents can vary the length of the Accept- headers to get an optimal tradeoff between the speed with which the first request is transmitted, and the chance that the remote algorithm has enough information to eliminate a second request.
According to the HTTP/1.1 specification [1], the complete absence of an Accept header from the request is equivalent to the presence of `Accept: */*'.  Thus, if the Accept header is collapsed to `Accept: */*', a user agent may omit it entirely.  An Accept-Charset, Accept- Language, or Accept-Features header which only contains `*' may also be omitted.
This will increase the chance that the remote variant selection algorithm will have sufficient information to choose on behalf of the user agent, thereby optimizing the negotiation process.  A good strategy for dynamic extension would be to extend the headers with those media types, languages, charsets, and feature tags mentioned in the variant lists of past responses from the server.
Retrieve Y in a subsequent request. This is sub-optimal because it takes time.
Display X anyway.  This is sub-optimal because it makes the end result of the negotiation process dependent on factors that can randomly change.  For the next request on the same resource, and intermediate proxy cache could return a list response, which would cause the local algorithm to choose and retrieve Y instead of X.  Compared to a stable representation, a representation which randomly switches between X and Y (say, the version with and without frames) has a very low subjective quality for most users.
As both alternatives above are unattractive, a user agent should try to avoid the above situation altogether.  The sections below discuss how this can be done.
If the user agent enables the remote algorithm in this specification, it should generally use a local algorithm which closely resembles the remote algorithm.  The algorithm should for example also use multiplication to combine quality factors.  If the user agent combines quality factors by addition, it would be more advantageous to define a new remote variant selection algorithm, with a new major version number, for use by this agent.
in order to account for special interdependencies between dimensions, which are due to limitations of the user agent.  For example, if the user agent, for some reason, cannot handle the iso-8859-7 charset when rendering text/plain documents, the q_adjust factor would be 0 when the text/plain - iso-8859-7 combination is present in the variant description, and 1 otherwise.
By selectively withholding information from the remote variant selection algorithm, the user agent can ensure that the remote algorithm will never make a choice if the local q_adjust is less than 1.  For example, to prevent the remote algorithm from ever returning a text/plain - iso-8859-7 choice response, the user agent should take care to never produce a request which exactly specifies the quality factors of both text/plain and iso-8859-7.  The omission of either factor from a request will cause the overall quality value of any text/plain - iso-8859-7 variant to be speculative, and variants with speculative quality values can never be returned in a choice response.
In general, if the local q_adjust does not equal 1 for a particular combination X - Y - Z, then a remote choice can be prevented by always omitting at least one of the elements of the combination from the Accept- headers, and adding a suitable wildcard pattern to match the omitted element, if such a pattern is not already present.
This specification introduces no security and privacy considerations not already covered in [2].  See [2] for a discussion of privacy risks connected to the sending of Accept- headers.
Work on HTTP content negotiation has been done since at least 1993. The authors are unable to trace the origin of many of the ideas incorporated in this document.  Many members of the HTTP working group have contributed to the negotiation model in this specification.  The authors wish to thank the individuals who have commented on earlier versions of this document, including Brian Behlendorf, Daniel DuBois, Ted Hardie, Larry Masinter, and Roy T. Fielding.
Copyright (C) The Internet Society (1998).  All Rights Reserved.
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works.  However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
This document and the information contained herein is provided on an "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
