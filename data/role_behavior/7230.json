[
    {
        "if": {},
        "result": {},
        "role": "server",
        "origin": "Hence, a server MUST NOT assume that two requests on the same connection are from the same user agent unless the connection is secured and specific to that agent."
    },
    {
        "if": {},
        "result": {},
        "role": "client",
        "origin": "Any client or server MAY employ a cache, though a cache cannot be used by a server while it is acting as a tunnel."
    },
    {
        "if": {},
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT generate protocol elements that convey a meaning that is known by that sender to be false."
    },
    {
        "if": {},
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules."
    },
    {
        "if": {},
        "result": {},
        "role": "sender",
        "origin": "Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message)."
    },
    {
        "if": {},
        "result": {},
        "role": "recipient",
        "origin": "At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages."
    },
    {
        "if": {},
        "result": {},
        "role": "recipient",
        "origin": "A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics."
    },
    {
        "if": {},
        "result": {},
        "role": "recipient",
        "origin": "Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct."
    },
    {
        "if": [],
        "result": [],
        "role": "client",
        "origin": "A client SHOULD send a request version equal to the highest version to which the client is conformant and whose major version is no higher than the highest version supported by the server, if this is known."
    },
    {
        "if": {},
        "result": {},
        "role": "client",
        "origin": "A client MUST NOT send a version to which it is not conformant."
    },
    {
        "if": [],
        "result": [
            {}
        ],
        "role": "client",
        "origin": "A client MAY send a lower request version if it is known that the server incorrectly implements the HTTP specification, but only after the client has attempted at least one normal request and determined from the response status code or header fields (e.g., Server) that the server improperly handles higher request versions."
    },
    {
        "if": {},
        "result": {},
        "role": "server",
        "origin": "A server SHOULD send a response version equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request."
    },
    {
        "if": {},
        "result": {},
        "role": "server",
        "origin": "A server MUST NOT send a version to which it is not conformant."
    },
    {
        "if": [
            {}
        ],
        "result": [
            {
                "response_version": "HTTP/1.0"
            }
        ],
        "role": "server",
        "origin": "A server MAY send an HTTP/1.0 response to a request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol."
    },
    {
        "if": [],
        "result": [],
        "role": "recipient",
        "origin": "When an HTTP message is received with a major version number that the recipient implements, but a higher minor version number than what the recipient implements, the recipient SHOULD process the message as if it were in the highest minor version within that major version to which the recipient is conformant."
    },
    {
        "if": {
            "not_exists": "host",
            "assign": "host"
        },
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT generate an \"http\" URI with an empty host identifier."
    },
    {
        "if": {
            "exist": "URI"
        },
        "result": {},
        "role": "recipient",
        "origin": "A recipient that processes such a URI reference MUST reject it as invalid."
    },
    {
        "if": {},
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT generate the userinfo subcomponent (and its \"@\" delimiter) when an \"http\" URI reference is generated within a message as a request target or header field value."
    },
    {
        "if": {
            "exist": "URI"
        },
        "result": {
            "error_status": true
        },
        "role": "recipient",
        "origin": "Before making use of an \"http\" URI reference received from an untrusted source, a recipient SHOULD parse for userinfo and treat its presence as an error; it is likely being used to obscure the authority for the sake of phishing attacks."
    },
    {
        "if": [
            {
                "not_exists": "port"
            }
        ],
        "result": [],
        "role": "agent",
        "origin": "All of the requirements listed above for the \"http\" scheme are also requirements for the \"https\" scheme, except that TCP port 443 is the default if the port subcomponent is empty or not given, and the user agent MUST ensure that its connection to the origin server is secured through the use of strong encryption, end-to-end, prior to sending the first HTTP request."
    },
    {
        "if": {},
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT send whitespace between the start-line and the first header field."
    },
    {
        "if": {},
        "result": {},
        "role": "recipient",
        "origin": "A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated)."
    },
    {
        "if": {
            "exist": "request-target",
            "invalid": "Request"
        },
        "result": {
            "status_code": "400",
            "error_status": true
        },
        "role": "Recipients",
        "origin": "Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded."
    },
    {
        "if": {
            "invalid": "request-line",
            "not_final": "request-line"
        },
        "result": {},
        "role": "recipient",
        "origin": "A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain."
    },
    {
        "if": {
            "not_implement": "method"
        },
        "result": {
            "status_code": "501"
        },
        "role": "server",
        "origin": "A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code."
    },
    {
        "if": {
            "not_exists": "reason-phrase"
        },
        "result": {},
        "role": "client",
        "origin": "A client SHOULD ignore the reason-phrase content."
    },
    {
        "if": {
            "exist": "Connection"
        },
        "result": {},
        "role": "proxy",
        "origin": "A proxy MUST forward unrecognized header fields unless the field-name is listed in the Connection header field (Section 6.1) or the proxy is specifically configured to block, or otherwise transform, such fields."
    },
    {
        "if": {},
        "result": {},
        "role": "server",
        "origin": "A server MUST NOT apply a request to the target resource until the entire request header section is received, since later header fields might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that would impact request processing."
    },
    {
        "if": {},
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT generate multiple header fields with the same field name in a message unless either the entire field value for that header field is defined as a comma-separated list [i.e., #(values)] or the header field is a well-known exception (as noted below)."
    },
    {
        "if": {},
        "result": {},
        "role": "recipient",
        "origin": "A recipient MAY combine multiple header fields with the same field name into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma."
    },
    {
        "if": {},
        "result": {},
        "role": "proxy",
        "origin": "The order in which header fields with the same field name are received is therefore significant to the interpretation of the combined field value; a proxy MUST NOT change the order of these field values when forwarding a message."
    },
    {
        "if": {},
        "result": {},
        "role": "sender",
        "origin": "For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to white out invalid or unwanted protocol elements during in-place message filtering."
    },
    {
        "if": {
            "exist": "response"
        },
        "result": {
            "status_code": "400",
            "error_status": true
        },
        "role": "server",
        "origin": "A server MUST reject any received request message that contains whitespace between a header field-name and colon with a response code of 400 (Bad Request)."
    },
    {
        "if": {},
        "result": {},
        "role": "proxy",
        "origin": "A proxy MUST remove any such whitespace from a response message before forwarding the message downstream."
    },
    {
        "if": {
            "not_exists": "obs-fold"
        },
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT generate a message that includes line folding (i.e., that has any field-value that contains a match to the obs-fold rule) unless the message is intended for packaging within the message/http media type."
    },
    {
        "if": {},
        "result": {
            "status_code": "400",
            "error_status": true
        },
        "role": "server",
        "origin": "A server that receives an obs-fold in a request message that is not within a message/http container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream."
    },
    {
        "if": {},
        "result": {
            "status_code": "502"
        },
        "role": "proxy",
        "origin": "A proxy or gateway that receives an obs-fold in a response message that is not within a message/http container MUST either discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream."
    },
    {
        "if": {
            "multiple": "obs-fold"
        },
        "result": {},
        "role": "agent",
        "origin": "A user agent that receives an obs-fold in a response message that is not within a message/http container MUST replace each received obs-fold with one or more SP octets prior to interpreting the field value."
    },
    {
        "if": [],
        "result": [],
        "role": "Recipients",
        "origin": "Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash."
    },
    {
        "if": {
            "not_exists": "quoted-pair"
        },
        "result": {},
        "role": "sender",
        "origin": "A sender SHOULD NOT generate a quoted-pair in a quoted-string except where necessary to quote DQUOTE and backslash octets occurring within that string."
    },
    {
        "if": {},
        "result": {},
        "role": "sender",
        "origin": "A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses [\"(\" and \")\"] and backslash octets occurring within that comment."
    },
    {
        "if": {
            "exist": "chunk"
        },
        "result": {},
        "role": "recipient",
        "origin": "A recipient MUST be able to parse the chunked transfer coding (Section 4.1) because it plays a crucial role in framing messages when the payload body size is not known in advance."
    },
    {
        "if": {
            "chunked_not_twice": true
        },
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT apply chunked more than once to a message body (i.e., chunking an already chunked message is not allowed)."
    },
    {
        "if": [],
        "result": [],
        "role": "sender",
        "origin": "If any transfer coding other than chunked is applied to a request payload body, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed."
    },
    {
        "if": [
            {
                "exist": "response"
            }
        ],
        "result": [
            {
                "close_connection": true
            }
        ],
        "role": "sender",
        "origin": "If any transfer coding other than chunked is applied to a response payload body, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection."
    },
    {
        "if": {
            "not_exists": "Transfer-Encoding"
        },
        "result": {},
        "role": "server",
        "origin": "A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content)."
    },
    {
        "if": {
            "not_exists": "Transfer-Encoding"
        },
        "result": {},
        "role": "server",
        "origin": "A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of [RFC7231])."
    },
    {
        "if": {
            "not_exists": "Transfer-Encoding"
        },
        "result": {},
        "role": "client",
        "origin": "A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 (or later) requests; such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response."
    },
    {
        "if": {
            "not_exists": "Transfer-Encoding",
            "request_version": "HTTP/1.1"
        },
        "result": {},
        "role": "server",
        "origin": "A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later)."
    },
    {
        "if": {},
        "result": {
            "status_code": "501"
        },
        "role": "server",
        "origin": "A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented)."
    },
    {
        "if": {
            "exist": "Transfer-Encoding",
            "not_exists": "Content-Length",
            "no_both_TE_CL": true
        },
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field."
    },
    {
        "if": {
            "exist": "Content-Length",
            "not_exists": "Transfer-Encoding",
            "not_first": "Transfer-Encoding"
        },
        "result": {},
        "role": "agent",
        "origin": "A user agent SHOULD send a Content-Length in a request message when no Transfer-Encoding is sent and the request method defines a meaning for an enclosed payload body."
    },
    {
        "if": {
            "not_exists": "Content-Length"
        },
        "result": {},
        "role": "agent",
        "origin": "A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body."
    },
    {
        "if": [],
        "result": [],
        "role": "server",
        "origin": "A server MAY send a Content-Length header field in a response to a HEAD request (Section 4.3.2 of [RFC7231]); a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload body of a response if the same request had used the GET method."
    },
    {
        "if": {
            "exist": "Content-Length"
        },
        "result": {},
        "role": "server",
        "origin": "A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 4.1 of [RFC7232]); a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload body of a 200 (OK) response to the same request."
    },
    {
        "if": {
            "not_exists": "Content-Length"
        },
        "result": {},
        "role": "server",
        "origin": "A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content)."
    },
    {
        "if": {
            "not_exists": "Content-Length"
        },
        "result": {},
        "role": "server",
        "origin": "A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of [RFC7231])."
    },
    {
        "if": {},
        "result": {},
        "role": "recipient",
        "origin": "Since there is no predefined limit to the length of a payload, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows (Section 9.3)."
    },
    {
        "if": [
            {
                "exist": "Transfer-Encoding"
            }
        ],
        "result": [],
        "role": "server",
        "origin": "If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection."
    },
    {
        "if": {
            "not_exists": "Content-Length"
        },
        "result": {},
        "role": "sender",
        "origin": "A sender MUST remove the received Content-Length field prior to forwarding such a message downstream."
    },
    {
        "if": [
            {
                "not_exists": "Transfer-Encoding",
                "exist": "Content-Length",
                "multiple": "Content-Length"
            },
            {
                "not_exists": "Transfer-Encoding",
                "invalid": "Content-Length"
            }
        ],
        "result": [
            {
                "error_status": true
            }
        ],
        "role": "recipient",
        "origin": "If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error."
    },
    {
        "if": [
            {
                "not_exists": "Transfer-Encoding",
                "exist": "Content-Length",
                "multiple": "Content-Length"
            },
            {
                "not_exists": "Transfer-Encoding",
                "invalid": "Content-Length"
            }
        ],
        "result": [
            {
                "status_code": "400",
                "close_connection": true
            }
        ],
        "role": "server",
        "origin": "If message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value, the server MUST respond with a 400 (Bad Request) status code and then close the connection."
    },
    {
        "if": [
            {
                "not_exists": "Transfer-Encoding",
                "exist": "Content-Length",
                "multiple": "Content-Length"
            },
            {
                "not_exists": "Transfer-Encoding",
                "invalid": "Content-Length"
            }
        ],
        "result": [
            {
                "close_connection": true,
                "status_code": "502"
            }
        ],
        "role": "proxy",
        "origin": "If message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client."
    },
    {
        "if": [],
        "result": [
            {
                "close_connection": true
            }
        ],
        "role": "agent",
        "origin": "If this is a response message received by a user agent, the user agent MUST close the connection to the server and discard the received response."
    },
    {
        "if": {},
        "result": {},
        "role": "server",
        "origin": "Since there is no way to distinguish a successfully completed, close-delimited message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible."
    },
    {
        "if": {
            "exist": "Content-Length",
            "not_exists": "Content-Length"
        },
        "result": {
            "status_code": "411"
        },
        "role": "server",
        "origin": "A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required)."
    },
    {
        "if": [
            {}
        ],
        "result": [],
        "role": "agent",
        "origin": "A user agent that sends a request containing a message body MUST send a valid Content-Length header field if it does not know the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response."
    },
    {
        "if": [
            {
                "final": "response",
                "not_first": "response"
            }
        ],
        "result": [
            {}
        ],
        "role": "agent",
        "origin": "If the final response to the last request on a connection has been completely received and there remains additional data to read, a user agent MAY discard the remaining data or attempt to determine if that data belongs as part of the prior response body, which might be the case if the prior message's Content-Length value is incorrect."
    },
    {
        "if": {},
        "result": {},
        "role": "client",
        "origin": "A client MUST NOT process, cache, or forward such extra data as a separate response, since such behavior would be vulnerable to cache poisoning."
    },
    {
        "if": {},
        "result": {
            "close_connection": true,
            "error_status": true
        },
        "role": "server",
        "origin": "A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection."
    },
    {
        "if": {
            "not_final": "response"
        },
        "result": {
            "error_status": true
        },
        "role": "client",
        "origin": "A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete."
    },
    {
        "if": {
            "not_exists": "ext",
            "request_version": "HTTP/1.1"
        },
        "result": {},
        "role": "agent",
        "origin": "An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF."
    },
    {
        "if": {},
        "result": {},
        "role": "agent",
        "origin": "If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length."
    },
    {
        "if": {},
        "result": {},
        "role": "server",
        "origin": "In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line."
    },
    {
        "if": {},
        "result": {},
        "role": "recipient",
        "origin": "Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR."
    },
    {
        "if": {},
        "result": {},
        "role": "recipients",
        "origin": "Although the request-line and status-line grammar rules require that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR."
    },
    {
        "if": {},
        "result": {
            "status_code": "400"
        },
        "role": "server",
        "origin": "When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response."
    },
    {
        "if": {
            "not_exists": "Content-Encoding",
            "no_both_TE_CL": true
        },
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT generate a trailer that contains a field necessary for message framing (e.g., Transfer-Encoding and Content-Length), routing (e.g., Host), request modifiers (e.g., controls and conditionals in Section 5 of [RFC7231]), authentication (e.g., see [RFC7235] and [RFC6265]), response control data (e.g., see Section 7.1 of [RFC7231]), or determining how to process the payload (e.g., Content-Encoding, Content-Type, Content-Range, and Trailer)."
    },
    {
        "if": [
            {
                "exist": "end"
            }
        ],
        "result": [],
        "role": "recipient",
        "origin": "When a chunked message containing a non-empty trailer is received, the recipient MAY process the fields (aside from those forbidden above) as if they were appended to the message's header section."
    },
    {
        "if": [],
        "result": [],
        "role": "recipient",
        "origin": "A recipient MUST ignore (or consider as an error) any fields that are forbidden to be sent in a trailer, since processing them as if they were present in the header section might bypass external security filters."
    },
    {
        "if": {
            "exist": "trailer",
            "assign": "trailer"
        },
        "result": {},
        "role": "server",
        "origin": "Unless the request includes a TE header field indicating \"trailers\" is acceptable, as described in Section 4.3, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive."
    },
    {
        "if": {},
        "result": {},
        "role": "recipient",
        "origin": "A recipient SHOULD consider \"x-compress\" to be equivalent to \"compress\"."
    },
    {
        "if": {},
        "result": {},
        "role": "recipient",
        "origin": "A recipient SHOULD consider \"x-gzip\" to be equivalent to \"gzip\"."
    },
    {
        "if": {
            "not_exists": "chunk",
            "request_version": "HTTP/1.1"
        },
        "result": {
            "response_version": "HTTP/1.1"
        },
        "role": "client",
        "origin": "A client MUST NOT send the chunked transfer coding name in TE; chunked is always acceptable for HTTP/1.1 recipients."
    },
    {
        "if": {
            "multiple": "codings",
            "assign": "codings"
        },
        "result": {},
        "role": "client",
        "origin": "When multiple transfer codings are acceptable, the client MAY rank the codings by preference using a case-insensitive \"q\" parameter (similar to the qvalues used in content negotiation fields, Section 5.3.1 of [RFC7231])."
    },
    {
        "if": {
            "exist": "Connection",
            "multiple": "Connection",
            "assign": "Connection",
            "twice": "Connection"
        },
        "result": {},
        "role": "sender",
        "origin": "Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a \"TE\" connection option within the Connection header field (Section 6.1) in order to prevent the TE field from being forwarded by intermediaries that do not support its semantics."
    },
    {
        "if": {
            "exist": "Trailer"
        },
        "result": {},
        "role": "sender",
        "origin": "When a message includes a message body encoded with the chunked transfer coding and the sender desires to send metadata in the form of trailer fields at the end of the message, the sender SHOULD generate a Trailer header field before the message body to indicate which fields will be present in the trailers."
    },
    {
        "if": [
            {
                "not_exists": "path"
            }
        ],
        "result": [],
        "role": "client",
        "origin": "If the target URI's path component is empty, the client MUST send \"/\" as the path within the origin-form of request-target."
    },
    {
        "if": [
            {
                "not_exists": "query"
            }
        ],
        "result": [],
        "role": "proxy",
        "origin": "If a proxy receives an OPTIONS request with an absolute-form of request-target in which the URI has an empty path and no query component, then the last proxy on the request chain MUST send a request-target of \"*\" when it forwards the request to the indicated origin server."
    },
    {
        "if": [
            {
                "not_implement": "authority"
            }
        ],
        "result": [],
        "role": "client",
        "origin": "If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field-value."
    },
    {
        "if": {
            "exist": "Host",
            "first": "Host"
        },
        "result": {},
        "role": "agent",
        "origin": "Since the Host field-value is critical information for handling a request, a user agent SHOULD generate Host as the first header field following the request-line."
    },
    {
        "if": {
            "exist": "absolute-form",
            "not_exists": "Host"
        },
        "result": {},
        "role": "proxy",
        "origin": "When a proxy receives a request with an absolute-form of request-target, the proxy MUST ignore the received Host header field (if any) and instead replace it with the host information of the request-target."
    },
    {
        "if": {},
        "result": {},
        "role": "request",
        "origin": "A proxy that forwards such a request MUST generate a new Host field-value based on the received request-target rather than forward the received Host field-value."
    },
    {
        "if": {
            "multiple": "Host",
            "invalid": "Host",
            "request_version": "HTTP/1.1"
        },
        "result": {
            "status_code": "400",
            "error_status": true,
            "response_version": "HTTP/1.1"
        },
        "role": "server",
        "origin": "A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field or a Host header field with an invalid field-value."
    },
    {
        "if": {
            "multiple": "response"
        },
        "result": {},
        "role": "client",
        "origin": "A client that has more than one outstanding request on a connection MUST maintain a list of outstanding requests in the order sent and MUST associate each received response message on that connection to the highest ordered request that has not yet received a final (non-1xx) response."
    },
    {
        "if": {
            "exist": "Connection"
        },
        "result": {},
        "role": "intermediary",
        "origin": "An intermediary not acting as a tunnel MUST implement the Connection header field, as specified in Section 6.1, and exclude fields from being forwarded that are only intended for the incoming connection."
    },
    {
        "if": {},
        "result": {},
        "role": "intermediary",
        "origin": "An intermediary MUST NOT forward a message to itself unless it is protected from an infinite request loop."
    },
    {
        "if": {
            "exist": "Via",
            "multiple": "Via",
            "twice": "Via"
        },
        "result": {},
        "role": "gateway",
        "origin": "An HTTP-to-HTTP gateway MUST send an appropriate Via header field in each inbound request message and MAY send a Via header field in forwarded response messages."
    },
    {
        "if": [
            {
                "not_implement": "port",
                "not_final": "port",
                "not_first": "port"
            }
        ],
        "result": [],
        "role": "recipient",
        "origin": "If a port is not provided, a recipient MAY interpret that as meaning it was received on the default TCP port, if any, for the received-protocol."
    },
    {
        "if": {},
        "result": {},
        "role": "sender",
        "origin": "A sender SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms."
    },
    {
        "if": {
            "multiple": "protocol"
        },
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT combine entries that have different received-protocol values."
    },
    {
        "if": {},
        "result": {},
        "role": "proxy",
        "origin": "A proxy MUST NOT transform the payload (Section 3.3 of [RFC7231]) of a message that contains a no-transform cache-control directive (Section 5.2 of [RFC7234])."
    },
    {
        "if": {},
        "result": {},
        "role": "proxy",
        "origin": "A proxy MAY transform the payload of a message that does not contain a no-transform cache-control directive."
    },
    {
        "if": {},
        "result": {},
        "role": "proxy",
        "origin": "A proxy SHOULD NOT modify header fields that provide information about the endpoints of the communication chain, the resource state, or the selected representation (other than the payload) unless the field's definition specifically allows such modification or the modification is deemed necessary for privacy or security."
    },
    {
        "if": {},
        "result": {},
        "role": "proxy",
        "origin": "In order to avoid confusing downstream recipients, a proxy or gateway MUST remove or replace any received connection options before forwarding the message."
    },
    {
        "if": {},
        "result": {},
        "role": "sender",
        "origin": "A sender MUST NOT send a connection option corresponding to a header field that is intended for all recipients of the payload."
    },
    {
        "if": {},
        "result": {
            "close_connection": true
        },
        "role": "client",
        "origin": "A client that does not support persistent connections MUST send the \"close\" connection option in every request message."
    },
    {
        "if": {
            "multiple": "response",
            "assign": "response"
        },
        "result": {
            "close_connection": true
        },
        "role": "server",
        "origin": "A server that does not support persistent connections MUST send the \"close\" connection option in every response message that does not have a 1xx (Informational) status code."
    },
    {
        "if": {
            "exist": "response"
        },
        "result": {
            "close_connection": true
        },
        "role": "server",
        "origin": "A server MUST read the entire request message body or close the connection after sending its response, since otherwise the remaining data on a persistent connection would be misinterpreted as the next request."
    },
    {
        "if": {},
        "result": {},
        "role": "server",
        "origin": "A proxy server MUST NOT maintain a persistent connection with an HTTP/1.0 client (see Section 19.7.1 of [RFC2068] for information and discussion of the problems with the Keep-Alive header field implemented by many HTTP/1.0 clients)."
    },
    {
        "if": [],
        "result": [],
        "role": "client",
        "origin": "When an inbound connection is closed prematurely, a client MAY open a new connection and automatically retransmit an aborted sequence of requests if all of those requests have idempotent methods (Section 4.2.2 of [RFC7231])."
    },
    {
        "if": {},
        "result": {},
        "role": "proxy",
        "origin": "A proxy MUST NOT automatically retry non-idempotent requests."
    },
    {
        "if": {},
        "result": {},
        "role": "agent",
        "origin": "A user agent MUST NOT automatically retry a request with a non- idempotent method unless it has some means to know that the request semantics are actually idempotent, regardless of the method, or some means to detect that the original request was never applied."
    },
    {
        "if": {},
        "result": {},
        "role": "client",
        "origin": "A client SHOULD NOT automatically retry a failed automatic retry."
    },
    {
        "if": [],
        "result": [],
        "role": "requests",
        "origin": "A client that pipelines requests SHOULD retry unanswered requests if the connection closes before it receives all of the corresponding responses."
    },
    {
        "if": [],
        "result": [],
        "role": "client",
        "origin": "When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 6.6)."
    },
    {
        "if": {},
        "result": {},
        "role": "agent",
        "origin": "A user agent SHOULD NOT pipeline requests after a non-idempotent method, until the final response status code for that method has been received, unless the user agent has a means to detect and recover from partial failure conditions involving the pipelined sequence."
    },
    {
        "if": [
            {
                "not_first": "response"
            }
        ],
        "result": [],
        "role": "intermediary",
        "origin": "If the inbound connection fails before receiving a response, the pipelining intermediary MAY attempt to retry a sequence of requests that have yet to receive a response if the requests all have idempotent methods; otherwise, the pipelining intermediary SHOULD forward any received responses and then close the corresponding outbound connection(s) so that the outbound user agent(s) can recover accordingly."
    },
    {
        "if": {},
        "result": {
            "close_connection": true
        },
        "role": "client",
        "origin": "A client or server that wishes to time out SHOULD issue a graceful close on the connection."
    },
    {
        "if": {},
        "result": {},
        "role": "server",
        "origin": "A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads, rather than terminate connections with the expectation that clients will retry."
    },
    {
        "if": {},
        "result": {},
        "role": "client",
        "origin": "A client sending a message body SHOULD monitor the network connection for an error response while it is transmitting the request."
    },
    {
        "if": [],
        "result": [
            {
                "close_connection": true
            }
        ],
        "role": "client",
        "origin": "If the client sees a response that indicates the server does not wish to receive the message body and is closing the connection, the client SHOULD immediately cease transmitting the body and close its side of the connection."
    },
    {
        "if": {},
        "result": {
            "close_connection": true
        },
        "role": "client",
        "origin": "A client that sends a \"close\" connection option MUST NOT send further requests on that connection (after the one containing \"close\") and MUST close the connection after reading the final response message corresponding to this request."
    },
    {
        "if": {},
        "result": {},
        "role": "server",
        "origin": "The server MUST NOT process any further requests received on that connection."
    },
    {
        "if": {
            "exist": "response",
            "assign": "response",
            "not_first": "end"
        },
        "result": {
            "close_connection": true
        },
        "role": "server",
        "origin": "A server that sends a \"close\" connection option MUST initiate a close of the connection (see below) after it sends the response containing \"close\"."
    },
    {
        "if": [],
        "result": [
            {
                "close_connection": true
            }
        ],
        "role": "client",
        "origin": "A client that receives a \"close\" connection option MUST cease sending requests on that connection and close the connection after reading the response message containing the \"close\"; if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server."
    },
    {
        "if": [],
        "result": [],
        "role": "server",
        "origin": "A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection."
    },
    {
        "if": {
            "exist": "Upgrade"
        },
        "result": {},
        "role": "server",
        "origin": "A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field."
    },
    {
        "if": {
            "exist": "Connection",
            "multiple": "protocol",
            "assign": "Connection"
        },
        "result": {},
        "role": "sender",
        "origin": "When Upgrade is sent, the sender MUST also send a Connection header field (Section 6.1) that contains an \"upgrade\" connection option, in order to prevent Upgrade from being accidentally forwarded by intermediaries that might not implement the listed protocols."
    },
    {
        "if": {
            "not_exists": "Upgrade",
            "request_version": "HTTP/1.0"
        },
        "result": {},
        "role": "server",
        "origin": "A server MUST ignore an Upgrade header field that is received in an HTTP/1.0 request."
    }
]